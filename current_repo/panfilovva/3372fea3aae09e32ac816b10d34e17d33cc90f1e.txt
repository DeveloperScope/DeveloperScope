==== File: .gitlab-ci.yml ====
@@ -35,6 +35,11 @@ lint_code:
     - tar -czf $backup_archive.tar.gz $SITE_ROOT
     - ls -las $CI_PROJECT_DIR
     - cp -r $CI_PROJECT_DIR/* $SITE_ROOT
+    - if grep -q '^COMMIT_TAG=' $SITE_ROOT/.env; then
+        sudo sed -i "s/^COMMIT_TAG=.*/COMMIT_TAG=$CI_COMMIT_TAG/" $SITE_ROOT/.env;
+      else
+        echo "COMMIT_TAG=$CI_COMMIT_TAG" | sudo tee -a $SITE_ROOT/.env;
+      fi
     - sudo python -m pip config set global.index https://nx.alfastrah.ru/repository/pypi-proxy/pypi
     - sudo python -m pip config set global.index-url https://nx.alfastrah.ru/repository/pypi-proxy/simple
     - sudo python -m pip config set global.trusted-host nx.alfastrah.ru


==== File: accesslist/admin.py ====
@@ -1,40 +1,15 @@
-import secrets
-import string
-from datetime import timedelta
-from django.utils import timezone
-
 from django.contrib import admin
-from django.http import HttpResponseRedirect
-from django.urls import path
 
-from .models import ACL, ACLGitlabStore, AccessToken
+from .models import ACL, ACLGitlabStore
 
 
 @admin.register(ACL)
 class ACLAdmin(admin.ModelAdmin):
-    list_display = ('project', 'status', 'owner', 'id', 'taskid', 'created')
-    list_filter = ('status', 'created')
+    list_display = ("project", "status", "owner", "id", "taskid", "created")
+    list_filter = ("status", "created")
     list_display_links = list_display
 
 
 @admin.register(ACLGitlabStore)
 class ACLGitlabStoreAdmin(admin.ModelAdmin):
-    list_display = ('project', 'gitlab_url')
-
-
-@admin.register(AccessToken)
-class AccessTokenAdmin(admin.ModelAdmin):
-    change_list_template = 'admin/access_token/change_list.html'
-    list_display = ('id', 'is_active', 'expires_at', 'created_at', 'deactivated_at')
-
-    def get_urls(self):
-        urls = super().get_urls()
-        custom_urls = [
-            path('generate_token/', self.generate_token, name='generate_token'),
-        ]
-        return custom_urls + urls
-
-    def generate_token(self, request):
-        token = ''.join(secrets.choice(string.ascii_letters + string.digits) for _ in range(32))
-        AccessToken.objects.create(token=token, is_active=True, expires_at=timezone.now() + timedelta(hours=1))
-        return HttpResponseRedirect(request.META.get('HTTP_REFERER'))
+    list_display = ("project", "gitlab_url")


==== File: accesslist/migrations/0037_aclgitlabstore.py ====
@@ -0,0 +1,21 @@
+# Generated by Django 3.1.6 on 2023-10-09 07:59
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('accesslist', '0036_auto_20221109_1641'),
+    ]
+
+    operations = [
+        migrations.CreateModel(
+            name='ACLGitlabStore',
+            fields=[
+                ('id', models.BigAutoField(db_index=True, primary_key=True, serialize=False)),
+                ('project', models.CharField(blank=True, max_length=128)),
+                ('gitlab_url', models.URLField(blank=True)),
+            ],
+        ),
+    ]


==== File: accesslist/migrations/0038_acl_git_filename.py ====
@@ -0,0 +1,18 @@
+# Generated by Django 3.1.6 on 2023-11-10 07:28
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('accesslist', '0037_aclgitlabstore'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='acl',
+            name='git_filename',
+            field=models.CharField(blank=True, default='', max_length=256),
+        ),
+    ]


==== File: accesslist/migrations/0039_auto_20231115_2045.py ====
@@ -0,0 +1,28 @@
+# Generated by Django 3.1.6 on 2023-11-15 17:45
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('accesslist', '0038_acl_git_filename'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='acl',
+            name='last_status',
+            field=models.CharField(default='', max_length=20),
+        ),
+        migrations.AddField(
+            model_name='acl',
+            name='last_status_change_date',
+            field=models.DateTimeField(blank=True, null=True),
+        ),
+        migrations.AddField(
+            model_name='acl',
+            name='status_complete_date',
+            field=models.DateTimeField(blank=True, null=True),
+        ),
+    ]


==== File: accesslist/migrations/0040_auto_20231204_1121.py ====
@@ -0,0 +1,22 @@
+# Generated by Django 3.1.6 on 2023-12-04 08:21
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('accesslist', '0039_auto_20231115_2045'),
+    ]
+
+    operations = [
+        migrations.RemoveField(
+            model_name='acl',
+            name='status_complete_date',
+        ),
+        migrations.AddField(
+            model_name='acl',
+            name='days_in_work',
+            field=models.IntegerField(blank=True, null=True),
+        ),
+    ]


==== File: accesslist/models.py ====
@@ -1,9 +1,10 @@
 from datetime import datetime, timezone
+
+from django.contrib.auth.models import User
 from django.db import models
 from django.db.models.signals import pre_save
 from django.dispatch import receiver
-from django.contrib.auth.models import User
-from django.utils import timezone as django_timezone
+
 from ownerlist.utils import MakeTemporaryToken
 from teams.models import Team
 
@@ -13,60 +14,87 @@ class ACL(models.Model):
     id = models.UUIDField(db_index=True, editable=False)
     acltext = models.JSONField(blank=True, null=True, default=list)
     is_executed = models.BooleanField(null=True, default=False)
-    owner = models.ForeignKey(User, null=True, on_delete=models.SET_NULL,  related_name='ownername') #default=Owners.get_default_owner
-    #approve = models.ForeignKey(User, null=True, on_delete=models.SET_NULL, related_name='approve_persone')
+    owner = models.ForeignKey(
+        User, null=True, on_delete=models.SET_NULL, related_name="ownername"
+    )  # default=Owners.get_default_owner
+    # approve = models.ForeignKey(User, null=True, on_delete=models.SET_NULL, related_name='approve_persone')
     # tags = models.ManyToManyField(Tags, blank=True, verbose_name='tags')
-    approve = models.ManyToManyField(User, blank=True, verbose_name='approves')
+    approve = models.ManyToManyField(User, blank=True, verbose_name="approves")
     taskid = models.CharField(blank=True, default="", editable=True, max_length=64)
     comment = models.CharField(blank=True, default="", editable=True, max_length=256)
     project = models.CharField(blank=True, max_length=128)
     created = models.DateField(blank=True, auto_now_add=True)
     token = models.CharField(blank=True, default="", editable=True, max_length=10)
-    activity = models.CharField(blank=True, default="", editable=True, max_length=256, null=True,)
+    activity = models.CharField(
+        blank=True,
+        default="",
+        editable=True,
+        max_length=256,
+        null=True,
+    )
     APL_STATUS = [
-        ('NOTFL', 'Не заполнено'),
-        ('FL', 'Заполнено'),
-        ('FLY', 'В процессе'),
-        ('CMP', 'Выполнено'),
-        ('WTE', 'Ожидает согласования'),
-        ('APRV', 'Согласовано'),
-        ('CNL', 'Отклонено'),
-        ('JOB', 'На исполнении')
+        ("NOTFL", "Не заполнено"),
+        ("FL", "Заполнено"),
+        ("FLY", "В процессе"),
+        ("CMP", "Выполнено"),
+        ("WTE", "Ожидает согласования"),
+        ("APRV", "Согласовано"),
+        ("CNL", "Отклонено"),
+        ("JOB", "На исполнении"),
     ]
-    status = models.CharField(choices=APL_STATUS, default='NOTFL', blank=True, max_length=20)
+    status = models.CharField(
+        choices=APL_STATUS, default="NOTFL", blank=True, max_length=20
+    )
     team = models.ForeignKey(Team, null=True, on_delete=models.SET_NULL, editable=True)
-    git_filename = models.CharField(blank=True, default="", editable=True, max_length=256)
+    git_filename = models.CharField(
+        blank=True, default="", editable=True, max_length=256
+    )
 
-    last_status = models.CharField(max_length=20, default='')
+    last_status = models.CharField(max_length=20, default="")
     last_status_change_date = models.DateTimeField(blank=True, null=True)
     days_in_work = models.IntegerField(blank=True, null=True)
 
     def save(self, *args, **kwargs):
-        if self.token is None or self.token == '':
+        if self.token is None or self.token == "":
             self.token = MakeTemporaryToken()
-        if self.status == 'JOB' and self.last_status_change_date:
-            self.days_in_work = (datetime.now().date() - self.last_status_change_date.date()).days
+        if self.status == "JOB" and self.last_status_change_date:
+            self.days_in_work = (
+                datetime.now().date() - self.last_status_change_date.date()
+            ).days
         super().save(*args, **kwargs)
 
     def days_in_job_status(self):
-        if self.status == 'JOB' and self.last_status_change_date:
-            self.days_in_work = (datetime.now().date() - self.last_status_change_date.date()).days
+        if self.status == "JOB" and self.last_status_change_date:
+            self.days_in_work = (
+                datetime.now().date() - self.last_status_change_date.date()
+            ).days
             self.save()
             return self.days_in_work
-        elif self.status in ["CMP", "CNL"] and self.last_status_change_date and self.days_in_work != None:
+        elif (
+            self.status in ["CMP", "CNL"]
+            and self.last_status_change_date
+            and self.days_in_work != None
+        ):
             return self.days_in_work
         else:
-            return ''
+            return ""
+
 
 @receiver(pre_save, sender=ACL)
 def update_days_in_work(sender, instance, **kwargs):
-    if instance.status != instance._state.adding and instance.status != instance.last_status:
+    if (
+        instance.status != instance._state.adding
+        and instance.status != instance.last_status
+    ):
         if instance.status not in ["CMP", "CNL"]:
             instance.last_status = instance.status
             instance.last_status_change_date = datetime.now(timezone.utc)
-            instance.days_in_work = (datetime.now().date() - instance.last_status_change_date.date()).days
+            instance.days_in_work = (
+                datetime.now().date() - instance.last_status_change_date.date()
+            ).days
             instance.days_in_job_status()
 
+
 class AclHistory(models.Model):
     id = models.BigAutoField(db_index=True, primary_key=True)
     pkid = models.UUIDField(db_index=True, editable=True)
@@ -74,25 +102,8 @@ class AclHistory(models.Model):
     time = models.DateTimeField(blank=True, default=datetime.now)
     activity = models.CharField(max_length=255)
 
+
 class ACLGitlabStore(models.Model):
     id = models.BigAutoField(db_index=True, primary_key=True)
     project = models.CharField(blank=True, max_length=128)
     gitlab_url = models.URLField(blank=True)
-
-class AccessToken(models.Model):
-    token = models.CharField(max_length=255, unique=True)
-    is_active = models.BooleanField(default=True)
-    created_at = models.DateTimeField(auto_now_add=True)
-    deactivated_at = models.DateTimeField(null=True, blank=True)
-
-    #
-    expires_at = models.DateTimeField(null=True, blank=True)
-    #
-
-    def __str__(self):
-        return self.token
-
-@receiver(pre_save, sender=AccessToken)
-def set_deactivated_at(sender, instance, **kwargs):
-    if not instance.is_active:
-        instance.deactivated_at = django_timezone.now()


==== File: accesslist/tasks.py ====
@@ -1,12 +0,0 @@
-from django.utils import timezone
-from celery import shared_task
-from .models import AccessToken
-
-
-@shared_task
-def deactivate_expired_tokens():
-    expired_tokens = AccessToken.objects.filter(expires_at__lte=timezone.now(), is_active=True)
-    for token in expired_tokens:
-        token.is_active = False
-        token.deactivated_at = timezone.now()
-        token.save()


==== File: accesslist/templates/admin/access_token/change_list.html ====
@@ -1,7 +0,0 @@
-{% extends 'admin/change_list.html' %}
-
-{% block content %}
-    <button type="submit"><a href="generate_token/">Generate Token</a></button>
-
-    {{ block.super }}
-{% endblock %}
\ No newline at end of file


==== File: accesslist/urls.py ====
@@ -1,4 +1,5 @@
-from django.urls import path, re_path, include
+from django.urls import include, path, re_path
+
 from .views import *
 
 urlpatterns = [
@@ -6,69 +7,180 @@ urlpatterns = [
     path("welcome/", AclDemo.as_view(), name="acldemo_urls"),
     path("history/", Aclhistory.as_view(), name="aclhistory_urls"),
     path("history/<uuid:acl_id>/", Aclhistory.as_view(), name="aclhistory_urls"),
-    path("history/status/<str:acl_status>/", Aclhistory.as_view(), name="aclhistory_urls_filter_status"),
-    path("history/project/<str:project_name>/", Aclhistory.as_view(), name="aclhistory_urls_filter_project"),
+    path(
+        "history/status/<str:acl_status>/",
+        Aclhistory.as_view(),
+        name="aclhistory_urls_filter_status",
+    ),
+    path(
+        "history/project/<str:project_name>/",
+        Aclhistory.as_view(),
+        name="aclhistory_urls_filter_project",
+    ),
     path("history/acl_pusher/", check_taskid_and_status, name="acl_pusher"),
-    path("taskstatus/<str:taskid>/", taskstatus, name='taskstatus_urls'),
+    path("taskstatus/<str:taskid>/", taskstatus, name="taskstatus_urls"),
     path("instruction/", AclInstruction.as_view(), name="aclinstruction_urls"),
-
     path("api/get_acl_by_ip/", APIACLInfoView.as_view()),  # api
-
-    re_path("info/", include([
-        re_path(r"^$", AclCreate.as_view(), name="aclcreate_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclCreate.as_view(), name="aclcreate_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclCreate.as_view(), name="aclcreate_new_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/download_file_docx_md/$", makeAndDownloadMdAndDocx, name='acl_download_file'),
-    ])),
-
-    re_path("internal/", include([
-        re_path(r"^$", AclCreate.as_view(), name="aclinternal_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclCreate_internal.as_view(), name="aclinternal_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclCreate_internal.as_view(), name="aclinternal_urls"),
-    ])),
-
-    re_path("external/", include([
-        re_path(r"^$", AclCreate_external.as_view(), name="aclexternal_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclCreate_external.as_view(), name="aclexternal_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclCreate_external.as_view(), name="aclexternal_urls"),
-    ])),
-
-    re_path("traffic/", include([
-        re_path(r"^$", AclCreate_traffic.as_view(), name="acltraffic_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclCreate_traffic.as_view(), name="acltraffic_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclCreate_traffic.as_view(), name="acltraffic_urls"),
-    ])),
-
-    re_path("dmz/", include([
-        re_path(r"^$", AclCreate_dmz.as_view(), name="acldmz_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclCreate_dmz.as_view(), name="acldmz_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclCreate_dmz.as_view(), name="acldmz_urls"),
-    ])),
-
-    re_path("overview/", include([
-        re_path(r"^$", AclCreate_dmz.as_view(), name="acloverview_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclOver.as_view(), name="acloverview_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", AclOver.as_view(), name="acloverview_urls"),
-    ])),
-
-    re_path("approve/", include([
-        re_path(r"^$", Acl_approve.as_view(), name="acl_approve_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", Acl_approve.as_view(), name="acl_approve_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", Acl_approve.as_view(), name="acl_approve_urls"),
-    ])),
-
-    re_path("pending/", include([
-        re_path(r"^$", Acl_approve.as_view(), name="acl_pending_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", Acl_pending.as_view(), name="acl_pending_urls"), #(?P<token>[0-9a-z]{10})/
-        #re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", Acl_pending.as_view(), name="acl_pending_urls"),
-    ])),
-
-    re_path("prepare/", include([
-        re_path(r"^$", AclPrepare.as_view(), name="acl_prepare_urls"),
-        re_path(r"^(?P<acl_id>[0-9a-f-]+)/$", AclPrepare.as_view(), name="acl_prepare_urls"),  # (?P<token>[0-9a-z]{10})/
-        # re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", Acl_pending.as_view(), name="acl_pending_urls"),
-    ])),
-    path("checkip/<str:ip>/", CheckIp, name='check_ip_urls'),
+    re_path(
+        "info/",
+        include(
+            [
+                re_path(r"^$", AclCreate.as_view(), name="aclcreate_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclCreate.as_view(),
+                    name="aclcreate_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclCreate.as_view(),
+                    name="aclcreate_new_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/download_file_docx_md/$",
+                    makeAndDownloadMdAndDocx,
+                    name="acl_download_file",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "internal/",
+        include(
+            [
+                re_path(r"^$", AclCreate.as_view(), name="aclinternal_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclCreate_internal.as_view(),
+                    name="aclinternal_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclCreate_internal.as_view(),
+                    name="aclinternal_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "external/",
+        include(
+            [
+                re_path(r"^$", AclCreate_external.as_view(), name="aclexternal_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclCreate_external.as_view(),
+                    name="aclexternal_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclCreate_external.as_view(),
+                    name="aclexternal_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "traffic/",
+        include(
+            [
+                re_path(r"^$", AclCreate_traffic.as_view(), name="acltraffic_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclCreate_traffic.as_view(),
+                    name="acltraffic_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclCreate_traffic.as_view(),
+                    name="acltraffic_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "dmz/",
+        include(
+            [
+                re_path(r"^$", AclCreate_dmz.as_view(), name="acldmz_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclCreate_dmz.as_view(),
+                    name="acldmz_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclCreate_dmz.as_view(),
+                    name="acldmz_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "overview/",
+        include(
+            [
+                re_path(r"^$", AclCreate_dmz.as_view(), name="acloverview_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclOver.as_view(),
+                    name="acloverview_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    AclOver.as_view(),
+                    name="acloverview_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "approve/",
+        include(
+            [
+                re_path(r"^$", Acl_approve.as_view(), name="acl_approve_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/new/$",
+                    Acl_approve.as_view(),
+                    name="acl_approve_urls",
+                ),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    Acl_approve.as_view(),
+                    name="acl_approve_urls",
+                ),
+            ]
+        ),
+    ),
+    re_path(
+        "pending/",
+        include(
+            [
+                re_path(r"^$", Acl_approve.as_view(), name="acl_pending_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    Acl_pending.as_view(),
+                    name="acl_pending_urls",
+                ),  # (?P<token>[0-9a-z]{10})/
+                # re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", Acl_pending.as_view(), name="acl_pending_urls"),
+            ]
+        ),
+    ),
+    re_path(
+        "prepare/",
+        include(
+            [
+                re_path(r"^$", AclPrepare.as_view(), name="acl_prepare_urls"),
+                re_path(
+                    r"^(?P<acl_id>[0-9a-f-]+)/$",
+                    AclPrepare.as_view(),
+                    name="acl_prepare_urls",
+                ),  # (?P<token>[0-9a-z]{10})/
+                # re_path(r"^(?P<acl_id>[0-9a-f-]+)/new/$", Acl_pending.as_view(), name="acl_pending_urls"),
+            ]
+        ),
+    ),
+    path("checkip/<str:ip>/", CheckIp, name="check_ip_urls"),
     path("remove/", AclRemove, name="acl_remove"),
     path("change/", acl_stage_change, name="acl_stage_change"),
     path("gitcheck/", Gitcheck, name="aclgit_urls"),
@@ -76,11 +188,14 @@ urlpatterns = [
     path("git_upload_template/", upload_acl_from_git, name="gitlab_upload_acl"),
     path("git_get_files/", get_gitlab_files, name="git_get_files"),
     path("git_update_projects/", sync_gitlab_projects, name="git_projects_sync"),
-    path("project_filter_by_department/", get_project_filter_by_department, name="get_project_filter"),
+    path(
+        "project_filter_by_department/",
+        get_project_filter_by_department,
+        name="get_project_filter",
+    ),
     path("set_teamid/", set_team_id, name="set_team_id"),
     path("act/<str:acl_id>/<str:job>/<str:do>/", act),
     path("task/<str:acl_id>/", task, name="aclcheck_status_urls"),
     path("task/<str:acl_id>/status", TaskStatus, name="aclcheck_status_urls"),
-    re_path("$^", ACldefault, name="acldefault_urls")
+    re_path("$^", ACldefault, name="acldefault_urls"),
 ]
-


==== File: accesslist/views.py ====
@@ -1,166 +1,225 @@
-from functools import wraps
-
-import requests
-from django.forms import model_to_dict
-from django.shortcuts import render, redirect, get_object_or_404
-from django.template.loader import render_to_string
-from django.utils.decorators import method_decorator
-from django.views.generic import View
-from django.http import HttpResponseRedirect, HttpResponseForbidden, HttpResponseNotFound, FileResponse, JsonResponse
-from django.urls import reverse
-from django.contrib import messages
-from django.http import HttpResponse
-from .models import ACL, ACLGitlabStore, AccessToken
-from ownerlist.models import Owners, Iplist
-import os
-from ownerlist.utils import make_doc, MakeMarkDown, request_handler, is_valid_uuid, ip_status, logger, get_client_ip, \
-    MakeTemporaryToken, ParseDocx, get_gitlab_project_info
-from ownerlist.utils import FORM_APPLICATION_KEYS, FORM_URLS, BaseView, GitWorker, BASE_DIR, UpdateCallBackStatus, \
-    ClearSessionMeta, upload_file_handler, omni_check_status, SendMessageToApprove
-from ownerlist.utils import send_onmitracker, send_to_mattermost
-from ownerlist.utils import get_files_from_gitlab, convert_md_to_dict, get_acl_from_gitlab
-from ownerlist.utils import acl_sending_retry_checking
-from ownerlist.utils import sync_acl_portal_projects_list
 import json
+import os
+import re
+import sys
+import threading
 import uuid
-from django.views.decorators.csrf import csrf_exempt
-from django.core.paginator import Paginator
+from inspect import stack
+from time import sleep
+
+import requests
 from django.conf import settings
+from django.contrib import messages
 from django.contrib.auth.mixins import LoginRequiredMixin
-from django.core.cache import cache
-import re
-import sys
 from django.contrib.auth.models import User
-from .forms import Approve_form
-from django.db.models import Q
-from django.core.mail import EmailMessage
 from django.contrib.messages import get_messages
-from teams.models import Block, Team
-from inspect import stack
-from time import sleep
+from django.core.cache import cache
+from django.core.mail import EmailMessage
+from django.core.paginator import Paginator
 from django.db import transaction
-import threading
-
+from django.db.models import Q
+from django.forms import model_to_dict
+from django.http import (
+    FileResponse,
+    HttpResponse,
+    HttpResponseForbidden,
+    HttpResponseNotFound,
+    HttpResponseRedirect,
+)
+from django.shortcuts import get_object_or_404, redirect, render
+from django.template.loader import render_to_string
+from django.urls import reverse
+from django.views.decorators.csrf import csrf_exempt
+from django.views.generic import View
+from drf_yasg.utils import swagger_auto_schema
+from rest_framework import serializers, status
+from rest_framework.permissions import IsAdminUser
+from rest_framework.response import Response
 from rest_framework.views import APIView
+from rest_framework_api_key.permissions import HasAPIKey
+
+from ownerlist.models import Iplist, Owners
+from ownerlist.utils import (
+    BASE_DIR,
+    FORM_APPLICATION_KEYS,
+    FORM_URLS,
+    BaseView,
+    ClearSessionMeta,
+    GitWorker,
+    MakeMarkDown,
+    MakeTemporaryToken,
+    ParseDocx,
+    SendMessageToApprove,
+    UpdateCallBackStatus,
+    acl_sending_retry_checking,
+    convert_md_to_dict,
+    get_acl_from_gitlab,
+    get_client_ip,
+    get_files_from_gitlab,
+    get_gitlab_project_info,
+    ip_status,
+    is_valid_uuid,
+    logger,
+    make_doc,
+    omni_check_status,
+    request_handler,
+    send_onmitracker,
+    send_to_mattermost,
+    sync_acl_portal_projects_list,
+    upload_file_handler,
+)
+from teams.models import Block, Team
+
+from .forms import Approve_form
+from .models import ACL, ACLGitlabStore
 
+tasklist = ["ACT_MAKE_DOCX", "ACT_MAKE_GIT", "ACT_OMNI"]
+jobs = ["docx", "git", "omni"]
+# геморрой с выкаткой
 
-tasklist = ['ACT_MAKE_DOCX', 'ACT_MAKE_GIT', 'ACT_OMNI']
-jobs = ['docx', 'git', 'omni']
-#геморрой с выкаткой
 
 class ObjectMixin:
     """Миксин обработки запросов и отобращение страниц"""
+
     template = None
     url = None
 
     def get(self, request, acl_id=None):
         context = {}
         tmp = None
-        #Очищаем кеш активностей (бага с быстрым выполнением JOB)
+        # Очищаем кеш активностей (бага с быстрым выполнением JOB)
         cache.set(acl_id, {})
         if acl_id is None:
-            if 'uuid' in request.session is not None:
-                if request.session['uuid']:
-                    return redirect(reverse(self.url, kwargs={'acl_id': request.session['uuid']}))
-
-            if 'HTTP_REFERER' in request.META.keys():
-                if reverse(FORM_URLS[0]) in request.META.get('HTTP_REFERER'):
+            if "uuid" in request.session is not None:
+                if request.session["uuid"]:
+                    return redirect(
+                        reverse(self.url, kwargs={"acl_id": request.session["uuid"]})
+                    )
+
+            if "HTTP_REFERER" in request.META.keys():
+                if reverse(FORM_URLS[0]) in request.META.get("HTTP_REFERER"):
                     # Заполняем uuid для нового acl
                     ClearSessionMeta()
-                    request.session['uuid'] = str(uuid.uuid4())
-                    request.session['LOCAL_STORAGE'] = {}
-                    request.session['taskid'] = None
-                    return HttpResponseRedirect(reverse(FORM_URLS[1], kwargs={'acl_id': request.session['uuid']}))
+                    request.session["uuid"] = str(uuid.uuid4())
+                    request.session["LOCAL_STORAGE"] = {}
+                    request.session["taskid"] = None
+                    return HttpResponseRedirect(
+                        reverse(
+                            FORM_URLS[1], kwargs={"acl_id": request.session["uuid"]}
+                        )
+                    )
         else:
-            if 'uuid' in request.session : #is not None
-                  if '/new/' in request.path:
-                      if str(acl_id) != request.session['uuid']:
-                         return HttpResponseRedirect(reverse(FORM_URLS[0]))
-                  elif str(acl_id) == request.session['uuid']:
-                     response = reverse(self.url, kwargs={'acl_id': request.session['uuid']}) #aclcreate_new_urls
-                     #Временный workaround
-                     if 'new' not in response:
-                         response += "new"
-                     return redirect(response)
-
-            if '/new/' not in request.path:
-                #ClearSessionMeta()
+            if "uuid" in request.session:  # is not None
+                if "/new/" in request.path:
+                    if str(acl_id) != request.session["uuid"]:
+                        return HttpResponseRedirect(reverse(FORM_URLS[0]))
+                elif str(acl_id) == request.session["uuid"]:
+                    response = reverse(
+                        self.url, kwargs={"acl_id": request.session["uuid"]}
+                    )  # aclcreate_new_urls
+                    # Временный workaround
+                    if "new" not in response:
+                        response += "new"
+                    return redirect(response)
+
+            if "/new/" not in request.path:
+                # ClearSessionMeta()
                 tmp = get_object_or_404(ACL, id=str(acl_id))
 
-                request.session['LOCAL_STORAGE'] = json.loads(tmp.acltext)
-                request.session['taskid'] = tmp.taskid or ''
+                request.session["LOCAL_STORAGE"] = json.loads(tmp.acltext)
+                request.session["taskid"] = tmp.taskid or ""
 
-                if request.META.get('HTTP_REFERER', '') == '' and tmp.status in ['WTE', 'APRV', 'CNL']:
+                if request.META.get("HTTP_REFERER", "") == "" and tmp.status in [
+                    "WTE",
+                    "APRV",
+                    "CNL",
+                ]:
                     if tmp.approve == request.user or request.user.is_staff:
-                        context.update({'acl_owner': tmp.owner})
-                    #else:
-                        response = HttpResponseRedirect(reverse('acl_pending_urls', kwargs=({'acl_id': acl_id})))
-                        response['Location'] += "?token={}".format(tmp.token)
+                        context.update({"acl_owner": tmp.owner})
+                        # else:
+                        response = HttpResponseRedirect(
+                            reverse("acl_pending_urls", kwargs=({"acl_id": acl_id}))
+                        )
+                        response["Location"] += "?token={}".format(tmp.token)
                         return response
 
                     if tmp.approve == request.user:
-                        context.update({'debtor': 'True',
-                                        'token': tmp.token})
+                        context.update({"debtor": "True", "token": tmp.token})
 
-                context.update({
-                    'status': str(tmp.status),
-                    'app_person': tmp.approve
-                })
+                context.update({"status": str(tmp.status), "app_person": tmp.approve})
 
                 if tmp.team is not None:
-                    context.update({'team_block': tmp.team.included_teams.all()[0]})
-
-            if 'traffic' in request.path:
-                context.update({'widgets': ["input__domain_source",
-                                           "input__ip_source",
-                                           "input__domain_dest",
-                                           "input__ip__external",
-                                           "input__host_port",
-                                           "input__application_port",
-                                           "input_descr",
-                                           "input_is_reserve"]})
-            if '/info/' in request.path:
+                    context.update({"team_block": tmp.team.included_teams.all()[0]})
+
+            if "traffic" in request.path:
+                context.update(
+                    {
+                        "widgets": [
+                            "input__domain_source",
+                            "input__ip_source",
+                            "input__domain_dest",
+                            "input__ip__external",
+                            "input__host_port",
+                            "input__application_port",
+                            "input_descr",
+                            "input_is_reserve",
+                        ]
+                    }
+                )
+            if "/info/" in request.path:
                 if tmp:
-                    activity = tmp.activity.split(';')
-                    context.update({'ACT': activity,
-                                    'team': tmp.team})
+                    activity = tmp.activity.split(";")
+                    context.update({"ACT": activity, "team": tmp.team})
                     for ACT in activity:
-                        if '.git' not in ACT:
+                        if ".git" not in ACT:
                             request.session[ACT] = True
                         # else:
                         #     request.session['GIT_URL'] = ACT
-            if 'LOCAL_STORAGE' in request.session:
-                if 'acl_create_info.html' in request.session["LOCAL_STORAGE"]:
-                    acl_proj = request.session["LOCAL_STORAGE"]["acl_create_info.html"][4]
-                    acl_git_file = request.session["LOCAL_STORAGE"]["acl_create_info.html"][-1]
-                    latest_acl_obj = ACL.objects.filter(project=acl_proj, git_filename=acl_git_file, status__in=["JOB", "CMP"])
+            if "LOCAL_STORAGE" in request.session:
+                if "acl_create_info.html" in request.session["LOCAL_STORAGE"]:
+                    acl_proj = request.session["LOCAL_STORAGE"]["acl_create_info.html"][
+                        4
+                    ]
+                    acl_git_file = request.session["LOCAL_STORAGE"][
+                        "acl_create_info.html"
+                    ][-1]
+                    latest_acl_obj = ACL.objects.filter(
+                        project=acl_proj,
+                        git_filename=acl_git_file,
+                        status__in=["JOB", "CMP"],
+                    )
                     if len(latest_acl_obj) > 0:
                         latest_acl_obj = latest_acl_obj.latest("created")
                         latest_local_storage = json.loads(latest_acl_obj.acltext)
                         latest_uuid = latest_acl_obj.id
                         latest_project = latest_acl_obj.project
                         latest_git_file = latest_acl_obj.git_filename
-                        context['latest_local_storage'] = latest_local_storage
-                        context['latest_uuid'] = latest_uuid
-                        context['latest_project'] = latest_project
-                        context['latest_git_file'] = latest_git_file
+                        context["latest_local_storage"] = latest_local_storage
+                        context["latest_uuid"] = latest_uuid
+                        context["latest_project"] = latest_project
+                        context["latest_git_file"] = latest_git_file
                     else:
-                        print('Последнего acl не найдено.')
-                context.update({'acl_id': str(acl_id),
-                                'FULL_STORAGE': request.session['LOCAL_STORAGE'],
-                                'FORM_APPLICATION_KEYS': FORM_APPLICATION_KEYS,
-                                'template_name': self.template,
-                                'blocks': Block.objects.all(),
-                                'acl_gitlab_store': ACLGitlabStore.objects.all()
-                                })
+                        print("Последнего acl не найдено.")
+                context.update(
+                    {
+                        "acl_id": str(acl_id),
+                        "FULL_STORAGE": request.session["LOCAL_STORAGE"],
+                        "FORM_APPLICATION_KEYS": FORM_APPLICATION_KEYS,
+                        "template_name": self.template,
+                        "blocks": Block.objects.all(),
+                        "acl_gitlab_store": ACLGitlabStore.objects.all(),
+                    }
+                )
                 if tmp and len(tmp.taskid) >= 3:
                     if re.match(r"\d{4,}", str(tmp.taskid)):
-                            context.update({'taskid': str(tmp.taskid)})
+                        context.update({"taskid": str(tmp.taskid)})
 
-                if self.template not in request.session['LOCAL_STORAGE']:
+                if self.template not in request.session["LOCAL_STORAGE"]:
                     return render(request, self.template, context=context)
                 else:
-                    context['LOCAL_STORAGE'] = request.session['LOCAL_STORAGE'][self.template]
+                    context["LOCAL_STORAGE"] = request.session["LOCAL_STORAGE"][
+                        self.template
+                    ]
                     return render(request, self.template, context=context)
 
         return HttpResponseRedirect(reverse(FORM_URLS[0]))
@@ -169,83 +228,112 @@ class ObjectMixin:
         if acl_id is not None:
             tmp = request_handler(request, self.template)
             current_page = FORM_URLS.index(self.url)
-            NO_MAKE_JOB = request.GET.get('request', 'yes')
+            NO_MAKE_JOB = request.GET.get("request", "yes")
             if tmp:
                 try:
-                    if len(tmp[self.template]) == 0 or len(tmp[self.template][0]) == 0 or len(tmp[self.template][0][0]) == 0:
-                        if self.template in request.session['LOCAL_STORAGE']:
-                            del request.session['LOCAL_STORAGE'][self.template]
+                    if (
+                        len(tmp[self.template]) == 0
+                        or len(tmp[self.template][0]) == 0
+                        or len(tmp[self.template][0][0]) == 0
+                    ):
+                        if self.template in request.session["LOCAL_STORAGE"]:
+                            del request.session["LOCAL_STORAGE"][self.template]
                     else:
-                        if self.template in request.session['LOCAL_STORAGE']:
-                            request.session['LOCAL_STORAGE'].update({self.template: tmp[self.template]})
+                        if self.template in request.session["LOCAL_STORAGE"]:
+                            request.session["LOCAL_STORAGE"].update(
+                                {self.template: tmp[self.template]}
+                            )
                         else:
-                            request.session['LOCAL_STORAGE'][self.template] = tmp[self.template]
+                            request.session["LOCAL_STORAGE"][self.template] = tmp[
+                                self.template
+                            ]
                 except:
-                    request.session['LOCAL_STORAGE'][self.template] = tmp[self.template]
+                    request.session["LOCAL_STORAGE"][self.template] = tmp[self.template]
 
                 request.session.modified = True
 
-                if '/new/' in request.path:
-                    if 'uuid' not in request.session or request.session['uuid'] != str(acl_id):
-                        logger.warning('Попытка записи в чужой uuid')
-                        return redirect(reverse(FORM_URLS[current_page + 1], kwargs={'acl_id': acl_id}))
-                    #else:
+                if "/new/" in request.path:
+                    if "uuid" not in request.session or request.session["uuid"] != str(
+                        acl_id
+                    ):
+                        logger.warning("Попытка записи в чужой uuid")
+                        return redirect(
+                            reverse(
+                                FORM_URLS[current_page + 1], kwargs={"acl_id": acl_id}
+                            )
+                        )
+                    # else:
                     #    return HttpResponseRedirect(reverse(FORM_URLS[0]))
-                if FORM_APPLICATION_KEYS[0] in request.session['LOCAL_STORAGE']:
-                        owner_form = request.session['LOCAL_STORAGE'][FORM_APPLICATION_KEYS[0]]
+                if FORM_APPLICATION_KEYS[0] in request.session["LOCAL_STORAGE"]:
+                    owner_form = request.session["LOCAL_STORAGE"][
+                        FORM_APPLICATION_KEYS[0]
+                    ]
                 else:
-                    messages.warning(request, 'Для продолжения, необходимо заполнить контактные данные.')
+                    messages.warning(
+                        request,
+                        "Для продолжения, необходимо заполнить контактные данные.",
+                    )
                     return redirect("{}{}/".format(reverse(FORM_URLS[1]), acl_id))
                 obj = save__form(request, owner_form, acl_id)
                 if obj is not None:
                     return obj
-                if NO_MAKE_JOB == 'no':
-                    messages.info(request, 'Данные сохранены')
-                    return redirect("{}{}/".format(reverse(FORM_URLS[current_page]), acl_id))
-                return redirect("{}{}/".format(reverse(FORM_URLS[current_page + 1]), acl_id))
-
-        messages.warning(request, 'Не все поля заполнены')
-        return render(request, self.template, context={'acl_id': acl_id})
+                if NO_MAKE_JOB == "no":
+                    messages.info(request, "Данные сохранены")
+                    return redirect(
+                        "{}{}/".format(reverse(FORM_URLS[current_page]), acl_id)
+                    )
+                return redirect(
+                    "{}{}/".format(reverse(FORM_URLS[current_page + 1]), acl_id)
+                )
 
+        messages.warning(request, "Не все поля заполнены")
+        return render(request, self.template, context={"acl_id": acl_id})
 
 
 class Aclhistory(BaseView, LoginRequiredMixin, View):
     """История запросов"""
+
     def get(self, request, acl_id=None, acl_status=None, project_name=None):
         ClearSessionMeta(request)
         if acl_id is not None:
-            #if request.user.is_staff:
-            acllist= ACL.objects.filter(id__exact=acl_id)
-            #else:
-                #acllist = ACL.objects.filter(id__exact=acl_id, owner__email__iexact=request.user.email)
+            # if request.user.is_staff:
+            acllist = ACL.objects.filter(id__exact=acl_id)
+            # else:
+            # acllist = ACL.objects.filter(id__exact=acl_id, owner__email__iexact=request.user.email)
         elif acl_status is not None:
-            acllist = ACL.objects.filter(status__exact=acl_status).order_by("-created", "-pkid")
+            acllist = ACL.objects.filter(status__exact=acl_status).order_by(
+                "-created", "-pkid"
+            )
         elif project_name is not None:
-            acllist = ACL.objects.filter(project__icontains=project_name).order_by("-created", "-pkid")
-            logger.info('Отсортировал по проекту')
+            acllist = ACL.objects.filter(project__icontains=project_name).order_by(
+                "-created", "-pkid"
+            )
+            logger.info("Отсортировал по проекту")
         else:
             if request.user.is_staff:
                 acllist = ACL.objects.order_by("-created", "-pkid")
             else:
-                acllist = ACL.objects.filter(Q(owner_id=request.user.id) | Q(approve__exact=request.user)).order_by("-created", "-pkid") #owner__email__iexact=request.user.email
-
-
+                acllist = ACL.objects.filter(
+                    Q(owner_id=request.user.id) | Q(approve__exact=request.user)
+                ).order_by(
+                    "-created", "-pkid"
+                )  # owner__email__iexact=request.user.email
 
         paginator = Paginator(acllist, 10)
-        page_number = request.GET.get('page', 1)
+        page_number = request.GET.get("page", 1)
         page = paginator.get_page(page_number)
 
         is_paginated = page.has_other_pages()
 
         if page.has_previous():
-            prev_url = '?page={}'.format(page.previous_page_number())
+            prev_url = "?page={}".format(page.previous_page_number())
         else:
-            prev_url = ''
+            prev_url = ""
 
         if page.has_next():
-            next_url = '?page={}'.format(page.next_page_number())
+            next_url = "?page={}".format(page.next_page_number())
         else:
-            next_url = ''
+            next_url = ""
 
         context = {
             "acl": ACL,
@@ -254,268 +342,315 @@ class Aclhistory(BaseView, LoginRequiredMixin, View):
             "next_url": next_url,
             "prev_url": prev_url,
         }
-        return render(request, 'acl_history.html', context=context)
+        return render(request, "acl_history.html", context=context)
 
 
 class AclCreate(BaseView, LoginRequiredMixin, ObjectMixin, View):
-    template = 'acl_create_info.html'
-    url = 'aclcreate_urls'
+    template = "acl_create_info.html"
+    url = "aclcreate_urls"
+
 
 class AclPrepare(BaseView, ObjectMixin, View):
-    template = 'acl_pending.html'
-    url = 'acl_prepare_urls'
+    template = "acl_pending.html"
+    url = "acl_prepare_urls"
+
 
 class AclCreate_internal(BaseView, LoginRequiredMixin, ObjectMixin, View):
-    template = 'acl_internal_resources.html'
-    url = 'aclinternal_urls'
+    template = "acl_internal_resources.html"
+    url = "aclinternal_urls"
 
 
 class AclCreate_dmz(BaseView, LoginRequiredMixin, ObjectMixin, View):
-    template = 'acl_dmz_resources.html'
-    url = 'acldmz_urls'
+    template = "acl_dmz_resources.html"
+    url = "acldmz_urls"
 
 
 class AclCreate_external(BaseView, LoginRequiredMixin, ObjectMixin, View):
-    template = 'acl_external_resources.html'
-    url = 'aclexternal_urls'
+    template = "acl_external_resources.html"
+    url = "aclexternal_urls"
 
 
 class AclCreate_traffic(BaseView, LoginRequiredMixin, ObjectMixin, View):
-    template = 'acl_traffic.html'
-    url = 'acltraffic_urls'
+    template = "acl_traffic.html"
+    url = "acltraffic_urls"
+
 
 class Acl_approve(BaseView, LoginRequiredMixin, View):
     """Функция для страницы согласования"""
+
     def get(self, request, acl_id=None):
         context = {}
-        actived = request.GET.get('actived', None)
-        token = request.GET.get('token', 0)
+        actived = request.GET.get("actived", None)
+        token = request.GET.get("token", 0)
 
         if acl_id is None or not is_valid_uuid(acl_id):
-            messages.warning(request, 'Неправильный запрос')
-            return redirect(reverse('acldemo_urls'))
+            messages.warning(request, "Неправильный запрос")
+            return redirect(reverse("acldemo_urls"))
         try:
             tmp = get_object_or_404(ACL, id=str(acl_id))
         except Exception as e:
             logger.error(e)
-            messages.warning(request, 'Неправильный запрос')
-            return redirect(reverse('acldemo_urls'))
+            messages.warning(request, "Неправильный запрос")
+            return redirect(reverse("acldemo_urls"))
 
-        if actived != 'true' or tmp.token != token:
+        if actived != "true" or tmp.token != token:
             actived = False
 
-        if tmp.status == 'WTE' and not actived:
-            #messages.warning(request, 'ACL уже ожидает согласование')
-            return redirect(reverse('acl_pending_urls', kwargs=({'acl_id': acl_id})))
-        elif tmp.status == 'APRV':
-            return redirect(reverse('aclcreate_urls', kwargs=({'acl_id': acl_id})))
+        if tmp.status == "WTE" and not actived:
+            # messages.warning(request, 'ACL уже ожидает согласование')
+            return redirect(reverse("acl_pending_urls", kwargs=({"acl_id": acl_id})))
+        elif tmp.status == "APRV":
+            return redirect(reverse("aclcreate_urls", kwargs=({"acl_id": acl_id})))
 
         form = Approve_form()
         if tmp.team is not None:
             APPROVE_OWNER = tmp.team.response.all()
             APPROVE_LIST = tmp.team.response.all()
-            #context.update({'PROJECT': tmp.team.name})
+            # context.update({'PROJECT': tmp.team.name})
         else:
-            APPROVE_OWNER = User.objects.filter(groups__name=settings.APPROVE).filter(groups__name=tmp.project)
+            APPROVE_OWNER = User.objects.filter(groups__name=settings.APPROVE).filter(
+                groups__name=tmp.project
+            )
             if APPROVE_OWNER:
                 # Берем только одного человека для согласования
                 APPROVE_OWNER = APPROVE_OWNER[0]
-                APPROVE_LIST = User.objects.filter(groups__name=settings.APPROVE).exclude(id__exact=APPROVE_OWNER.id)
+                APPROVE_LIST = User.objects.filter(
+                    groups__name=settings.APPROVE
+                ).exclude(id__exact=APPROVE_OWNER.id)
             else:
                 APPROVE_LIST = User.objects.filter(groups__name=settings.APPROVE)
 
         if tmp.team is not None:
-            context.update({'team': tmp.team.name})
+            context.update({"team": tmp.team.name})
         else:
-            d_tmp = json.loads(tmp.acltext)['acl_create_info.html']
+            d_tmp = json.loads(tmp.acltext)["acl_create_info.html"]
             if len(d_tmp) > 0:
                 d_tmp = d_tmp[3]
-            context.update({'team': d_tmp})
-
-        context.update({'acl_id': str(acl_id),
-                        'FULL_STORAGE': json.loads(tmp.acltext),
-                        'FORM_APPLICATION_KEYS': FORM_APPLICATION_KEYS,
-                        'APPROVE_LIST': APPROVE_LIST,
-                        'APPROVE_OWNER': APPROVE_OWNER,
-                        'STATUS': tmp.status,
-                        'REASON': tmp.comment,
-                        'form': form,
-                        'PROJECT': tmp.project,
-                        'blocks': Block.objects.all()
-                        })
-        #if actived:
+            context.update({"team": d_tmp})
+
+        context.update(
+            {
+                "acl_id": str(acl_id),
+                "FULL_STORAGE": json.loads(tmp.acltext),
+                "FORM_APPLICATION_KEYS": FORM_APPLICATION_KEYS,
+                "APPROVE_LIST": APPROVE_LIST,
+                "APPROVE_OWNER": APPROVE_OWNER,
+                "STATUS": tmp.status,
+                "REASON": tmp.comment,
+                "form": form,
+                "PROJECT": tmp.project,
+                "blocks": Block.objects.all(),
+            }
+        )
+        # if actived:
         #    context.update({'actived': 'true',
         #                    'url': request.path})
 
-        return render(request, 'acl_approve.html', context=context)
-
+        return render(request, "acl_approve.html", context=context)
 
     def post(self, request, acl_id=None):
         form = Approve_form(data=request.POST or None)
-        actived = request.GET.get('actived', None)
-        token = request.GET.get('token', 0)
+        actived = request.GET.get("actived", None)
+        token = request.GET.get("token", 0)
         user_list = []
-        if 'approve_person' not in form.data or len(form.data['approve_person']) == 0:
-            messages.error(request, 'Нужно выбрать согласующего')
-            return HttpResponseRedirect(reverse('acl_approve_urls', kwargs=({"acl_id": acl_id})))
+        if "approve_person" not in form.data or len(form.data["approve_person"]) == 0:
+            messages.error(request, "Нужно выбрать согласующего")
+            return HttpResponseRedirect(
+                reverse("acl_approve_urls", kwargs=({"acl_id": acl_id}))
+            )
 
-        approve_persons = form.data['approve_person'] or ''
+        approve_persons = form.data["approve_person"] or ""
         if form.is_valid():
             tmp = get_object_or_404(ACL, id=str(acl_id))
-            if tmp.token == '':
+            if tmp.token == "":
                 tmp.token = MakeTemporaryToken()
                 actived = False
             else:
                 if actived and tmp.token == token:
                     actived = True
-                    #tmp.token = MakeTemporaryToken()
+                    # tmp.token = MakeTemporaryToken()
 
-            users = (form.cleaned_data['approve_person']).split(';') or []
+            users = (form.cleaned_data["approve_person"]).split(";") or []
             if len(users) >= 5:
-                messages.error(request, 'Слишком много адресатов, максимальное количество: 5')
-                return HttpResponseRedirect(reverse('acl_approve_urls', kwargs=({"acl_id": acl_id})))
+                messages.error(
+                    request, "Слишком много адресатов, максимальное количество: 5"
+                )
+                return HttpResponseRedirect(
+                    reverse("acl_approve_urls", kwargs=({"acl_id": acl_id}))
+                )
 
             for user in users:
                 try:
                     user_obj = User.objects.get(username__exact=user) or None
                 except User.DoesNotExist:
-                    messages.error(request, f'Выбранный пользователь {user} не может согласовать данный ACL')
+                    messages.error(
+                        request,
+                        f"Выбранный пользователь {user} не может согласовать данный ACL",
+                    )
 
                 if user_obj:
                     user_list.append(user_obj)
                     try:
-                        SendMessageToApprove(acl_id, tmp.owner, user_obj, token=tmp.token)
+                        SendMessageToApprove(
+                            acl_id, tmp.owner, user_obj, token=tmp.token
+                        )
                     except Exception as e:
-                        logger.error('Ошибка при отправке email: {}'.format(e))
+                        logger.error("Ошибка при отправке email: {}".format(e))
 
-            tmp.status = 'WTE'
+            tmp.status = "WTE"
             tmp.approve.set(user_list)
             tmp.save()
 
-            return redirect(reverse('acl_pending_urls', kwargs=({"acl_id": acl_id})))
+            return redirect(reverse("acl_pending_urls", kwargs=({"acl_id": acl_id})))
 
         else:
             if len(form.errors.keys()) > 0:
-                messages.error(request,
-                               'Произошла ошибка при изменении данных, вероятно невалидные данные в форме: {}'.format(
-                                   form.errors.keys()))
+                messages.error(
+                    request,
+                    "Произошла ошибка при изменении данных, вероятно невалидные данные в форме: {}".format(
+                        form.errors.keys()
+                    ),
+                )
             else:
-                messages.error(request, 'Ошибка на стороне сервера')
+                messages.error(request, "Ошибка на стороне сервера")
         storage = get_messages(request)
         if storage:
             return redirect(request.get_full_path())
-        return HttpResponseRedirect(reverse('acl_approve_urls', kwargs=({"acl_id": acl_id})))
+        return HttpResponseRedirect(
+            reverse("acl_approve_urls", kwargs=({"acl_id": acl_id}))
+        )
 
 
 class Acl_pending(BaseView, View):
     """Функция вывода информации об согласовании объекта"""
+
     def get(self, request, acl_id=None):
         if acl_id is None:
             return redirect(reverse(FORM_URLS[1]))
-        prepare = request.GET.get('prepare', False)
-        token = request.GET.get('token', '')
+        prepare = request.GET.get("prepare", False)
+        token = request.GET.get("token", "")
         context = {}
         tmp = None
         try:
             tmp = get_object_or_404(ACL, id=str(acl_id))
-        except Exception as e:
+        except Exception:
             if not prepare:
-                messages.warning(request, 'Такого ACL листа еще нет, но можете его создать')
+                messages.warning(
+                    request, "Такого ACL листа еще нет, но можете его создать"
+                )
             else:
-                messages.warning(request, 'Необходимо сохранить ACL')
-            return HttpResponseRedirect(request.META.get('HTTP_REFERER'))
+                messages.warning(request, "Необходимо сохранить ACL")
+            return HttpResponseRedirect(request.META.get("HTTP_REFERER"))
         # except Exception as e:
         #         messages.warning(request, 'Произошла ошибка при выполнении запроса')
         #         return HttpResponseRedirect(reverse('acldemo_urls'))
-        context.update({'obj': tmp})
+        context.update({"obj": tmp})
 
         if len(tmp.approve.all()) == 0:
-            tmp.status = 'FL'
+            tmp.status = "FL"
             tmp.save()
-            messages.warning(request, 'Мы не смогли найти согласующего')
-            return redirect(reverse('acl_approve_urls', kwargs={'acl_id': acl_id}))
+            messages.warning(request, "Мы не смогли найти согласующего")
+            return redirect(reverse("acl_approve_urls", kwargs={"acl_id": acl_id}))
         if not prepare:
             if token != tmp.token:
                 if request.user not in tmp.approve.all():
-                    context.update({'IS_APPROVE': False})
+                    context.update({"IS_APPROVE": False})
                     # or request.user != tmp.owner:
                     if request.user != tmp.owner and not request.user.is_staff:
-                            messages.warning(request, 'Вы не можете получить доступ к данному ACL, вероятно истек токен или Вы не авторизованы.')
-                            return redirect(reverse('acldemo_urls'))
+                        messages.warning(
+                            request,
+                            "Вы не можете получить доступ к данному ACL, вероятно истек токен или Вы не авторизованы.",
+                        )
+                        return redirect(reverse("acldemo_urls"))
             else:
-                context.update({'IS_APPROVE': True})
-                #messages.warning(request, 'Не валидный токен, попробуйте запросить новый')
-                #return redirect(reverse(FORM_URLS[1]))
-            if tmp.status == 'APRV':
+                context.update({"IS_APPROVE": True})
+                # messages.warning(request, 'Не валидный токен, попробуйте запросить новый')
+                # return redirect(reverse(FORM_URLS[1]))
+            if tmp.status == "APRV":
                 if request.user == tmp.owner:
-                    return redirect(reverse('acloverview_urls', kwargs={'acl_id': acl_id}))
+                    return redirect(
+                        reverse("acloverview_urls", kwargs={"acl_id": acl_id})
+                    )
                 else:
-                    messages.info(request, 'Это действие уже кто-то выполнил')
-                    return redirect(reverse('aclcreate_urls', kwargs={'acl_id': acl_id}))
-
-            if tmp.status != 'WTE':
-                messages.warning(request, 'ACL вероятно уже согласован, либо редактируется кем-то другим')
-                return redirect(reverse('acl_approve_urls', kwargs={'acl_id': acl_id}))
-
-            context.update({'status': str(tmp.status), 'APP_PERSON': tmp.approve.all(),
-                            'TOKEN': tmp.token})
-
-
-            context.update({'LOCAL_STORAGE': json.loads(tmp.acltext)})
+                    messages.info(request, "Это действие уже кто-то выполнил")
+                    return redirect(
+                        reverse("aclcreate_urls", kwargs={"acl_id": acl_id})
+                    )
+
+            if tmp.status != "WTE":
+                messages.warning(
+                    request,
+                    "ACL вероятно уже согласован, либо редактируется кем-то другим",
+                )
+                return redirect(reverse("acl_approve_urls", kwargs={"acl_id": acl_id}))
+
+            context.update(
+                {
+                    "status": str(tmp.status),
+                    "APP_PERSON": tmp.approve.all(),
+                    "TOKEN": tmp.token,
+                }
+            )
+
+            context.update({"LOCAL_STORAGE": json.loads(tmp.acltext)})
         else:
-            if 'LOCAL_STORAGE' in request.session:
-                context.update({'LOCAL_STORAGE': request.session['LOCAL_STORAGE']})
-        context.update({'acl_id': str(acl_id)})
-        context.update({'PREPARE': bool(prepare)})
+            if "LOCAL_STORAGE" in request.session:
+                context.update({"LOCAL_STORAGE": request.session["LOCAL_STORAGE"]})
+        context.update({"acl_id": str(acl_id)})
+        context.update({"PREPARE": bool(prepare)})
+
+        return render(request, "acl_pending.html", context=context)
 
-        return render(request, 'acl_pending.html', context=context)
 
 class AclDemo(BaseView, View):
     """Страница приветствия"""
+
     def get(self, request):
         ClearSessionMeta(request)
-        return render(request, 'acl_demo.html')
+        return render(request, "acl_demo.html")
+
 
 class AclInstruction(BaseView, View):
     def get(self, request):
         ClearSessionMeta(request)
-        return render(request, 'acl_instruction.html')
+        return render(request, "acl_instruction.html")
 
 
 def ACldefault(request):
     request.session.set_expiry(0)
-    return HttpResponseRedirect(reverse('acldemo_urls'))
+    return HttpResponseRedirect(reverse("acldemo_urls"))
 
 
-def save__form(request, owner_form: None, acl_id)->None:
+def save__form(request, owner_form: None, acl_id) -> None:
     """Сохранение данныех из сесии в БД"""
     if owner_form is None:
         logger.error("[save__form] owner_form is None")
         return
-    
+
     if owner_form[1] != request.user.email:
         email = request.user.email
     else:
         email = owner_form[1]
-    
 
     user = Owners.objects.filter(email=email).first()
     if not user:
-        user = Owners.objects.create(email=email,
-                                     username=owner_form[0],
-                                     phone = owner_form[2],
-                                     active = True,
-                                     department = owner_form[3])
+        user = Owners.objects.create(
+            email=email,
+            username=owner_form[0],
+            phone=owner_form[2],
+            active=True,
+            department=owner_form[3],
+        )
     try:
         ip, created_ip = Iplist.objects.get_or_create(ipv4=get_client_ip(request))
         ip.owner = user
         ip.save()
         activity = []
         if any([job for job in tasklist if job in request.session]):
-            if 'ACT_OMNI' in request.session:
-                activity.append('ACT_OMNI')
-            if 'ACT_MAKE_GIT' in request.session:
-                activity.append('ACT_MAKE_GIT')
+            if "ACT_OMNI" in request.session:
+                activity.append("ACT_OMNI")
+            if "ACT_MAKE_GIT" in request.session:
+                activity.append("ACT_MAKE_GIT")
 
             # if 'GIT_URL' in request.session:
             #         activity.append(request.session['GIT_URL'])
@@ -523,16 +658,16 @@ def save__form(request, owner_form: None, acl_id)->None:
             # if 'GIT_FILENAME' in request.session:
             #     activity.append(request.session['GIT_FILENAME'])
 
-            if 'ACT_MAKE_DOCX' in request.session:
-                activity.append('ACT_MAKE_DOCX')
+            if "ACT_MAKE_DOCX" in request.session:
+                activity.append("ACT_MAKE_DOCX")
 
         obj, created = ACL.objects.get_or_create(id=str(acl_id))
         if obj:
-            #if obj.status in ['WTE', 'APRV']:
+            # if obj.status in ['WTE', 'APRV']:
             #    messages.warning(request, 'Вы не можете изменить ACL лист находяшийся на согласовании')
             #    return redirect(reverse('aclcreate_urls'),  kwargs=({"acl_id": acl_id}))
             old = obj.acltext
-            team_obj = int(request.POST.get('teamid', 0))
+            team_obj = int(request.POST.get("teamid", 0))
             if team_obj > 0:
                 team = Team.objects.get(id=team_obj)
                 if team:
@@ -555,185 +690,237 @@ def save__form(request, owner_form: None, acl_id)->None:
                                 except tmp_owner.DoesNotExist:
                                     obj.owner = request.user
 
-            if len(request.session['LOCAL_STORAGE']) <= 1:
-                  obj.status = 'NOTFL'
-                  obj.save(update_fields=['status'])
+            if len(request.session["LOCAL_STORAGE"]) <= 1:
+                obj.status = "NOTFL"
+                obj.save(update_fields=["status"])
             else:
-                if not created and obj.status == 'NOTFL':
-                    obj.status = 'FL'
-                    obj.save(update_fields=['status'])
+                if not created and obj.status == "NOTFL":
+                    obj.status = "FL"
+                    obj.save(update_fields=["status"])
 
-            #Fix bug hash empty old acl list
+            # Fix bug hash empty old acl list
             if list(obj.acltext) != []:
                 old = hash(obj.acltext)
-            new = hash(json.dumps(request.session['LOCAL_STORAGE']))
+            new = hash(json.dumps(request.session["LOCAL_STORAGE"]))
             if old != new:
-                if obj.status in ['CMP']: #'WTE', 'APRV'
+                if obj.status in ["CMP"]:  #'WTE', 'APRV'
                     print(type(obj.approve))
                     obj.approve.add([])
-                    obj.status = 'FL'
-                    messages.info(request, 'Вы изменили согласованные данные, для формирования обращения, необходимо заново согласовать ACL лист')
+                    obj.status = "FL"
+                    messages.info(
+                        request,
+                        "Вы изменили согласованные данные, для формирования обращения, необходимо заново согласовать ACL лист",
+                    )
                 else:
-                    if obj.status in ['WTE']:
-                        messages.warning(request, 'Вы не можете изменить ACL лист находяшийся на согласовании')
-                        response = redirect(reverse('aclcreate_urls', kwargs=({"acl_id": acl_id})))
-
-                        #response = redirect(reverse('acl_pending_urls', kwargs=({"acl_id": acl_id})))
-                        #response['Location'] += "?token={}".format(tmp.token)
-                        #return response
-                        return response #HttpResponseRedirect()
+                    if obj.status in ["WTE"]:
+                        messages.warning(
+                            request,
+                            "Вы не можете изменить ACL лист находяшийся на согласовании",
+                        )
+                        response = redirect(
+                            reverse("aclcreate_urls", kwargs=({"acl_id": acl_id}))
+                        )
+
+                        # response = redirect(reverse('acl_pending_urls', kwargs=({"acl_id": acl_id})))
+                        # response['Location'] += "?token={}".format(tmp.token)
+                        # return response
+                        return response  # HttpResponseRedirect()
                 #
                 # ('CMP', 'Выполнено'),
                 # ('WTE', 'Ожидает согласования'),
                 # ('APRV', 'Согласованно'),
 
-                obj.acltext = json.dumps(request.session['LOCAL_STORAGE'])
+                obj.acltext = json.dumps(request.session["LOCAL_STORAGE"])
             if len(activity) > 0:
                 obj.activity = ";".join(activity)
             obj.project = owner_form[4]
             obj.git_filename = owner_form[9]
             try:
                 department = request.POST.get("department")
-                if department != '' or department != 'Нет':
+                if department != "" or department != "Нет":
                     team = Team.objects.get(name=department)
                     if team:
                         obj.team = team
             except Exception as e:
-                logger.warning(f'Не удалось сохранить team в БД: {e}')
+                logger.warning(f"Не удалось сохранить team в БД: {e}")
             obj.save()
 
     except Exception as e:
-        messages.error(request, 'Ошибка, мы не смогли записать данные в БД. {}'.format(e))
-        logger.error('{}|{}|{}'.format(stack()[0][3], str(e), request.META.get('REMOTE_ADDR')))
+        messages.error(
+            request, "Ошибка, мы не смогли записать данные в БД. {}".format(e)
+        )
+        logger.error(
+            "{}|{}|{}".format(stack()[0][3], str(e), request.META.get("REMOTE_ADDR"))
+        )
         if settings.DEBUG:
             logger.error(obj.acltext)
     finally:
         if not obj:
-            messages.error(request, 'Упс, что-то пошло не так, данные не сохранены')
-            logger.error('{}|{}|{}'.format(stack()[0][3], str('Данные в БД не сохранены'), request.META.get('REMOTE_ADDR')))
-            return HttpResponseRedirect(reverse('aclcreate_urls', kwargs=({"acl_id": acl_id})))
+            messages.error(request, "Упс, что-то пошло не так, данные не сохранены")
+            logger.error(
+                "{}|{}|{}".format(
+                    stack()[0][3],
+                    str("Данные в БД не сохранены"),
+                    request.META.get("REMOTE_ADDR"),
+                )
+            )
+            return HttpResponseRedirect(
+                reverse("aclcreate_urls", kwargs=({"acl_id": acl_id}))
+            )
 
 
 class AclOver(BaseView, LoginRequiredMixin, View):
     """Страница формирования ACL файла и других активностей"""
+
     def get(self, request, acl_id=None):
-        if acl_id is None or 'LOCAL_STORAGE' not in request.session: # or 'uuid' not in request.session
-            return HttpResponseRedirect(reverse('acldemo_urls'))
-        context = {'obj': acl_id,
-                   'JS_TIMEOUT': settings.JS_TIMEOUT,
-                   'tasks': {},
-                   }
-        if 'uuid' in request.session is not None:
-                    if '/new/' in request.path:
-                        if str(acl_id) != request.session['uuid']:
-                            return HttpResponseRedirect(reverse(FORM_URLS[0]))
-                    elif str(acl_id) == request.session['uuid']:
-                        return redirect(reverse('acloverview_urls', kwargs={'acl_id': acl_id}))
-
-        if len(request.session['LOCAL_STORAGE']) > 1: #or tmp.status == 'NOTFL'
-            owner_form = request.session['LOCAL_STORAGE'][FORM_APPLICATION_KEYS[0]]
+        if (
+            acl_id is None or "LOCAL_STORAGE" not in request.session
+        ):  # or 'uuid' not in request.session
+            return HttpResponseRedirect(reverse("acldemo_urls"))
+        context = {
+            "obj": acl_id,
+            "JS_TIMEOUT": settings.JS_TIMEOUT,
+            "tasks": {},
+        }
+        if "uuid" in request.session is not None:
+            if "/new/" in request.path:
+                if str(acl_id) != request.session["uuid"]:
+                    return HttpResponseRedirect(reverse(FORM_URLS[0]))
+            elif str(acl_id) == request.session["uuid"]:
+                return redirect(reverse("acloverview_urls", kwargs={"acl_id": acl_id}))
+
+        if len(request.session["LOCAL_STORAGE"]) > 1:  # or tmp.status == 'NOTFL'
+            owner_form = request.session["LOCAL_STORAGE"][FORM_APPLICATION_KEYS[0]]
             obj = save__form(request, owner_form, acl_id)
             if obj is not None:
                 return obj
         else:
-            messages.warning(request, 'Нехватает данных для формирования ACL')
-            return redirect(reverse(FORM_URLS[1], kwargs={'acl_id': acl_id}))
+            messages.warning(request, "Нехватает данных для формирования ACL")
+            return redirect(reverse(FORM_URLS[1], kwargs={"acl_id": acl_id}))
 
         try:
             tmp = get_object_or_404(ACL, id=str(acl_id))
             if len(tmp.taskid) > 4:
-                context.update({'taskid': tmp.taskid})
+                context.update({"taskid": tmp.taskid})
         except tmp.DoesNotExist:
-            messages.error(request, 'К сожалению такого ACL нету, вероятно Вы ошиблись, либо истекла сессия')
-            return HttpResponseRedirect(reverse('acldemo_urls'))
+            messages.error(
+                request,
+                "К сожалению такого ACL нету, вероятно Вы ошиблись, либо истекла сессия",
+            )
+            return HttpResponseRedirect(reverse("acldemo_urls"))
 
         """Проверяем состояние массива с данными"""
         # and all(KEY in request.session['LOCAL_STORAGE'] for KEY in FORM_APPLICATION_KEYS):
 
-        if tmp.status == 'WTE':
-            return HttpResponseRedirect(reverse('acl_approve_urls', kwargs={'acl_id': acl_id}))
-
-
-
-        #Требовать согласование при формировании обращения
-        if 'ACT_MAKE_GIT' in request.session or 'ACT_OMNI' in request.session:
-
-            if tmp.status in ['APRV', 'CMP'] and tmp.approve == None:
-                messages.error(request,
-                               'Данный ACL уже согласован, но нам не удалось получить данные согласующего. '
-                               'Необходимо согласовать заново.')
-                tmp.status = 'FL'
+        if tmp.status == "WTE":
+            return HttpResponseRedirect(
+                reverse("acl_approve_urls", kwargs={"acl_id": acl_id})
+            )
+
+        # Требовать согласование при формировании обращения
+        if "ACT_MAKE_GIT" in request.session or "ACT_OMNI" in request.session:
+
+            if tmp.status in ["APRV", "CMP"] and tmp.approve == None:
+                messages.error(
+                    request,
+                    "Данный ACL уже согласован, но нам не удалось получить данные согласующего. "
+                    "Необходимо согласовать заново.",
+                )
+                tmp.status = "FL"
                 tmp.save()
-                t = reverse('acl_approve_urls', kwargs={'acl_id': acl_id})
+                t = reverse("acl_approve_urls", kwargs={"acl_id": acl_id})
                 return HttpResponseRedirect(t)
 
-            if tmp.status in ['FL', 'CNL'] or tmp.status == 'CMP' and tmp.approve == None:
-                t = reverse('acl_approve_urls', kwargs={'acl_id': acl_id})
+            if (
+                tmp.status in ["FL", "CNL"]
+                or tmp.status == "CMP"
+                and tmp.approve == None
+            ):
+                t = reverse("acl_approve_urls", kwargs={"acl_id": acl_id})
                 return HttpResponseRedirect(t)
 
-            if tmp.status not in ['APRV', 'CMP', 'JOB']:
-                messages.warning(request, 'Данный ACL не получил согласования')
-                return HttpResponseRedirect(reverse('acl_approve_urls', kwargs={'acl_id': acl_id}))
+            if tmp.status not in ["APRV", "CMP", "JOB"]:
+                messages.warning(request, "Данный ACL не получил согласования")
+                return HttpResponseRedirect(
+                    reverse("acl_approve_urls", kwargs={"acl_id": acl_id})
+                )
 
-        if 'ACT_MAKE_DOCX' in request.session:
-                context['tasks'].update({'list-group-item-file': 'Формирование docx обращения'})
+        if "ACT_MAKE_DOCX" in request.session:
+            context["tasks"].update(
+                {"list-group-item-file": "Формирование docx обращения"}
+            )
 
-        if 'ACT_OMNI' in request.session:
-            context['tasks'].update({'list-group-item-omni': 'Отправка обращения в OmniTracker'})
+        if "ACT_OMNI" in request.session:
+            context["tasks"].update(
+                {"list-group-item-omni": "Отправка обращения в OmniTracker"}
+            )
 
-        if 'ACT_MAKE_GIT' in request.session:
-            context['tasks'].update({'list-group-item-git': 'Отправка md в Git'})
+        if "ACT_MAKE_GIT" in request.session:
+            context["tasks"].update({"list-group-item-git": "Отправка md в Git"})
         # tmp_cache = cache.get(acl_id, {})
         # if len(tmp_cache) > 0:
         #     context.update({'cache': tmp_cache})
-        context.update({'status': tmp.status})
-        return render(request, 'acl_overview.html', context=context)
+        context.update({"status": tmp.status})
+        return render(request, "acl_overview.html", context=context)
 
 
 @csrf_exempt
 def acl_stage_change(request, *args, **kwargs):
-    if request.method != 'POST':
+    if request.method != "POST":
         return HttpResponse(status=405)
 
-    logger.info(f'Проверка request.user: {request.user}')
+    logger.info(f"Проверка request.user: {request.user}")
 
     if not request.user.is_authenticated:
-        logger.error('Обнаружен Анонимный пользователь.')
-        messages.error(request, 'Вы не авторизованы. Необходимо авторизоваться для изменения статуса ACL. Пожалуйста, авторизуйтесь.')
-        result = {'error': 'Вы не авторизованы. Необходимо авторизоваться для изменения статуса ACL. Пожалуйста, авторизуйтесь.'}
-        send_to_mattermost('[СОГЛАСОВАНИЕ] Обнаружен Анонимный пользователь. Изменение статуса прекращено.')
+        logger.error("Обнаружен Анонимный пользователь.")
+        messages.error(
+            request,
+            "Вы не авторизованы. Необходимо авторизоваться для изменения статуса ACL. Пожалуйста, авторизуйтесь.",
+        )
+        result = {
+            "error": "Вы не авторизованы. Необходимо авторизоваться для изменения статуса ACL. Пожалуйста, авторизуйтесь."
+        }
+        send_to_mattermost(
+            "[СОГЛАСОВАНИЕ] Обнаружен Анонимный пользователь. Изменение статуса прекращено."
+        )
         return HttpResponse(json.dumps(result), content_type="application/json")
 
-    uuid = request.POST.get('uuid', '')
-    text = request.POST.get('text', '')
-    stage = request.POST.get('stage', '')
+    uuid = request.POST.get("uuid", "")
+    text = request.POST.get("text", "")
+    stage = request.POST.get("stage", "")
 
     if not uuid or not stage:
-        result = {'error': 'Неверная request data'}
+        result = {"error": "Неверная request data"}
         return HttpResponse(json.dumps(result), content_type="application/json")
 
-    valid_stages = ['NOTFL', 'FL', 'CMP', 'WTE', 'APRV', 'CNL', 'JOB']
+    valid_stages = ["NOTFL", "FL", "CMP", "WTE", "APRV", "CNL", "JOB"]
     if stage not in valid_stages:
-        result = {'error': 'Неверный stage'}
+        result = {"error": "Неверный stage"}
         return HttpResponse(json.dumps(result), content_type="application/json")
 
-    if stage == 'WTE':
-        result = {'error': 'Не удалось изменить статус на WTE'}
+    if stage == "WTE":
+        result = {"error": "Не удалось изменить статус на WTE"}
         return HttpResponse(json.dumps(result), content_type="application/json")
 
     try:
         acl = ACL.objects.get(id=uuid)
     except ACL.DoesNotExist:
-        result = {'error': 'ACL не найден'}
+        result = {"error": "ACL не найден"}
         return HttpResponse(json.dumps(result), content_type="application/json")
 
-    if stage in ['APRV', 'CNL'] and request.user not in acl.approve.all() and 'token' not in request.META.get('HTTP_REFERER'):
-        logger.error(f'Пользователю {request.user} не хватает прав для изменения статуса ACL.')
-        messages.error(request, 'У Вас не достаточно прав для изменения статуса ACL.')
-        result = {'error': 'У Вас не достаточно прав для изменения статуса ACL.'}
+    if (
+        stage in ["APRV", "CNL"]
+        and request.user not in acl.approve.all()
+        and "token" not in request.META.get("HTTP_REFERER")
+    ):
+        logger.error(
+            f"Пользователю {request.user} не хватает прав для изменения статуса ACL."
+        )
+        messages.error(request, "У Вас не достаточно прав для изменения статуса ACL.")
+        result = {"error": "У Вас не достаточно прав для изменения статуса ACL."}
         return HttpResponse(json.dumps(result), content_type="application/json")
 
-    if text == '' and stage == 'CNL':
+    if text == "" and stage == "CNL":
         text = "Отклонено согласующим без указании причины"
 
     acl.approve.set([request.user])
@@ -742,70 +929,89 @@ def acl_stage_change(request, *args, **kwargs):
     acl.token = MakeTemporaryToken()
     acl.save()
 
-    log_message = f'[ACL PORTAL] Статус ACL({uuid}) изменён на новый:{stage}.'
+    log_message = f"[ACL PORTAL] Статус ACL({uuid}) изменён на новый:{stage}."
     print(log_message)
     logger.info(log_message)
 
-    if stage == 'APRV' and settings.MAKE_TASK_AFTER_APRROVE:
-        sendtext = 'Ваше обращение согласовано и уже отправлено на исполнение'
-        logger.info(f'Обращение {uuid} будет выполнено через бекенд')
+    if stage == "APRV" and settings.MAKE_TASK_AFTER_APRROVE:
+        sendtext = "Ваше обращение согласовано и уже отправлено на исполнение"
+        logger.info(f"Обращение {uuid} будет выполнено через бекенд")
         if settings.DEBUG:
-            print(f'Обращение {uuid} будет выполнено через бекенд')
+            print(f"Обращение {uuid} будет выполнено через бекенд")
 
-        threading.Thread(target=MakeBackgroundTask, kwargs={'request': request, 'acl_id': str(uuid)}).start()
+        threading.Thread(
+            target=MakeBackgroundTask, kwargs={"request": request, "acl_id": str(uuid)}
+        ).start()
 
-        letter_context = {'sendtext': sendtext, 'uuid': uuid}
-        email_body = render_to_string('status_change_letter.html', context=letter_context)
+        letter_context = {"sendtext": sendtext, "uuid": uuid}
+        email_body = render_to_string(
+            "status_change_letter.html", context=letter_context
+        )
         try:
-            EmailMessage(
-                subject='Статус обращения',
+            msg = EmailMessage(
+                subject="Статус обращения",
                 body=email_body,
-                from_email='acl@alfastrah.ru',
-                to=[acl.owner.email]
-            ).send(fail_silently=settings.DEBUG)
+                from_email="acl@alfastrah.ru",
+                to=[acl.owner.email],
+            )
+            msg.content_subtype = "html"
+            msg.send(fail_silently=settings.DEBUG)
         except Exception as e:
             logger.error(f"Ошибка отправки письма 'Статус обращения': {e}")
 
-    result = {'status': f'Статус изменён на новый: {stage}'}
+    result = {"status": f"Статус изменён на новый: {stage}"}
     return HttpResponse(json.dumps(result), content_type="application/json")
 
+
 @csrf_exempt
 def Gitcheck(request):
     """Функция сохранения и проверки git проекта"""
-    if request.method == 'POST':
-        result = {'status': 'Git проект и файл корректно загружены'}
-        if 'git_url' in request.POST:
-            if request.POST.get('git_url', '') == '':
-                if 'ACT_MAKE_GIT' in request.session:
-                    del request.session['ACT_MAKE_GIT']
-                result = {'error': 'Git проект не может быть пустым'}
+    if request.method == "POST":
+        result = {"status": "Git проект и файл корректно загружены"}
+        if "git_url" in request.POST:
+            if request.POST.get("git_url", "") == "":
+                if "ACT_MAKE_GIT" in request.session:
+                    del request.session["ACT_MAKE_GIT"]
+                result = {"error": "Git проект не может быть пустым"}
         return HttpResponse(json.dumps(result), content_type="application/json")
     return HttpResponse(status=405)
 
+
 def get_gitlab_files(request):
-    if request.method == 'POST':
+    if request.method == "POST":
         try:
-            gitlab_project = request.POST.get('gitlab_project')
-            gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
-            md_files = get_files_from_gitlab(repo_url=gitlab_repo_url, branch_name='develop')
+            gitlab_project = request.POST.get("gitlab_project")
+            gitlab_repo_url = ACLGitlabStore.objects.get(
+                project=gitlab_project
+            ).gitlab_url
+            md_files = get_files_from_gitlab(
+                repo_url=gitlab_repo_url, branch_name="develop"
+            )
             return HttpResponse(json.dumps(md_files), content_type="application/text")
         except Exception as e:
             logger.error(f"Ошибка при загрузке: {e}")
     return HttpResponse(json.dumps([]), content_type="application/text")
 
+
 def upload_acl_from_git(request):
-    if request.method == 'POST':
-        logger.info(f'[Загрузка md на портал] Инициализация загрузки md на портал')
-        gitlab_project = request.POST.get('project')
+    if request.method == "POST":
+        logger.info("[Загрузка md на портал] Инициализация загрузки md на портал")
+        gitlab_project = request.POST.get("project")
         gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
-        gitlab_file_name = request.POST.get('gitlab_file_selected_option')
-        logger.info(f'[Загрузка md на портал] Получены данные для загрузки: gitlab_project:{gitlab_project}, gitlab_repo_url:{gitlab_repo_url}, gitlab_file_name:{gitlab_file_name}')
+        gitlab_file_name = request.POST.get("gitlab_file_selected_option")
+        logger.info(
+            f"[Загрузка md на портал] Получены данные для загрузки: gitlab_project:{gitlab_project}, gitlab_repo_url:{gitlab_repo_url}, gitlab_file_name:{gitlab_file_name}"
+        )
         # Проверка прав пользователя
         session = requests.Session()
-        session.headers.update({'PRIVATE-TOKEN': settings.GIT_ACCESS_TOKEN})
-        project_id = get_gitlab_project_info(session, repo_url=gitlab_repo_url, mode='id')
-        logger.info(f'[Загрузка md на портал] Получен id Проекта:{project_id}')
-        get_members_api = f'https://gitlab.alfastrah.ru/api/v4/projects/{project_id}/members/all'
+        session.headers.update({"PRIVATE-TOKEN": settings.GIT_ACCESS_TOKEN})
+        project_id = get_gitlab_project_info(
+            session, repo_url=gitlab_repo_url, mode="id"
+        )
+        logger.info(f"[Загрузка md на портал] Получен id Проекта:{project_id}")
+        get_members_api = (
+            f"https://gitlab.alfastrah.ru/api/v4/projects/{project_id}/members/all"
+        )
         #
         response = session.get(get_members_api)
 
@@ -813,91 +1019,136 @@ def upload_acl_from_git(request):
             project_members_list_full = response.json()
             project_members_list = []
             for member in project_members_list_full:
-                project_members_list.append(member['username'].lower())
-            current_username = request.session['GIT_USERNAME']
+                project_members_list.append(member["username"].lower())
+            current_username = request.session["GIT_USERNAME"]
 
             if current_username.lower() in project_members_list:
-                logger.info(f'[Загрузка md на портал] Пользователь {current_username} есть в списке участников: {project_members_list}. Начинаю загрузку md на портал')
-                g = GitWorker(request, gitlab_repo_url, PATH_OF_GIT_REPO=None, MDFILE='', taskid='')
+                logger.info(
+                    f"[Загрузка md на портал] Пользователь {current_username} есть в списке участников: {project_members_list}. Начинаю загрузку md на портал"
+                )
+                g = GitWorker(
+                    request,
+                    gitlab_repo_url,
+                    PATH_OF_GIT_REPO=None,
+                    MDFILE="",
+                    taskid="",
+                )
                 if g:
-                    g.repo.git.ls_remote('--heads', '--tags', g.GITPRO)
+                    g.repo.git.ls_remote("--heads", "--tags", g.GITPRO)
                     g.free()
             else:
-                logger.warning(f'[Загрузка md на портал] Пользователь {current_username} не найден среди участников проекта: {project_members_list}. Отображено сообщение: нет доступа')
-                return HttpResponse(json.dumps({'error': f"Ошибка: У пользователя {current_username} нет доступа"}), content_type="application/json")
+                logger.warning(
+                    f"[Загрузка md на портал] Пользователь {current_username} не найден среди участников проекта: {project_members_list}. Отображено сообщение: нет доступа"
+                )
+                return HttpResponse(
+                    json.dumps(
+                        {
+                            "error": f"Ошибка: У пользователя {current_username} нет доступа"
+                        }
+                    ),
+                    content_type="application/json",
+                )
         else:
-            logger.error(f"[Загрузка md на портал] Ошибка во время проверки прав:{response}")
-            return HttpResponse(json.dumps({'error': f"Ошибка: Во время проверки прав"}), content_type="application/json")
-
-        md_content, project_desc = get_acl_from_gitlab(repo_url=gitlab_repo_url, branch_name='develop', file_name=gitlab_file_name)
+            logger.error(
+                f"[Загрузка md на портал] Ошибка во время проверки прав:{response}"
+            )
+            return HttpResponse(
+                json.dumps({"error": "Ошибка: Во время проверки прав"}),
+                content_type="application/json",
+            )
+
+        md_content, project_desc = get_acl_from_gitlab(
+            repo_url=gitlab_repo_url, branch_name="develop", file_name=gitlab_file_name
+        )
         if md_content is not None:
             result = convert_md_to_dict(md_content)
-            if 'LOCAL_STORAGE' in result:
-                request.session['LOCAL_STORAGE'] = result.get('LOCAL_STORAGE')
-                if 'acl_create_info.html' in result['LOCAL_STORAGE']:
-                    result['LOCAL_STORAGE']['acl_create_info.html'][5] = project_desc
-        if request.method == 'POST' and request.is_ajax:
-            if len(result['LOCAL_STORAGE']) == 0:
+            if "LOCAL_STORAGE" in result:
+                request.session["LOCAL_STORAGE"] = result.get("LOCAL_STORAGE")
+                if "acl_create_info.html" in result["LOCAL_STORAGE"]:
+                    result["LOCAL_STORAGE"]["acl_create_info.html"][5] = project_desc
+        if request.method == "POST" and request.is_ajax:
+            if len(result["LOCAL_STORAGE"]) == 0:
                 data = {"project_desc": project_desc}
                 return HttpResponse(json.dumps(data), content_type="application/text")
             return HttpResponse(json.dumps(result), content_type="application/text")
-        return HttpResponse(json.dumps("upload from git error"), content_type="application/text")
+        return HttpResponse(
+            json.dumps("upload from git error"), content_type="application/text"
+        )
 
 
 def send_acl_to_git(request, acl_object):
     try:
-        file_md = MakeMarkDown(request,
-                               json_data=json.loads(acl_object.acltext),
-                               filename=f'acl_{acl_object.id}',
-                               fileuuid=acl_object.id) or None
+        file_md = (
+            MakeMarkDown(
+                request,
+                json_data=json.loads(acl_object.acltext),
+                filename=f"acl_{acl_object.id}",
+                fileuuid=acl_object.id,
+            )
+            or None
+        )
         if not file_md:
             send_to_mattermost(
-                '[acl_pusher] Ошибка: функция создания md отработала, но файл не сформирован.')
+                "[acl_pusher] Ошибка: функция создания md отработала, но файл не сформирован."
+            )
             raise Exception(
-                '[acl_pusher] Ошибка: функция создания md отработала, но файл не сформирован.')
+                "[acl_pusher] Ошибка: функция создания md отработала, но файл не сформирован."
+            )
 
         file_md_abs = os.path.join(BASE_DIR, file_md)
         file_md_abs = os.path.normpath(file_md_abs)
         if not os.path.exists(file_md_abs):
-            send_to_mattermost('[acl_pusher] Ошибка: Сформированный md файл не существует.')
+            send_to_mattermost(
+                "[acl_pusher] Ошибка: Сформированный md файл не существует."
+            )
 
         gitlab_project = acl_object.project
         gitlab_filename = acl_object.git_filename
         gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
 
-        g = GitWorker(request,
-                      GITPRO=gitlab_repo_url,
-                      PATH_OF_GIT_REPO=None,
-                      MDFILE=file_md_abs,
-                      taskid=acl_object.id
-                      )
+        g = GitWorker(
+            request,
+            GITPRO=gitlab_repo_url,
+            PATH_OF_GIT_REPO=None,
+            MDFILE=file_md_abs,
+            taskid=acl_object.id,
+        )
         gitpush_successful = False
         if g:
             g.fetch()
             if g.clone():
-                g.repo.git.checkout('develop')
+                g.repo.git.checkout("develop")
                 f = g.activity(gitlab_filename)
                 if f:
                     if g.addindex(f):
-                        if g.push(refspec='develop:develop'):
-                            logger.info(f'[acl_pusher] acl успешно отправлен в git')
-                            send_to_mattermost('[acl_pusher] acl успешно отправлен в git')
+                        if g.push(refspec="develop:develop"):
+                            logger.info("[acl_pusher] acl успешно отправлен в git")
+                            send_to_mattermost(
+                                "[acl_pusher] acl успешно отправлен в git"
+                            )
                             gitpush_successful = True
                         else:
-                            send_to_mattermost('[acl_pusher] acl не удалось отправить в git')
+                            send_to_mattermost(
+                                "[acl_pusher] acl не удалось отправить в git"
+                            )
             g.free()
             return gitpush_successful
     except Exception as e:
-        print(f'[acl_pusher] Ошибка отправки в git:{e}')
-        send_to_mattermost(f'[acl_pusher] Ошибка при отправке в git: {e}')
-        logger.error(f'[acl_pusher] Ошибка при отправке в git: {e}')
+        print(f"[acl_pusher] Ошибка отправки в git:{e}")
+        send_to_mattermost(f"[acl_pusher] Ошибка при отправке в git: {e}")
+        logger.error(f"[acl_pusher] Ошибка при отправке в git: {e}")
         return False
 
-def check_taskid_and_status(request, *args, **kwargs):
-    '''Проверяет acl в omnitracker, если нет - переотправляет'''
 
-    if request.method == 'POST' and request.user.is_authenticated and request.user.is_superuser:
-        acl_list = request.POST.getlist('acl_list[]')
+def check_taskid_and_status(request, *args, **kwargs):
+    """Проверяет acl в omnitracker, если нет - переотправляет"""
+
+    if (
+        request.method == "POST"
+        and request.user.is_authenticated
+        and request.user.is_superuser
+    ):
+        acl_list = request.POST.getlist("acl_list[]")
         acl_objects = ACL.objects.filter(id__in=acl_list)
 
         success_checks_count = 0
@@ -918,11 +1169,14 @@ def check_taskid_and_status(request, *args, **kwargs):
                     try:
                         if acl_object.taskid:
                             send_to_mattermost(
-                                f"[acl_pusher] [Перехвачен Дубль обращения] ACL уже назначен Номер SD:{acl_object.taskid}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_object.id)}")
+                                f"[acl_pusher] [Перехвачен Дубль обращения] ACL уже назначен Номер SD:{acl_object.taskid}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_object.id)}"
+                            )
                             continue
 
                         try:
-                            gitlab_repo_url = ACLGitlabStore.objects.get(project=acl_object.project).gitlab_url
+                            gitlab_repo_url = ACLGitlabStore.objects.get(
+                                project=acl_object.project
+                            ).gitlab_url
                             local_storage = json.loads(acl_object.acltext)
                             doc_result = make_doc(
                                 request,
@@ -972,37 +1226,73 @@ def check_taskid_and_status(request, *args, **kwargs):
                         try:
                             gitpush_successful = send_acl_to_git(request, acl_object)
                             if not gitpush_successful:
-                                unsuccessful_git_push_acl.append(f'https://acl.vesta.ru/acl/info/{str(acl_object.id)}')
+                                unsuccessful_git_push_acl.append(
+                                    f"https://acl.vesta.ru/acl/info/{str(acl_object.id)}"
+                                )
                                 unsuccessful_send_git_count += 1
                         except Exception as e:
-                            send_to_mattermost(f"[acl_pusher] Ошибка при создании docx:{e}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_object.id)}")
-                            logger.error(f'[acl_pusher] Ошибка при создании docx: {e}')
-                            unsuccessful_make_docx_acl.append(f'https://acl.vesta.ru/acl/info/{str(acl_object.id)}')
+                            send_to_mattermost(
+                                f"[acl_pusher] Ошибка при создании docx:{e}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_object.id)}"
+                            )
+                            logger.error(f"[acl_pusher] Ошибка при создании docx: {e}")
+                            unsuccessful_make_docx_acl.append(
+                                f"https://acl.vesta.ru/acl/info/{str(acl_object.id)}"
+                            )
                             unsuccessful_count += 1
                             unsuccessful_make_docx_count += 1
                     except Exception as e:
-                        send_to_mattermost(f"[acl_pusher] Ошибка при отправке обращения в SD:{e}; ")
-                        logger.error(f'[acl_pusher] Ошибка при отправке обращения в SD: {e}')
+                        send_to_mattermost(
+                            f"[acl_pusher] Ошибка при отправке обращения в SD:{e}; "
+                        )
+                        logger.error(
+                            f"[acl_pusher] Ошибка при отправке обращения в SD: {e}"
+                        )
                         unsuccessful_count += 1
             except Exception as e:
-                send_to_mattermost(f"[acl_pusher] Ошибка при работе с acl({acl_object.id}): {e}; ")
-                logger.error(f'[acl_pusher] Ошибка при работе с acl({acl_object.id}): {e} ')
+                send_to_mattermost(
+                    f"[acl_pusher] Ошибка при работе с acl({acl_object.id}): {e}; "
+                )
+                logger.error(
+                    f"[acl_pusher] Ошибка при работе с acl({acl_object.id}): {e} "
+                )
                 unsuccessful_count += 1
                 continue
-        send_to_mattermost(f"[acl_pusher] Результат работы Доталкивателя ACL: ( ACL Проверено: {success_checks_count}; ACL переотправлено: {success_send_omni_count}).")
+        send_to_mattermost(
+            f"[acl_pusher] Результат работы Доталкивателя ACL: ( ACL Проверено: {success_checks_count}; ACL переотправлено: {success_send_omni_count})."
+        )
 
         unsuccessful_count_messages = [
-                                        f'[acl_pusher] Не удалось создать docx: {unsuccessful_make_docx_count}.' if unsuccessful_make_docx_count > 0 else '',
-                                        f'[acl_pusher] Не удалось отправить omni: {unsuccessful_count}.' if unsuccessful_count > 0 else '',
-                                        f'[acl_pusher] Не удалось отправить в git: {unsuccessful_send_git_count}.' if unsuccessful_send_git_count > 0 else '',
-                                        f'[acl_pusher] Не удалось сформировать docx для следующих ACL:{"; ".join(unsuccessful_make_docx_acl)}' if len(unsuccessful_make_docx_acl) > 0 else '',
-                                        f'[acl_pusher] Не удалось отправить в git следующие ACL:{"; ".join(unsuccessful_git_push_acl)}' if len(unsuccessful_git_push_acl) > 0 else ''
-                                      ]
+            (
+                f"[acl_pusher] Не удалось создать docx: {unsuccessful_make_docx_count}."
+                if unsuccessful_make_docx_count > 0
+                else ""
+            ),
+            (
+                f"[acl_pusher] Не удалось отправить omni: {unsuccessful_count}."
+                if unsuccessful_count > 0
+                else ""
+            ),
+            (
+                f"[acl_pusher] Не удалось отправить в git: {unsuccessful_send_git_count}."
+                if unsuccessful_send_git_count > 0
+                else ""
+            ),
+            (
+                f'[acl_pusher] Не удалось сформировать docx для следующих ACL:{"; ".join(unsuccessful_make_docx_acl)}'
+                if len(unsuccessful_make_docx_acl) > 0
+                else ""
+            ),
+            (
+                f'[acl_pusher] Не удалось отправить в git следующие ACL:{"; ".join(unsuccessful_git_push_acl)}'
+                if len(unsuccessful_git_push_acl) > 0
+                else ""
+            ),
+        ]
 
         for message in [m for m in unsuccessful_count_messages if m]:
             send_to_mattermost(message)
 
-        return HttpResponseRedirect(reverse('aclhistory_urls'))
+        return HttpResponseRedirect(reverse("aclhistory_urls"))
     return HttpResponse(json.dumps("acl_pusher error"), content_type="application/text")
 
 
@@ -1011,316 +1301,524 @@ def UploadTemplate(request):
         result = upload_file_handler(request, ParseDocx)
     except Exception as e:
         if request.is_ajax:
-            logger.error(f'Ошибка загрузки из файла. Формат не определён. Ошибка: {str(e)}')
-            result = {'error': "Ошибка загрузки из файла. Формат не определён."}
+            logger.error(
+                f"Ошибка загрузки из файла. Формат не определён. Ошибка: {str(e)}"
+            )
+            result = {"error": "Ошибка загрузки из файла. Формат не определён."}
         else:
             messages.error(request, str(e))
         logger.error("{} {}".format(stack()[0][3], str(e)))
 
-    if request.method == 'POST' and request.is_ajax:
+    if request.method == "POST" and request.is_ajax:
         return HttpResponse(json.dumps(result), content_type="application/text")
-    return HttpResponse(json.dumps("upload template error"), content_type="application/text")
+    return HttpResponse(
+        json.dumps("upload template error"), content_type="application/text"
+    )
 
 
 def CheckIp(request, ip=None):
     """Функция возвращает данные по IP"""
     return HttpResponse(json.dumps(ip_status(ip)), content_type="application/json")
 
+
 @csrf_exempt
 def AclRemove(request, *args, **kwargs):
     """Функция удалеяет данные по uuid"""
-    if request.method == 'POST':
-        result = {'error': 'Ошибка при удалении acl'}
-        if 'uuid' in request.POST:
-                if is_valid_uuid(request.POST.get('uuid', 0)):
-                       try:
-                            obj = ACL.objects.get(id=request.POST.get('uuid'))
-                            if obj:
-                                if obj.status in ['WTE', 'CMP']:
-                                    return HttpResponse(json.dumps({'error': 'Этот ACL нельзя удалить. Он либо на согласовании либо уже выполнен.'}), content_type="application/json")
-                                obj.delete()
-                                result = {'status': 'Запись acl удалена'}
-                       except ACL.DoesNotExist:
-                            result = {'error': 'Не всё записи удалены'}
+    if request.method == "POST":
+        result = {"error": "Ошибка при удалении acl"}
+        if "uuid" in request.POST:
+            if is_valid_uuid(request.POST.get("uuid", 0)):
+                try:
+                    obj = ACL.objects.get(id=request.POST.get("uuid"))
+                    if obj:
+                        if obj.status in ["WTE", "CMP"]:
+                            return HttpResponse(
+                                json.dumps(
+                                    {
+                                        "error": "Этот ACL нельзя удалить. Он либо на согласовании либо уже выполнен."
+                                    }
+                                ),
+                                content_type="application/json",
+                            )
+                        obj.delete()
+                        result = {"status": "Запись acl удалена"}
+                except ACL.DoesNotExist:
+                    result = {"error": "Не всё записи удалены"}
         return HttpResponse(json.dumps(result), content_type="application/json")
     return HttpResponse(status=405)
 
 
-
 @csrf_exempt
-def task(request, acl_id)->bool:
+def task(request, acl_id) -> bool:
     """Функция обработки запросов на выполнение активностей для выполнения обращения"""
-    logger.info(f'[Отправка в omni] Начинается выполнение task для (request,acl_id):({request},{acl_id})')
-    logger.info(f'[Отправка в omni] Проверка на валидность uuid:{is_valid_uuid(acl_id)}')
+    logger.info(
+        f"[Отправка в omni] Начинается выполнение task для (request,acl_id):({request},{acl_id})"
+    )
+    logger.info(
+        f"[Отправка в omni] Проверка на валидность uuid:{is_valid_uuid(acl_id)}"
+    )
     if not is_valid_uuid(acl_id):
-        result = {'error': 'Произошла ошибка, uuid не прошёл валидацию.'}
-        logger.info(f'[Отправка в omni] acl_id не прошел валидацию. Выход из функции. Вероятно данный ACL застрял в статусе "Согласовано". |acl_id:{acl_id}.')
-        send_to_mattermost(f'[Отправка в omni] acl_id не прошел валидацию. Выход из функции. Вероятно данный ACL застрял в статусе "Согласовано". |acl_id:{acl_id}.')
-        return HttpResponse(json.dumps(result, ensure_ascii=False), content_type="application/json")
+        result = {"error": "Произошла ошибка, uuid не прошёл валидацию."}
+        logger.info(
+            f'[Отправка в omni] acl_id не прошел валидацию. Выход из функции. Вероятно данный ACL застрял в статусе "Согласовано". |acl_id:{acl_id}.'
+        )
+        send_to_mattermost(
+            f'[Отправка в omni] acl_id не прошел валидацию. Выход из функции. Вероятно данный ACL застрял в статусе "Согласовано". |acl_id:{acl_id}.'
+        )
+        return HttpResponse(
+            json.dumps(result, ensure_ascii=False), content_type="application/json"
+        )
 
     JOB = cache.get(acl_id, {})
     is_work_omni = False
     try:
         obj = ACL.objects.get(id=acl_id)
-        logger.info(f'[Отправка в omni] Получен obj по acl_id({acl_id})')
-        logger.info(f'[Отправка в omni] Проверка данных этого acl: owner({obj.owner}), project:({obj.project}), git_filename:({obj.git_filename})')
+        logger.info(f"[Отправка в omni] Получен obj по acl_id({acl_id})")
+        logger.info(
+            f"[Отправка в omni] Проверка данных этого acl: owner({obj.owner}), project:({obj.project}), git_filename:({obj.git_filename})"
+        )
         local_storage = json.loads(obj.acltext)
-        if local_storage == '':
-            result = {'error': 'Произошла ошибка: не найдены данные acl.'}
+        if local_storage == "":
+            result = {"error": "Произошла ошибка: не найдены данные acl."}
             log_message = f'[Отправка в omni] local_storage в БД пустой. Выход из функции. Вероятно данный ACL застрял в статусе "Согласовано". |acl_id:{acl_id}|.'
             logger.info(log_message, f" local_storage:{local_storage}.")
             send_to_mattermost(log_message)
-            return HttpResponse(json.dumps(result, ensure_ascii=False), content_type="application/json")
+            return HttpResponse(
+                json.dumps(result, ensure_ascii=False), content_type="application/json"
+            )
     except obj.DoesNotExist:
         log_message = f'[Отправка в omni] Не удалось найти объект с acl_id:{acl_id}. Выход из функции. Вероятно данный ACL застрял на статусе "Согласовано".'
         logger.info(log_message)
         send_to_mattermost(log_message)
-        return HttpResponse(json.dumps('Нет такого ACL', ensure_ascii=False), content_type="application/json")
+        return HttpResponse(
+            json.dumps("Нет такого ACL", ensure_ascii=False),
+            content_type="application/json",
+        )
 
     except Exception as e:
         log_message = f'[Отправка в omni] Произошла ошибка:{e}. Выход из функции. Вероятно данный ACL({acl_id}) застрял на статусе "Согласовано".'
         logger.info(log_message)
         send_to_mattermost(log_message)
-        return HttpResponse(json.dumps('Нет такого ACL', ensure_ascii=False), content_type="application/json")
-
-    if obj.status == 'FLY':
-        logger.info(f'[Отправка в omni] Статус == FLY(В процессе). Выход из функции. Вероятно данный ACL застрял на статусе "Согласовано".')
-        send_to_mattermost(f'[Отправка в omni] Статус == FLY(В процессе). Выход из функции. Вероятно данный ACL застрял на статусе "Согласовано".')
-        return HttpResponse(json.dumps({'status': JOB}, ensure_ascii=False), content_type="application/json")
-
+        return HttpResponse(
+            json.dumps("Нет такого ACL", ensure_ascii=False),
+            content_type="application/json",
+        )
+
+    if obj.status == "FLY":
+        logger.info(
+            '[Отправка в omni] Статус == FLY(В процессе). Выход из функции. Вероятно данный ACL застрял на статусе "Согласовано".'
+        )
+        send_to_mattermost(
+            '[Отправка в omni] Статус == FLY(В процессе). Выход из функции. Вероятно данный ACL застрял на статусе "Согласовано".'
+        )
+        return HttpResponse(
+            json.dumps({"status": JOB}, ensure_ascii=False),
+            content_type="application/json",
+        )
 
     if any([job for job in tasklist if job in request.session]) and JOB.__len__() == 0:
         cache.set(acl_id, {})
-        if obj.taskid != '':
-            logger.info('Номер существует')
+        if obj.taskid != "":
+            logger.info("Номер существует")
         else:
-            logger.info('[НОМЕР обращения не задан!]')
-            obj.status = 'FLY'
+            logger.info("[НОМЕР обращения не задан!]")
+            obj.status = "FLY"
             with transaction.atomic():
-                obj.save(update_fields=['status'])
+                obj.save(update_fields=["status"])
 
     sleep(1)
     is_work_done = False
     result_id = None
     doc_ready = False
-    if 'ACT_MAKE_GIT' in request.session:
-        UpdateCallBackStatus(request, acl_id, 'git_upload_status', 'Генерация md файла')
+    if "ACT_MAKE_GIT" in request.session:
+        UpdateCallBackStatus(request, acl_id, "git_upload_status", "Генерация md файла")
 
-    if 'ACT_MAKE_DOCX' in request.session:
-        UpdateCallBackStatus(request, acl_id, 'docx_download_status', 'Генерация docx файла')
+    if "ACT_MAKE_DOCX" in request.session:
+        UpdateCallBackStatus(
+            request, acl_id, "docx_download_status", "Генерация docx файла"
+        )
     try:
         gitlab_filename = obj.git_filename
         gitlab_project = obj.project
         gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
-        logger.info(f'[Отправка в omni] Проверка данных полученных перед формированием файла: filename:{gitlab_filename}, project:{gitlab_project}, repo_url:{gitlab_repo_url}', )
-        logger.info(f'[Отправка в omni] Проверка local_storage перед формированием word:{local_storage}')
-        doc_result = make_doc(request, local_storage, gitlab_repo_url=gitlab_repo_url, gitlab_filename=gitlab_filename)
-        logger.info(f'[Отправка в omni] Сформирован word документ: {doc_result}')
+        logger.info(
+            f"[Отправка в omni] Проверка данных полученных перед формированием файла: filename:{gitlab_filename}, project:{gitlab_project}, repo_url:{gitlab_repo_url}",
+        )
+        logger.info(
+            f"[Отправка в omni] Проверка local_storage перед формированием word:{local_storage}"
+        )
+        doc_result = make_doc(
+            request,
+            local_storage,
+            gitlab_repo_url=gitlab_repo_url,
+            gitlab_filename=gitlab_filename,
+        )
+        logger.info(f"[Отправка в omni] Сформирован word документ: {doc_result}")
         doc_ready = True
     except Exception as e:
-        logger.error(f'[Отправка в omni] Произошла ошибка при создании docx файла: {e}. |acl_id:{acl_id}|local_storage:{json.loads(obj.acltext)}|')
-        send_to_mattermost(f'[Отправка в omni]. |acl_id:{acl_id}| Произошла ошибка при создании docx файла: {e}')
-        UpdateCallBackStatus(request, acl_id, 'docx_download_status', 'Произошла ошибка при создании docx файла: {}'.format(e), 0)
+        logger.error(
+            f"[Отправка в omni] Произошла ошибка при создании docx файла: {e}. |acl_id:{acl_id}|local_storage:{json.loads(obj.acltext)}|"
+        )
+        send_to_mattermost(
+            f"[Отправка в omni]. |acl_id:{acl_id}| Произошла ошибка при создании docx файла: {e}"
+        )
+        UpdateCallBackStatus(
+            request,
+            acl_id,
+            "docx_download_status",
+            "Произошла ошибка при создании docx файла: {}".format(e),
+            0,
+        )
         is_work_done = False
     finally:
-        logger.info(f'[Отправка в omni] Выполнение finally в task. doc_ready:{doc_ready}')
+        logger.info(
+            f"[Отправка в omni] Выполнение finally в task. doc_ready:{doc_ready}"
+        )
         if doc_ready:
-            if 'ACT_MAKE_DOCX' in request.session:
-                del request.session['ACT_MAKE_DOCX']
-                logger.info(f'Файл docx успешно сформирован. ACT_MAKE_DOCX удалён из сессии.')
-                UpdateCallBackStatus(request, acl_id, 'docx_download_status', "Файл docx успешно сформирован", 2)
-    if 'ACT_OMNI' in request.session:
-        logger.error('ПРЕВЕД МЕДВЕД')
+            if "ACT_MAKE_DOCX" in request.session:
+                del request.session["ACT_MAKE_DOCX"]
+                logger.info(
+                    "Файл docx успешно сформирован. ACT_MAKE_DOCX удалён из сессии."
+                )
+                UpdateCallBackStatus(
+                    request,
+                    acl_id,
+                    "docx_download_status",
+                    "Файл docx успешно сформирован",
+                    2,
+                )
+    if "ACT_OMNI" in request.session:
+        logger.error("ПРЕВЕД МЕДВЕД")
         try:
-            if obj.taskid != '':
-                send_to_mattermost(f"[Перехвачен Дубль обращения] ACL уже назначен Номер SD:{obj.taskid}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(obj.id)}")
-                return HttpResponse(json.dumps({'status': obj.status, 'isdouble':True}, ensure_ascii=False), content_type="application/json")
+            if obj.taskid != "":
+                send_to_mattermost(
+                    f"[Перехвачен Дубль обращения] ACL уже назначен Номер SD:{obj.taskid}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(obj.id)}"
+                )
+                return HttpResponse(
+                    json.dumps(
+                        {"status": obj.status, "isdouble": True}, ensure_ascii=False
+                    ),
+                    content_type="application/json",
+                )
             is_work_omni = True
             omni_job = cache.get(acl_id, {})
             if settings.DEBUG:
                 logger.debug("OMNI CACHE STATUS: {}".format(omni_job))
 
-            if omni_job.keys().__len__() > 0 or (obj.status == 'JOB' and len(obj.taskid) >= 3):
-                if 'omni_email_status' in omni_job:  # or obj.taskid == 'PRO':
+            if omni_job.keys().__len__() > 0 or (
+                obj.status == "JOB" and len(obj.taskid) >= 3
+            ):
+                if "omni_email_status" in omni_job:  # or obj.taskid == 'PRO':
                     if settings.DEBUG:
-                        logger.debug('[TRACE] Активность {} пропущена ввиду незавершенного предыдушей задачи: {} {}'.format(omni_job, obj.taskid))
-                    return HttpResponse(json.dumps({'status': JOB}, ensure_ascii=False), content_type="application/json")
+                        logger.debug(
+                            "[TRACE] Активность {} пропущена ввиду незавершенного предыдушей задачи: {} {}".format(
+                                omni_job, obj.taskid
+                            )
+                        )
+                    return HttpResponse(
+                        json.dumps({"status": JOB}, ensure_ascii=False),
+                        content_type="application/json",
+                    )
             if doc_ready:
-                UpdateCallBackStatus(request, acl_id, 'omni_email_status', 'Отправляем запрос на сервер ... (Пожалуйста, подождите)')
+                UpdateCallBackStatus(
+                    request,
+                    acl_id,
+                    "omni_email_status",
+                    "Отправляем запрос на сервер ... (Пожалуйста, подождите)",
+                )
             else:
                 try:
-                    UpdateCallBackStatus(request, acl_id, 'omni_email_status', 'Генерация docx файла...')
+                    UpdateCallBackStatus(
+                        request, acl_id, "omni_email_status", "Генерация docx файла..."
+                    )
                     gitlab_filename = obj.git_filename
                     gitlab_project = obj.project
-                    gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
-                    logger.info(f"[send omni 2] Проверка local_storage из БД: {local_storage}")
-                    doc_result = make_doc(request, local_storage, acl_id, gitlab_repo_url=gitlab_repo_url, gitlab_filename=gitlab_filename)
+                    gitlab_repo_url = ACLGitlabStore.objects.get(
+                        project=gitlab_project
+                    ).gitlab_url
+                    logger.info(
+                        f"[send omni 2] Проверка local_storage из БД: {local_storage}"
+                    )
+                    doc_result = make_doc(
+                        request,
+                        local_storage,
+                        acl_id,
+                        gitlab_repo_url=gitlab_repo_url,
+                        gitlab_filename=gitlab_filename,
+                    )
                     doc_ready = True
                 except Exception as e:
                     logger.error(e)
-                    send_to_mattermost(f'[send omni 2] |acl_id:{acl_id}| Ошибка повторного формирования word:{e}')
+                    send_to_mattermost(
+                        f"[send omni 2] |acl_id:{acl_id}| Ошибка повторного формирования word:{e}"
+                    )
 
             try:
                 if settings.OMNITRACKER_URL:
                     try:
                         docx_url = f"{request.get_host()}/{doc_result[1:]}"
-                        logger.debug('URL ОТПРАВКИ В OMNI ' + str(docx_url))
+                        logger.debug("URL ОТПРАВКИ В OMNI " + str(docx_url))
 
-                        if '://' not in docx_url:
-                            docx_url = 'https://' + docx_url
+                        if "://" not in docx_url:
+                            docx_url = "https://" + docx_url
 
                     except:
-                        docx_url = ''
-                    result_id = send_onmitracker(sender=obj.owner.email,
-                                                 title=f'SH0458 Запрос на предоставление доступа согласован : {str(ACL.objects.get(id=acl_id).approve.first().get_full_name())}',
-                                                 text=f'Прошу предоставить сетевой доступ, согласно ACL. Согласование владельца ресурса во вложении. Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_id)}',
-                                                 attach=docx_url,
-                                                 fake=False,
-                                                 request=request,
-                                                 uid=acl_id
-                                                 )
+                        docx_url = ""
+                    result_id = send_onmitracker(
+                        sender=obj.owner.email,
+                        title=f"SH0458 Запрос на предоставление доступа согласован : {str(ACL.objects.get(id=acl_id).approve.first().get_full_name())}",
+                        text=f"Прошу предоставить сетевой доступ, согласно ACL. Согласование владельца ресурса во вложении. Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(acl_id)}",
+                        attach=docx_url,
+                        fake=False,
+                        request=request,
+                        uid=acl_id,
+                    )
                 result_id = int(result_id) or 0
                 if result_id == 0:
                     # UpdateCallBackStatus(request, uid, 'omni_email_status',
                     # 'Мы не смогли создать обращение через OmniTracker, отправим почтой...')
-                    raise Exception('Мы не смогли создать обращение через OmniTracker, отправляем почтой...')
+                    raise Exception(
+                        "Мы не смогли создать обращение через OmniTracker, отправляем почтой..."
+                    )
                 else:
 
                     if obj:
                         obj.taskid = str(result_id)
-                    #     obj.status = 'JOB'
-                        obj.save(update_fields=['taskid'])
-                        send_to_mattermost(f'[owner={obj.owner}, Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(obj.id)}] Получен номер SD("{result_id}"). Добавление Номера SD в БД. Проверка записи: obj.taskid={obj.taskid}')
-                    UpdateCallBackStatus(request, acl_id, 'omni_email_status',
-                                         '<p class="text-success">Обращение под номером {} успешно зарегистрировано</p>'.format(
-                                             result_id), 2)
-                    UpdateCallBackStatus(request, acl_id, 'omni_track_id', '{}'.format(result_id))
-                    if 'ACT_OMNI' in request.session: del request.session['ACT_OMNI']
-
-
+                        #     obj.status = 'JOB'
+                        obj.save(update_fields=["taskid"])
+                        send_to_mattermost(
+                            f'[owner={obj.owner}, Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(obj.id)}] Получен номер SD("{result_id}"). Добавление Номера SD в БД. Проверка записи: obj.taskid={obj.taskid}'
+                        )
+                    UpdateCallBackStatus(
+                        request,
+                        acl_id,
+                        "omni_email_status",
+                        '<p class="text-success">Обращение под номером {} успешно зарегистрировано</p>'.format(
+                            result_id
+                        ),
+                        2,
+                    )
+                    UpdateCallBackStatus(
+                        request, acl_id, "omni_track_id", "{}".format(result_id)
+                    )
+                    if "ACT_OMNI" in request.session:
+                        del request.session["ACT_OMNI"]
 
             except Exception as e:
-                logger.error('{}|{}|{}'.format(stack()[0][3], str(e), request.META.get('REMOTE_ADDR')))
-                UpdateCallBackStatus(request, acl_id, 'omni_email_status','{}'.format(str(e)))
-                sleep(3) #Ждем callback для уведомления пользователю
+                logger.error(
+                    "{}|{}|{}".format(
+                        stack()[0][3], str(e), request.META.get("REMOTE_ADDR")
+                    )
+                )
+                UpdateCallBackStatus(
+                    request, acl_id, "omni_email_status", "{}".format(str(e))
+                )
+                sleep(3)  # Ждем callback для уведомления пользователю
 
                 doc_result = os.path.join(BASE_DIR, doc_result[1:])
-                logger.error('ТЕМА ПИСЬМА ' + 'SH0458 Предоставление доступа  Согласовано = '+ str(ACL.objects.get(id=acl_id).approve.first().get_full_name()))
-
-                e = EmailMessage(subject='SH0458 Запрос на предоставление доступа согласован :  '+ str(ACL.objects.get(id=acl_id).approve.first().get_full_name()),
-                                 body='Прошу предоставить сетевой доступ, согласно ACL. Согласование владельца ресурса во вложении. Ссылка на ACL : https://acl.vesta.ru'+ '/acl/info/'+str(acl_id),
-                                 from_email=obj.owner.email,
-                                 to=[settings.EMAIL_SD], reply_to=[settings.EMAIL_ADMIN])
+                logger.error(
+                    "ТЕМА ПИСЬМА "
+                    + "SH0458 Предоставление доступа  Согласовано = "
+                    + str(ACL.objects.get(id=acl_id).approve.first().get_full_name())
+                )
+
+                e = EmailMessage(
+                    subject="SH0458 Запрос на предоставление доступа согласован :  "
+                    + str(ACL.objects.get(id=acl_id).approve.first().get_full_name()),
+                    body="Прошу предоставить сетевой доступ, согласно ACL. Согласование владельца ресурса во вложении. Ссылка на ACL : https://acl.vesta.ru"
+                    + "/acl/info/"
+                    + str(acl_id),
+                    from_email=obj.owner.email,
+                    to=[settings.EMAIL_SD],
+                    reply_to=[settings.EMAIL_ADMIN],
+                )
                 e.attach_file(doc_result)
                 e.send(fail_silently=settings.DEBUG)
                 is_work_done = True
-                #obj.taskid = str(result_id)
-                #obj.status = 'JOB'
-                #obj.save(update_fields=['taskid', 'status'])
+                # obj.taskid = str(result_id)
+                # obj.status = 'JOB'
+                # obj.save(update_fields=['taskid', 'status'])
 
         except Exception as e:
-            UpdateCallBackStatus(request, acl_id, 'omni_email_status', 'Произошла ошибка при отправки обращения в SD', 0)
+            UpdateCallBackStatus(
+                request,
+                acl_id,
+                "omni_email_status",
+                "Произошла ошибка при отправки обращения в SD",
+                0,
+            )
             logger.error(str(e))
             is_work_done = False
         finally:
             if doc_result:
-                if 'ACT_OMNI' in request.session: del request.session['ACT_OMNI']
+                if "ACT_OMNI" in request.session:
+                    del request.session["ACT_OMNI"]
                 if result_id is not None and result_id > 0:
-                    UpdateCallBackStatus(request, acl_id, 'omni_email_status',
-                                         '<p class="text-success">Обращение под номером {} успешно зарегистрировано</p>'.format(
-                                             result_id), 2)
+                    UpdateCallBackStatus(
+                        request,
+                        acl_id,
+                        "omni_email_status",
+                        '<p class="text-success">Обращение под номером {} успешно зарегистрировано</p>'.format(
+                            result_id
+                        ),
+                        2,
+                    )
                 else:
-                    UpdateCallBackStatus(request, acl_id, 'omni_email_status', 'Обращение успешно создано (через SD, номер в почте).', 2)
-
-    if 'ACT_MAKE_GIT' in request.session:
-        #UpdateCallBackStatus(request, acl_id, 'git_upload_status', 'Генерация md файла')
+                    UpdateCallBackStatus(
+                        request,
+                        acl_id,
+                        "omni_email_status",
+                        "Обращение успешно создано (через SD, номер в почте).",
+                        2,
+                    )
+
+    if "ACT_MAKE_GIT" in request.session:
+        # UpdateCallBackStatus(request, acl_id, 'git_upload_status', 'Генерация md файла')
         try:
-            file_md = MakeMarkDown(request, local_storage, 'acl_{}'.format(acl_id), acl_id) or 'None'
+            file_md = (
+                MakeMarkDown(request, local_storage, "acl_{}".format(acl_id), acl_id)
+                or "None"
+            )
             if not file_md:
-                send_to_mattermost(f'Не удалось создать md файл. acl_id:{acl_id}')
-                raise Exception('Ошибка при создании md файла')
-
-            UpdateCallBackStatus(request, acl_id, 'git_upload_file', "<a href='{}'style='font-size: 16px' " \
-                                                                     "class='card-link card-download-file text-primary' " \
-                                                                     "target='_blank' download>" \
-                                                                     "<i class='fab fa-github pr-1'>" \
-                                                                     "</i> Скачать md-файл</a>".format(file_md), 2)
-
-            file_md_abs = os.path.join(BASE_DIR, 'static/md/' + 'acl_{}'.format(str(acl_id)) + '.md')
-            if '/' in file_md_abs:
-                if 'linux' not in sys.platform:
-                    file_md_abs = file_md_abs.replace('/', '\\')
+                send_to_mattermost(f"Не удалось создать md файл. acl_id:{acl_id}")
+                raise Exception("Ошибка при создании md файла")
+
+            UpdateCallBackStatus(
+                request,
+                acl_id,
+                "git_upload_file",
+                "<a href='{}'style='font-size: 16px' "
+                "class='card-link card-download-file text-primary' "
+                "target='_blank' download>"
+                "<i class='fab fa-github pr-1'>"
+                "</i> Скачать md-файл</a>".format(file_md),
+                2,
+            )
+
+            file_md_abs = os.path.join(
+                BASE_DIR, "static/md/" + "acl_{}".format(str(acl_id)) + ".md"
+            )
+            if "/" in file_md_abs:
+                if "linux" not in sys.platform:
+                    file_md_abs = file_md_abs.replace("/", "\\")
             if not os.path.exists(file_md_abs):
-                file_md_abs = os.path.join(BASE_DIR, 'static/md/' + 'acl_{}'.format(str(acl_id)) + '.md')
-                logger.error(f'[Формирование md] Ошибка при формировании пути md файла.')
-                UpdateCallBackStatus(request, acl_id, 'git_upload_status', 'Ошибка при формировании пути md файла', 0)
+                file_md_abs = os.path.join(
+                    BASE_DIR, "static/md/" + "acl_{}".format(str(acl_id)) + ".md"
+                )
+                logger.error("[Формирование md] Ошибка при формировании пути md файла.")
+                UpdateCallBackStatus(
+                    request,
+                    acl_id,
+                    "git_upload_status",
+                    "Ошибка при формировании пути md файла",
+                    0,
+                )
                 # return HttpResponse(json.dumps({'status': cache.get(acl_id, {})}), content_type="application/json")
 
-            UpdateCallBackStatus(request, acl_id, 'git_upload_status', 'Отправка запроса в gitlab')
+            UpdateCallBackStatus(
+                request, acl_id, "git_upload_status", "Отправка запроса в gitlab"
+            )
             gitlab_project = obj.project
             gitlab_filename = obj.git_filename
-            gitlab_repo_url = ACLGitlabStore.objects.get(project=gitlab_project).gitlab_url
-
-            g = GitWorker(request, gitlab_repo_url, PATH_OF_GIT_REPO=None, MDFILE=file_md_abs,
-                          taskid=acl_id)
+            gitlab_repo_url = ACLGitlabStore.objects.get(
+                project=gitlab_project
+            ).gitlab_url
+
+            g = GitWorker(
+                request,
+                gitlab_repo_url,
+                PATH_OF_GIT_REPO=None,
+                MDFILE=file_md_abs,
+                taskid=acl_id,
+            )
             if g:
                 g.pull()
                 if g.clone():
-                    g.repo.git.checkout('develop')
+                    g.repo.git.checkout("develop")
                     f = g.activity(gitlab_filename)
                     if f:
                         if g.addindex(f):
-                            UpdateCallBackStatus(request, acl_id, 'git_upload_status',
-                                                 "Отправка изменений на сервер")
-                            if g.push(refspec='develop:develop'):
-                                UpdateCallBackStatus(request, acl_id, 'git_upload_status', f"Файл {gitlab_filename} успешно загружен в репозиторий", 2)
+                            UpdateCallBackStatus(
+                                request,
+                                acl_id,
+                                "git_upload_status",
+                                "Отправка изменений на сервер",
+                            )
+                            if g.push(refspec="develop:develop"):
+                                UpdateCallBackStatus(
+                                    request,
+                                    acl_id,
+                                    "git_upload_status",
+                                    f"Файл {gitlab_filename} успешно загружен в репозиторий",
+                                    2,
+                                )
                                 is_work_done = True
-                                send_to_mattermost(f'[Отправка изменений в giltab] acl({acl_id}) успешно отправлен в gitlab')
+                                send_to_mattermost(
+                                    f"[Отправка изменений в giltab] acl({acl_id}) успешно отправлен в gitlab"
+                                )
                                 if settings.DEBUG:
-                                    logger.debug('Файл загружен в проект')
+                                    logger.debug("Файл загружен в проект")
                             else:
-                                send_to_mattermost(f'[Отправка изменений в giltab] Не удалось отправить acl({acl_id}) в gitlab')
+                                send_to_mattermost(
+                                    f"[Отправка изменений в giltab] Не удалось отправить acl({acl_id}) в gitlab"
+                                )
                 g.free()
         except Exception as e:
-            logger.error(f'Ошибка при отправке в git: {e}')
-            UpdateCallBackStatus(request, acl_id, 'git_upload_status', '{}'.format(e), 0)
-            #is_work_done = False
+            logger.error(f"Ошибка при отправке в git: {e}")
+            UpdateCallBackStatus(
+                request, acl_id, "git_upload_status", "{}".format(e), 0
+            )
+            # is_work_done = False
         finally:
-            if 'ACT_MAKE_GIT' in request.session: del request.session['ACT_MAKE_GIT']
+            if "ACT_MAKE_GIT" in request.session:
+                del request.session["ACT_MAKE_GIT"]
             if settings.DEBUG:
-                logger.debug('Очистка переменных GIT')
+                logger.debug("Очистка переменных GIT")
 
         # obj = ACL.objects.get(id=request.POST.get('uuid'))
 
     JOB = cache.get(acl_id, {})
 
-    if obj and ((obj.status == 'APRV' and obj.approve) or (obj.status == 'FL' and is_work_done)):
+    if obj and (
+        (obj.status == "APRV" and obj.approve) or (obj.status == "FL" and is_work_done)
+    ):
         if is_work_omni:
-            obj.status = 'JOB'
+            obj.status = "JOB"
         else:
-            obj.status = 'APRV' #Фикс баги если сформировать docx то статус будет на исполнении
+            obj.status = (
+                "APRV"  # Фикс баги если сформировать docx то статус будет на исполнении
+            )
     if result_id:
         obj.taskid = str(result_id)
-    #else:
-    #obj.status = 'FL'
-    if is_work_done or obj.status == 'FLY':
+    # else:
+    # obj.status = 'FL'
+    if is_work_done or obj.status == "FLY":
         if is_work_omni:
-            obj.status = 'JOB'
+            obj.status = "JOB"
         else:
-            obj.status = 'APRV' #Фикс баги если сформировать docx то статус будет на исполнении
+            obj.status = (
+                "APRV"  # Фикс баги если сформировать docx то статус будет на исполнении
+            )
         with transaction.atomic():
-            obj.save(update_fields=['status', 'taskid'])
+            obj.save(update_fields=["status", "taskid"])
     if settings.DEBUG:
-        print("REQUEST FINISH, SAVING DATA: {}: {}".format([job for job in tasklist if job in request.session], JOB))
+        print(
+            "REQUEST FINISH, SAVING DATA: {}: {}".format(
+                [job for job in tasklist if job in request.session], JOB
+            )
+        )
 
-    return HttpResponse(json.dumps({'status': 'complete'}, ensure_ascii=False), content_type="application/json")
+    return HttpResponse(
+        json.dumps({"status": "complete"}, ensure_ascii=False),
+        content_type="application/json",
+    )
 
 
 @csrf_exempt
 def act(request, acl_id=None, job=None, do=None):
-    result = {'done': 'Данные сохранены'}
+    result = {"done": "Данные сохранены"}
     obj = None
-    if job not in jobs or do not in ['remove', 'add']:
+    if job not in jobs or do not in ["remove", "add"]:
         return HttpResponseForbidden(request)
 
     try:
@@ -1328,9 +1826,8 @@ def act(request, acl_id=None, job=None, do=None):
     except:
         return HttpResponseNotFound(request)
 
-
-    old = str(obj.activity).split(';')
-    if do == 'remove':
+    old = str(obj.activity).split(";")
+    if do == "remove":
         for j in jobs:
             if j == job:
                 if tasklist[jobs.index(j)] in old:
@@ -1338,40 +1835,41 @@ def act(request, acl_id=None, job=None, do=None):
                     # if j == 'git':
                     #         git_url = [x for x in old if ':' in x]
                     #         if len(git_url) > 0: old.remove(git_url[0])
-                            # if 'GIT_URL' in request.session: del request.session['GIT_URL']
-                            # if 'GIT_FILENAME' in request.session: del request.session['GIT_FILENAME']
+                    # if 'GIT_URL' in request.session: del request.session['GIT_URL']
+                    # if 'GIT_FILENAME' in request.session: del request.session['GIT_FILENAME']
                     if tasklist[jobs.index(j)] in request.session:
                         del request.session[tasklist[jobs.index(j)]]
                     break
     else:
-       if tasklist[jobs.index(job)] not in old:
-         old.append(tasklist[jobs.index(job)])
-         request.session[tasklist[jobs.index(job)]] = True
-
-         # if job == 'git' and request.POST.get('git_url', '') != '':
-         #     request.session['GIT_URL'] = request.POST.get('git_url')
-         #     old.append(request.POST.get('git_url'))
-         # if job == 'git' and request.POST.get('git_file', '') != '':
-         #     request.session['GIT_FILENAME'] = request.POST.get('git_file')
-         #     old.append(request.POST.get('git_file'))
-
-    #if len(old) > 0:
+        if tasklist[jobs.index(job)] not in old:
+            old.append(tasklist[jobs.index(job)])
+            request.session[tasklist[jobs.index(job)]] = True
+
+            # if job == 'git' and request.POST.get('git_url', '') != '':
+            #     request.session['GIT_URL'] = request.POST.get('git_url')
+            #     old.append(request.POST.get('git_url'))
+            # if job == 'git' and request.POST.get('git_file', '') != '':
+            #     request.session['GIT_FILENAME'] = request.POST.get('git_file')
+            #     old.append(request.POST.get('git_file'))
+
+    # if len(old) > 0:
     old = ";".join(old)
     if old != obj.activity:
-            obj.activity = old
-            obj.save(update_fields=['activity'])
-    return HttpResponse(json.dumps(result, ensure_ascii=False), content_type="application/json")
-
+        obj.activity = old
+        obj.save(update_fields=["activity"])
+    return HttpResponse(
+        json.dumps(result, ensure_ascii=False), content_type="application/json"
+    )
 
 
 def taskstatus(request, taskid=None):
     """Функция возвращает данные по taskid"""
-    omni_acl_status = ''
-    omni_http_status = 'Статус неизвестен'
+    omni_acl_status = ""
+    omni_http_status = "Статус неизвестен"
     result = {str(taskid): {omni_http_status: omni_acl_status}}
     obj = None
 
-    #obj = ACL.objects.filter(owner=request.user).order_by('-pkid')
+    # obj = ACL.objects.filter(owner=request.user).order_by('-pkid')
     # if taskid == '00000' and request.user:
     #     obj = ACL.objects.filter(owner=request.user).order_by('-pkid')
     #     if len(obj) > 1:
@@ -1386,179 +1884,242 @@ def taskstatus(request, taskid=None):
     #     except Exception as e:
     #         logger.error(str(e))
     try:
-        if taskid and re.match(r'^\d{3,}$', taskid):
-            obj = ACL.objects.filter(taskid__exact=taskid).order_by('-pkid')
+        if taskid and re.match(r"^\d{3,}$", taskid):
+            obj = ACL.objects.filter(taskid__exact=taskid).order_by("-pkid")
         else:
-            obj = ACL.objects.filter(id__exact=taskid).order_by('-pkid')
+            obj = ACL.objects.filter(id__exact=taskid).order_by("-pkid")
     except Exception as e:
         logger.error(str(e))
 
     if obj:
-        obj = obj[0] #first el
-        if obj.taskid and re.match(r'^\d{3,}$', obj.taskid):
+        obj = obj[0]  # first el
+        if obj.taskid and re.match(r"^\d{3,}$", obj.taskid):
             omni_acl_status, omni_http_status = omni_check_status(obj.taskid)
             if None == omni_acl_status:
-                result = {'error': 'Could not check omni status, omni_check_status[1422] return None'}
+                result = {
+                    "error": "Could not check omni status, omni_check_status[1422] return None"
+                }
             else:
                 result = {str(obj.id): {omni_http_status: omni_acl_status}}
 
         if omni_acl_status != obj.status:
-            if omni_acl_status in ['CMP', 'JOB', 'CNL']:
+            if omni_acl_status in ["CMP", "JOB", "CNL"]:
                 obj.status = omni_acl_status
-                obj.save(update_fields=['status'])
+                obj.save(update_fields=["status"])
     result = {str(taskid): {omni_http_status: omni_acl_status}}
-    return HttpResponse(json.dumps(result, ensure_ascii=False)) #content_type="application/json",
+    return HttpResponse(
+        json.dumps(result, ensure_ascii=False)
+    )  # content_type="application/json",
+
 
 def TaskStatus(request, acl_id):
     if not is_valid_uuid(acl_id):
-        return HttpResponse(json.dumps({'error': 'Произошла ошибка, вероятно отсутствуют данные для выполнения.'}, ensure_ascii=False), content_type="application/json")
-    return HttpResponse(json.dumps({'status': cache.get(acl_id, {})}, ensure_ascii=False), content_type="application/json")
-
-
-def MakeBackgroundTask(*args,**kwargs):
+        return HttpResponse(
+            json.dumps(
+                {
+                    "error": "Произошла ошибка, вероятно отсутствуют данные для выполнения."
+                },
+                ensure_ascii=False,
+            ),
+            content_type="application/json",
+        )
+    return HttpResponse(
+        json.dumps({"status": cache.get(acl_id, {})}, ensure_ascii=False),
+        content_type="application/json",
+    )
+
+
+def MakeBackgroundTask(*args, **kwargs):
     request = kwargs.get("request")
     acl_id = kwargs.get("acl_id")
     task(request, acl_id)
 
+
 def sync_gitlab_projects(request=None):
     try:
         new_projects_list = []
         gitlab_project_list = sync_acl_portal_projects_list()
         for gitlab_project in gitlab_project_list:
-            project_obj, created = ACLGitlabStore.objects.get_or_create(gitlab_url=gitlab_project['http_url_to_repo'])
+            project_obj, created = ACLGitlabStore.objects.get_or_create(
+                gitlab_url=gitlab_project["http_url_to_repo"]
+            )
             if created:
                 project_obj.project = gitlab_project["full_path"]
-                project_obj.gitlab_url = gitlab_project['http_url_to_repo']
+                project_obj.gitlab_url = gitlab_project["http_url_to_repo"]
                 project_obj.save()
 
                 new_projects_list.append(model_to_dict(project_obj))
-        return HttpResponse(json.dumps(new_projects_list), content_type="application/text")
+        return HttpResponse(
+            json.dumps(new_projects_list), content_type="application/text"
+        )
     except Exception as e:
         logger.error(f"[Ошибка при Обновлении списка проектов] {e}")
         return HttpResponse(json.dumps([]), content_type="application/text")
 
+
 def get_project_filter_by_department(request=None):
 
     try:
-        team_id = request.GET.get('team_id')
-        if team_id != '':
+        team_id = request.GET.get("team_id")
+        if team_id != "":
             team_obj = Team.objects.get(id=team_id)
             git_group_url = team_obj.gitlab_group_url
-            return HttpResponse(json.dumps(git_group_url), content_type="application/text")
+            return HttpResponse(
+                json.dumps(git_group_url), content_type="application/text"
+            )
         return HttpResponse(json.dumps([]), content_type="application/text")
-    except Exception as e:
-        logger.error(f'Ошибка при получении фильтра')
+    except Exception:
+        logger.error("Ошибка при получении фильтра")
+
 
 def set_team_id(request=None):
     try:
-        team_name = request.GET.get('team_name')
-        if team_name != '' and team_name != "Нет":
+        team_name = request.GET.get("team_name")
+        if team_name != "" and team_name != "Нет":
             team_obj = Team.objects.get(name=team_name)
             team_id = team_obj.id
             return HttpResponse(json.dumps(team_id), content_type="application/text")
         return HttpResponse(json.dumps([]), content_type="application/text")
-    except Exception as e:
-        logger.error(f'Ошибка при установке teamid')
+    except Exception:
+        logger.error("Ошибка при установке teamid")
+
 
 def makeAndDownloadMdAndDocx(request, acl_id):
     file_path = None
     acl_obj = ACL.objects.get(id=acl_id)
     local_storage = json.loads(acl_obj.acltext)
-    gitlab_filename = local_storage['acl_create_info.html'][9]
+    gitlab_filename = local_storage["acl_create_info.html"][9]
 
-    file_type = request.GET.get('file_type') or None
+    file_type = request.GET.get("file_type") or None
     try:
         if file_type is not None:
-            logger.info(f'[MAKE FILE] Получен file_type:{file_type}')
-            if file_type == 'docx':
-                logger.info(f'[MAKE FILE] Создание docx файла')
-                acl_project = local_storage['acl_create_info.html'][4]
-                gitlab_repo_url = ACLGitlabStore.objects.get(project=acl_project).gitlab_url
-                file_path = make_doc(request, local_storage, gitlab_repo_url=gitlab_repo_url,
-                                                             gitlab_filename=gitlab_filename)
-                logger.info(f'[MAKE FILE] Файл docx успешно сформирован:{file_path}')
-            elif file_type == 'md':
-                logger.info(f'[MAKE FILE] Создание md файла')
+            logger.info(f"[MAKE FILE] Получен file_type:{file_type}")
+            if file_type == "docx":
+                logger.info("[MAKE FILE] Создание docx файла")
+                acl_project = local_storage["acl_create_info.html"][4]
+                gitlab_repo_url = ACLGitlabStore.objects.get(
+                    project=acl_project
+                ).gitlab_url
+                file_path = make_doc(
+                    request,
+                    local_storage,
+                    gitlab_repo_url=gitlab_repo_url,
+                    gitlab_filename=gitlab_filename,
+                )
+                logger.info(f"[MAKE FILE] Файл docx успешно сформирован:{file_path}")
+            elif file_type == "md":
+                logger.info("[MAKE FILE] Создание md файла")
                 filename_without_extension = os.path.splitext(gitlab_filename)[0]
-                file_path = MakeMarkDown(request, local_storage, filename_without_extension, acl_id)
-                logger.info(f'[MAKE FILE] Файл md успешно сформирован:{file_path}')
+                file_path = MakeMarkDown(
+                    request, local_storage, filename_without_extension, acl_id
+                )
+                logger.info(f"[MAKE FILE] Файл md успешно сформирован:{file_path}")
 
             if file_path is not None:
-                logger.info(f'[MAKE FILE] Путь к файлу получен. Подготовка к скачиванию.')
+                logger.info(
+                    "[MAKE FILE] Путь к файлу получен. Подготовка к скачиванию."
+                )
                 file_name = os.path.basename(file_path)
-                logger.info(f'[MAKE FILE] Получено имя файла:{file_name}')
-                file_md_abs = os.path.join(BASE_DIR, f'static/{file_type}/' + f'{file_name}')
-                if '/' in file_md_abs:
-                    if 'linux' not in sys.platform:
-                        file_md_abs = file_md_abs.replace('/', '\\')
-                logger.info(f'[MAKE FILE] Сформирован абсолютный путь для скачивания:{file_md_abs}')
-
-                file = open(file_md_abs, 'rb')
+                logger.info(f"[MAKE FILE] Получено имя файла:{file_name}")
+                file_md_abs = os.path.join(
+                    BASE_DIR, f"static/{file_type}/" + f"{file_name}"
+                )
+                if "/" in file_md_abs:
+                    if "linux" not in sys.platform:
+                        file_md_abs = file_md_abs.replace("/", "\\")
+                logger.info(
+                    f"[MAKE FILE] Сформирован абсолютный путь для скачивания:{file_md_abs}"
+                )
+
+                file = open(file_md_abs, "rb")
                 file_response = FileResponse(file)
-                file_response['Content-Disposition'] = f'attachment; filename="{file_name}"'
+                file_response["Content-Disposition"] = (
+                    f'attachment; filename="{file_name}"'
+                )
                 return file_response
 
-        logger.error(f'[MAKE FILE] Не удалось сформировать файл. file_type:{file_type}; file_path:{file_path};')
-        return redirect(request.META.get('HTTP_REFERER'))
+        logger.error(
+            f"[MAKE FILE] Не удалось сформировать файл. file_type:{file_type}; file_path:{file_path};"
+        )
+        return redirect(request.META.get("HTTP_REFERER"))
     except Exception as e:
-        logger.error(f'[MAKE FILE] Exception: Не удалось сформировать файл. file_type:{file_type}; file_path:{file_path}; Ошибка:{e};')
-        return redirect(request.META.get('HTTP_REFERER'))
-
-
-def require_access_token(view_func):
-    @wraps(view_func)
-    def _wrapped_view(request, *args, **kwargs):
-        auth_header = request.META.get('HTTP_AUTHORIZATION')
-        if not auth_header:
-            return HttpResponse('Access token required', status=401)
-        if 'Bearer' in auth_header:
-            auth_header = auth_header.split()[1]
-        try:
-            access_token = AccessToken.objects.get(token=auth_header)
-            if not access_token.is_active:
-                return HttpResponse('Access token is inactive', status=401)
-        except AccessToken.DoesNotExist:
-            return HttpResponse('Invalid access token', status=401)
-        return view_func(request, *args, **kwargs)
-    return _wrapped_view
+        logger.error(
+            f"[MAKE FILE] Exception: Не удалось сформировать файл. file_type:{file_type}; file_path:{file_path}; Ошибка:{e};"
+        )
+        return redirect(request.META.get("HTTP_REFERER"))
 
 
 class APIACLInfoView(APIView):
-    @method_decorator(require_access_token)
+    permission_classes = [HasAPIKey | IsAdminUser]
+
+    class InputSerializer(serializers.Serializer):
+        ip_source = serializers.IPAddressField(protocol="IPv4", required=True)
+        ip_destination = serializers.IPAddressField(protocol="IPv4", required=True)
+        port = serializers.CharField(required=True)
+
+    class OutputSerializer(serializers.Serializer):
+        ip_source = serializers.IPAddressField(protocol="IPv4", required=True)
+        ip_destination = serializers.IPAddressField(protocol="IPv4", required=True)
+        port = serializers.CharField(required=True)
+        result = serializers.BooleanField(required=True)
+
+    @swagger_auto_schema(
+        operation_description="Получение ACL по IP",
+        request_body=InputSerializer,
+        responses={
+            200: OutputSerializer,
+            400: "Bad Request",
+        },
+        tags=["api/get_acl_by_ip/"],
+    )
     def post(self, request):
+        data = self.InputSerializer(data=request.data)
+        data.is_valid(raise_exception=True)
+        serializer = data.validated_data
+
         result = False
-        ip_source = request.data.get('ip_source')
-        ip_destination = request.data.get('ip_destination')
-        port = request.data.get('port').replace(" ", "")
+        ip_source = serializer.get("ip_source")
+        ip_destination = serializer.get("ip_destination")
+        port = serializer.get("port").replace(" ", "")
 
         if ip_source and ip_destination and port:
-            queryset = ACL.objects.values_list('id', 'acltext', 'taskid').exclude(taskid='')
+            queryset = ACL.objects.values_list("id", "acltext", "taskid").exclude(
+                taskid=""
+            )
             for acl in queryset:
                 acltext_dict = json.loads(acl[1])
-                if 'acl_traffic.html' in acltext_dict:
-                    for item in acltext_dict['acl_traffic.html']:
+                if "acl_traffic.html" in acltext_dict:
+                    for item in acltext_dict["acl_traffic.html"]:
                         if ip_source in item[1] and ip_destination in item[3]:
-                            row_port = item[4].split('/')[1].replace(" ", "")
-                            if re.match(r'^\d+$', row_port):
+                            row_port = item[4].split("/")[1].replace(" ", "")
+                            if re.match(r"^\d+$", row_port):
                                 if row_port == port:
                                     result = True
-                            elif re.match(r'^\d+-\d+$', row_port):
-                                start_num, end_num = row_port.split('-')
+                            elif re.match(r"^\d+-\d+$", row_port):
+                                start_num, end_num = row_port.split("-")
                                 if int(start_num) <= int(port) <= int(end_num):
                                     result = True
                             else:
-                                row_port_list = row_port.split(',')
+                                row_port_list = row_port.split(",")
                                 for row_port_el in row_port_list:
-                                    if re.match(r'^\d+$', row_port_el):
+                                    if re.match(r"^\d+$", row_port_el):
                                         if row_port_el == port:
                                             result = True
                                             break
-                                    elif re.match(r'^\d+-\d+$', row_port_el):
-                                        start_num, end_num = row_port_el.split('-')
+                                    elif re.match(r"^\d+-\d+$", row_port_el):
+                                        start_num, end_num = row_port_el.split("-")
                                         if int(start_num) <= int(port) <= int(end_num):
                                             result = True
                                             break
                     if result:
                         break
-        return JsonResponse({"ip_source": ip_source, 'ip_destination': ip_destination, 'port': port, 'result': result})
-    
\ No newline at end of file
+
+        response = self.OutputSerializer(
+            {
+                "ip_source": ip_source,
+                "ip_destination": ip_destination,
+                "port": port,
+                "result": result,
+            }
+        ).data
+        return Response(data=response, status=status.HTTP_200_OK)
\ No newline at end of file


==== File: acladmin/celery.py ====
@@ -1,16 +1,11 @@
 import os
-from celery import Celery
 
+from celery import Celery
 
-os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'acladmin.settings')
+os.environ.setdefault("DJANGO_SETTINGS_MODULE", "acladmin.settings")
 
-app = Celery('acladmin')
-app.config_from_object('django.conf:settings', namespace='CELERY')
+app = Celery("acladmin")
+app.config_from_object("django.conf:settings", namespace="CELERY")
 app.autodiscover_tasks()
 
-app.conf.beat_schedule = {
-    "deactivate-expired-tokens": {
-            "task": "accesslist.tasks.deactivate_expired_tokens",
-            "schedule": 300,     # 5 min
-        },
-}
\ No newline at end of file
+app.conf.beat_schedule = {}


==== File: acladmin/context_processors.py ====
@@ -0,0 +1,5 @@
+from django.conf import settings
+
+
+def commit_tag(request):
+    return {"commit_tag": settings.COMMIT_TAG}


==== File: acladmin/settings.py ====
@@ -9,9 +9,9 @@ https://docs.djangoproject.com/en/3.1/topics/settings/
 For the full list of settings and their values, see
 https://docs.djangoproject.com/en/3.1/ref/settings/
 """
-import base64
-from pathlib import Path
+
 import os
+from pathlib import Path
 
 import dotenv
 
@@ -22,87 +22,93 @@ dotenv_file = os.path.join(BASE_DIR, ".env")
 if os.path.isfile(dotenv_file):
     dotenv.load_dotenv(dotenv_file)
 
-SECRET_KEY =  os.environ['SECRET_KEY']
+SECRET_KEY = os.environ["SECRET_KEY"]
 #    '#8g9jc-u$r!z83lc1bi!e+wif&n^u+*0yy3otebb19lbu)2@dy'
 
 # SECURITY WARNING: don't run with debug turned on in production!
 DEBUG = True
 
-APPROVE = 'APPROVE_PERSON'
+APPROVE = "APPROVE_PERSON"
 
-ALLOWED_HOSTS = ['*']
+ALLOWED_HOSTS = ["*"]
 SESSION_SAVE_EVERY_REQUEST = True
 
 # Application definition
 
 INSTALLED_APPS = [
-    'django.contrib.auth',
-    'django.contrib.contenttypes',
-    'django.contrib.sessions',
-    'django.contrib.messages',
-    'django.contrib.staticfiles',
-    'fontawesome-free',
-    'ownerlist',
-    'accesslist',
-    'acladmin',
-    'django_python3_ldap',
-    'django.contrib.admin',
-    'panel',
-    'teams'
+    "django.contrib.auth",
+    "django.contrib.contenttypes",
+    "django.contrib.sessions",
+    "django.contrib.messages",
+    "django.contrib.staticfiles",
+    "fontawesome-free",
+    "ownerlist",
+    "accesslist",
+    "acladmin",
+    "django_python3_ldap",
+    "django.contrib.admin",
+    "panel",
+    "teams",
+    "django_celery_beat",
+    "rest_framework",
+    "rest_framework_api_key",
+    "drf_yasg",
+    "corsheaders",
 ]
 
 MIDDLEWARE = [
-    'django.middleware.security.SecurityMiddleware',
-    'django.contrib.sessions.middleware.SessionMiddleware',
-    'django.middleware.common.CommonMiddleware',
-    'django.middleware.csrf.CsrfViewMiddleware',
-    'django.contrib.auth.middleware.AuthenticationMiddleware',
-    'django.contrib.messages.middleware.MessageMiddleware',
-    'django.middleware.clickjacking.XFrameOptionsMiddleware',
+    "django.middleware.security.SecurityMiddleware",
+    "django.contrib.sessions.middleware.SessionMiddleware",
+    "corsheaders.middleware.CorsMiddleware",
+    "django.middleware.common.CommonMiddleware",
+    "django.middleware.csrf.CsrfViewMiddleware",
+    "django.contrib.auth.middleware.AuthenticationMiddleware",
+    "django.contrib.messages.middleware.MessageMiddleware",
+    "django.middleware.clickjacking.XFrameOptionsMiddleware",
 ]
 
-ROOT_URLCONF = 'acladmin.urls'
+ROOT_URLCONF = "acladmin.urls"
 
 TEMPLATES = [
     {
-        'BACKEND': 'django.template.backends.django.DjangoTemplates',
-        'DIRS': [
-            os.path.join(BASE_DIR, 'templates'),
-        ]
-        ,
-        'APP_DIRS': True,
-        'OPTIONS': {
-            'context_processors': [
-                'django.template.context_processors.debug',
-                'django.template.context_processors.request',
-                'django.contrib.auth.context_processors.auth',
-                'django.contrib.messages.context_processors.messages',
+        "BACKEND": "django.template.backends.django.DjangoTemplates",
+        "DIRS": [
+            os.path.join(BASE_DIR, "templates"),
+        ],
+        "APP_DIRS": True,
+        "OPTIONS": {
+            "context_processors": [
+                "django.template.context_processors.debug",
+                "django.template.context_processors.request",
+                "django.contrib.auth.context_processors.auth",
+                "django.contrib.messages.context_processors.messages",
+                "acladmin.context_processors.commit_tag",
             ],
-            'libraries':  {
-                'check_ip': 'accesslist.templatetags.ip_check',
-                'get_index': 'accesslist.templatetags.get_index',
-            }
+            "libraries": {
+                "check_ip": "accesslist.templatetags.ip_check",
+                "get_index": "accesslist.templatetags.get_index",
+            },
         },
     },
 ]
 
-WSGI_APPLICATION = 'acladmin.wsgi.application'
+WSGI_APPLICATION = "acladmin.wsgi.application"
 
 
 # Database
 # https://docs.djangoproject.com/en/3.1/ref/settings/#databases
 
-DB_USER =  os.environ['DB_USER']
-DB_USER_PASSWORD = os.environ['DB_USER_PASSWORD']
+DB_USER = os.environ["DB_USER"]
+DB_USER_PASSWORD = os.environ["DB_USER_PASSWORD"]
 
 DATABASES = {
-    'default': {
-        'ENGINE': 'django.db.backends.postgresql_psycopg2',
-        'NAME': 'acl',
-        'USER': DB_USER,
-        'PASSWORD': DB_USER_PASSWORD,
-        'HOST': '127.0.0.1',
-        'PORT': '5432',
+    "default": {
+        "ENGINE": "django.db.backends.postgresql_psycopg2",
+        "NAME": "acl",
+        "USER": DB_USER,
+        "PASSWORD": DB_USER_PASSWORD,
+        "HOST": "127.0.0.1",
+        "PORT": "5432",
     }
 }
 
@@ -111,16 +117,16 @@ DATABASES = {
 
 AUTH_PASSWORD_VALIDATORS = [
     {
-        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
+        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
+        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
+        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
     },
     {
-        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
+        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
     },
 ]
 
@@ -128,9 +134,9 @@ AUTH_PASSWORD_VALIDATORS = [
 # Internationalization
 # https://docs.djangoproject.com/en/3.1/topics/i18n/
 
-LANGUAGE_CODE = 'en-us'
+LANGUAGE_CODE = "en-us"
 
-TIME_ZONE = 'Europe/Moscow'
+TIME_ZONE = "Europe/Moscow"
 
 USE_I18N = True
 
@@ -142,64 +148,59 @@ USE_TZ = True
 # Static files (CSS, JavaScript, Images)
 # https://docs.djangoproject.com/en/3.1/howto/static-files/
 
-STATIC_URL = '/static/'
-#STATIC_ROOT = os.path.join(BASE_DIR, 'static')
+STATIC_URL = "/static/"
+# STATIC_ROOT = os.path.join(BASE_DIR, 'static')
 
 STATICFILES_DIRS = [
-    os.path.join(BASE_DIR, 'static'),
+    os.path.join(BASE_DIR, "static"),
 ]
 
-if os.name == 'nt':
-    LOGPATH = os.path.join(BASE_DIR, 'log\\debug.log')
+if os.name == "nt":
+    LOGPATH = os.path.join(BASE_DIR, "log\\debug.log")
 else:
-    LOGPATH = os.path.join(BASE_DIR, 'log//debug.log')
+    LOGPATH = os.path.join(BASE_DIR, "log//debug.log")
 
 LOGGING = {
-    'version': 1,
-    'disable_existing_loggers': False,
-    'formatters':
-        {
-            'file': {
-                'format': '%(levelname)s|%(asctime)s|%(module)s|%(process)d|%(filename)s|%(lineno)d|%(message)s',
-                'datefmt': '%d/%b/%Y %H:%M:%S'
-                    }
-         },
-
-    'handlers': {
-        'file': {
-                'level': 'DEBUG', #WARNING
-                'class': 'logging.handlers.RotatingFileHandler',
-                'filename': LOGPATH,
-                'maxBytes': 1024*1024*5, # 5MB
-                'backupCount': 0,
-                'formatter': 'file',
+    "version": 1,
+    "disable_existing_loggers": False,
+    "formatters": {
+        "file": {
+            "format": "%(levelname)s|%(asctime)s|%(module)s|%(process)d|%(filename)s|%(lineno)d|%(message)s",
+            "datefmt": "%d/%b/%Y %H:%M:%S",
+        }
+    },
+    "handlers": {
+        "file": {
+            "level": "DEBUG",  # WARNING
+            "class": "logging.handlers.RotatingFileHandler",
+            "filename": LOGPATH,
+            "maxBytes": 1024 * 1024 * 5,  # 5MB
+            "backupCount": 0,
+            "formatter": "file",
         },
         "console": {
             "class": "logging.StreamHandler",
         },
     },
-
-    'loggers': {
-        '': {
-            'handlers': ['file'],
-            'level': 'DEBUG', #WARNING
-            'propagate': True,
+    "loggers": {
+        "": {
+            "handlers": ["file"],
+            "level": "DEBUG",  # WARNING
+            "propagate": True,
         },
-
         "django_python3_ldap": {
             "handlers": ["file"],
             "level": "DEBUG",
         },
-
         "git": {
             "handlers": ["file"],
-            "level": "WARNING", #DEBUG #WARNING
+            "level": "WARNING",  # DEBUG #WARNING
         },
     },
 }
 
 
-LOGIN_REDIRECT_URL = '/acl/welcome/'
+LOGIN_REDIRECT_URL = "/acl/welcome/"
 
 AUTHENTICATION_BACKENDS = (
     "accesslist.auth.MyAuthBackend",
@@ -207,8 +208,8 @@ AUTHENTICATION_BACKENDS = (
     "django_python3_ldap.auth.LDAPBackend",
 )
 
-LDAP_AUTH_URL = os.environ['LDAP_AUTH_URL']
-LDAP_AUTH_SEARCH_BASE = os.environ['LDAP_AUTH_SEARCH_BASE']
+LDAP_AUTH_URL = os.environ["LDAP_AUTH_URL"]
+LDAP_AUTH_SEARCH_BASE = os.environ["LDAP_AUTH_SEARCH_BASE"]
 
 LDAP_AUTH_USE_TLS = True
 LDAP_AUTH_OBJECT_CLASS = "organizationalPerson"
@@ -226,41 +227,45 @@ LDAP_AUTH_USER_LOOKUP_FIELDS = ("username",)
 LDAP_AUTH_CLEAN_USER_DATA = "django_python3_ldap.utils.clean_user_data"
 LDAP_AUTH_SYNC_USER_RELATIONS = "django_python3_ldap.utils.sync_user_relations"
 LDAP_AUTH_FORMAT_SEARCH_FILTERS = "django_python3_ldap.utils.format_search_filters"
-LDAP_AUTH_FORMAT_USERNAME = "django_python3_ldap.utils.format_username_active_directory_principal"
+LDAP_AUTH_FORMAT_USERNAME = (
+    "django_python3_ldap.utils.format_username_active_directory_principal"
+)
 
-LDAP_AUTH_URL = os.environ['LDAP_AUTH_URL']
-LDAP_AUTH_SEARCH_BASE = os.environ['LDAP_AUTH_SEARCH_BASE']
-LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN = os.environ['LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN']
-LDAP_AUTH_CONNECTION_USERNAME = os.environ['LDAP_AUTH_CONNECTION_USERNAME']
-LDAP_AUTH_CONNECTION_PASSWORD = os.environ['LDAP_AUTH_CONNECTION_PASSWORD']
-LDAP_AUTH_CONNECTION_DOMAIN =os.environ['LDAP_AUTH_CONNECTION_DOMAIN']
+LDAP_AUTH_URL = os.environ["LDAP_AUTH_URL"]
+LDAP_AUTH_SEARCH_BASE = os.environ["LDAP_AUTH_SEARCH_BASE"]
+LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN = os.environ["LDAP_AUTH_ACTIVE_DIRECTORY_DOMAIN"]
+LDAP_AUTH_CONNECTION_USERNAME = os.environ["LDAP_AUTH_CONNECTION_USERNAME"]
+LDAP_AUTH_CONNECTION_PASSWORD = os.environ["LDAP_AUTH_CONNECTION_PASSWORD"]
+LDAP_AUTH_CONNECTION_DOMAIN = os.environ["LDAP_AUTH_CONNECTION_DOMAIN"]
 
-GITLAB_AUTH_USERNAME = os.environ['GITLAB_AUTH_USERNAME']
-GITLAB_AUTH_PASSWORD = os.environ['GITLAB_AUTH_PASSWORD']
+GITLAB_AUTH_USERNAME = os.environ["GITLAB_AUTH_USERNAME"]
+GITLAB_AUTH_PASSWORD = os.environ["GITLAB_AUTH_PASSWORD"]
 
-EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
-EMAIL_ADMIN = 'ragulinma@alfastrah.ru'
-EMAIL_SD = os.environ['EMAIL_SD']
+EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
+EMAIL_ADMIN = "ragulinma@alfastrah.ru"
+EMAIL_SD = os.environ["EMAIL_SD"]
 
 EMAIL_USE_TLS = False
-EMAIL_HOST = os.environ['EMAIL_HOST']
-EMAIL_PORT =os.environ['EMAIL_PORT']
-EMAIL_HOST_USER = os.environ['EMAIL_HOST_USER']
-EMAIL_HOST_PASSWORD = os.environ['EMAIL_HOST_PASSWORD']
+EMAIL_HOST = os.environ["EMAIL_HOST"]
+EMAIL_PORT = os.environ["EMAIL_PORT"]
+EMAIL_HOST_USER = os.environ["EMAIL_HOST_USER"]
+EMAIL_HOST_PASSWORD = os.environ["EMAIL_HOST_PASSWORD"]
 
-GIT_ACCESS_TOKEN = os.environ['GIT_ACCESS_TOKEN']
+GIT_ACCESS_TOKEN = os.environ["GIT_ACCESS_TOKEN"]
 
-MATTERMOST_WEBHOOK_URL = 'https://mattermost.alfastrah.ru/hooks/naht8rbp4fdwpf43pbsyatanka'
+MATTERMOST_WEBHOOK_URL = (
+    "https://mattermost.alfastrah.ru/hooks/naht8rbp4fdwpf43pbsyatanka"
+)
 
 OMNITRACKER_URL = "http://ot10.vesta.ru/otws/v1.asmx"
 TIMEOUT = 120
 ATTEMPS = 3
-JS_TIMEOUT = 3000 #msec
+JS_TIMEOUT = 3000  # msec
 
 MAKE_TASK_AFTER_APRROVE = True
 
 DATA_UPLOAD_MAX_NUMBER_FIELDS = 10000
-
+COMMIT_TAG = os.environ.get("COMMIT_TAG", "1.0.0")
 CELERY_ACCEPT_CONTENT = ["application/json"]
 CELERY_TASK_SERIALIZER = "json"
 CELERY_RESULT_SERIALIZER = "json"
@@ -268,4 +273,15 @@ CELERY_RESULT_SERIALIZER = "json"
 CELERY_TIMEZONE = "Europe/Moscow"
 CELERY_TASK_TRACK_STARTED = True
 # Таймаут 10 мин на задачу
-CELERY_TASK_TIME_LIMIT = 10 * 60
\ No newline at end of file
+CELERY_TASK_TIME_LIMIT = 10 * 60
+
+CORS_ALLOW_ALL_ORIGINS = True
+REST_FRAMEWORK = {
+    "DEFAULT_AUTHENTICATION_CLASSES": [
+        "rest_framework.authentication.SessionAuthentication",
+        "rest_framework.authentication.BasicAuthentication",
+    ],
+    "DEFAULT_PERMISSION_CLASSES": [
+        "rest_framework.permissions.IsAuthenticated",
+    ],
+}


==== File: acladmin/urls.py ====
@@ -1,46 +1,37 @@
-"""acladmin URL Configuration
+from os.path import join
 
-The `urlpatterns` list routes URLs to views. For more information please see:
-    https://docs.djangoproject.com/en/3.1/topics/http/urls/
-Examples:
-Function views
-    1. Add an import:  from my_app import views
-    2. Add a URL to urlpatterns:  path('', views.home, name='home')
-Class-based views
-    1. Add an import:  from other_app.views import Home
-    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
-Including another URLconf
-    1. Import the include() function: from django.urls import include, path
-    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
-"""
+from django.conf import settings
 from django.contrib import admin
+from django.contrib.staticfiles.urls import staticfiles_urlpatterns
 from django.urls import include, path, re_path
-from django.conf import settings
-from .views import login
 from django.views.static import serve
-from os.path import join
 
-from django.contrib.staticfiles.urls import staticfiles_urlpatterns
+from .views import login
+from .yasg import doc_urls
 
 urlpatterns = [
-    path('admin/', admin.site.urls),
-    path('acl/', include('accesslist.urls')),
-    path('login/', login.as_view(), name="login_urls"),
-    path('accounts/', include('django.contrib.auth.urls'), name='login'),
-    path('panel/', include('panel.urls')),
-    path('teams/', include('teams.urls')),
-    path('', include('ownerlist.urls')),
+    path("admin/", admin.site.urls),
+    path("acl/", include("accesslist.urls")),
+    path("login/", login.as_view(), name="login_urls"),
+    path("accounts/", include("django.contrib.auth.urls"), name="login"),
+    path("panel/", include("panel.urls")),
+    path("teams/", include("teams.urls")),
+    path("", include("ownerlist.urls")),
 ]
 
 if settings.DEBUG:
     urlpatterns += [
-        re_path(r'^static/(?P<path>.*)$', serve, {
-            'document_root': join(settings.BASE_DIR, 'static'),
-        }),
-    ]
+        re_path(
+            r"^static/(?P<path>.*)$",
+            serve,
+            {
+                "document_root": join(settings.BASE_DIR, "static"),
+            },
+        ),
+    ] + doc_urls
 
     urlpatterns += staticfiles_urlpatterns()
 
-handler500 = 'acladmin.views.handler500'
-handler404 = 'acladmin.views.handler404'
-handler403 = 'acladmin.views.handler403'
\ No newline at end of file
+handler500 = "acladmin.views.handler500"
+handler404 = "acladmin.views.handler404"
+handler403 = "acladmin.views.handler403"


==== File: acladmin/yasg.py ====
@@ -0,0 +1,34 @@
+from django.urls import re_path
+from drf_yasg import openapi
+from drf_yasg.views import get_schema_view
+from rest_framework.permissions import AllowAny
+
+schema_view = get_schema_view(
+    openapi.Info(
+        title="ACL API",
+        default_version="v1",
+        description="Acl Alfastrah",
+        license=openapi.License(name="BSD License"),
+    ),
+    public=False,
+    permission_classes=(AllowAny,),
+)
+
+
+doc_urls = [
+    re_path(
+        r"^swagger(?P<format>\.json|\.yaml)$",
+        schema_view.without_ui(cache_timeout=0),
+        name="schema-json",
+    ),
+    re_path(
+        r"^swagger/$",
+        schema_view.with_ui("redoc", cache_timeout=0),
+        name="schema-redoc",
+    ),
+    re_path(
+        r"^swagger-old/$",
+        schema_view.with_ui("swagger", cache_timeout=0),
+        name="schema-swagger-ui",
+    ),
+]


==== File: ownerlist/utils.py ====
@@ -2545,12 +2545,8 @@ def SendMessageToApprove(acl_id, acl_owner, user, token=""):
         "https://acl.vesta.ru/acl/pending/{}/?token={}".format(acl_id, token),
     )
 
-    e = EmailMessage(
-        subject="Согласование обращения" + str(user.username),
-        body=EMAIL_APPROVE,
-        from_email="acl@alfastrah.ru",
-        to=[user.email],
-    )
+    e = EmailMessage(subject='Согласование обращения '+str(user.username), body=EMAIL_APPROVE, from_email='acl@alfastrah.ru',
+                     to=[user.email])
     e.content_subtype = "html"
     e.send(fail_silently=settings.DEBUG)
     if settings.DEBUG:


==== File: requirements.txt ====
Binary files a/requirements.txt and b/requirements.txt differ


==== File: teams/migrations/0005_team_gitlab_group_url.py ====
@@ -0,0 +1,18 @@
+# Generated by Django 3.1.6 on 2023-11-27 07:26
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('teams', '0004_auto_20221109_1618'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='team',
+            name='gitlab_group_url',
+            field=models.URLField(blank=True),
+        ),
+    ]


==== File: templates/base.html ====
@@ -58,6 +58,9 @@
 
       </div>
    </div>
+   <div class="col-2 d-flex justify-content-end align-items-center">
+    <h6 class="mb-0 text-white ml-auto">version: {{ commit_tag }}</h6>
+  </div>
     <script type="text/javascript">
     $("form[name='search-text']").on("submit", function(e){
             $(".search-spinner").hide();


