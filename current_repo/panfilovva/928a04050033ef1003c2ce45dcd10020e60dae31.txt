==== File: accesslist/admin.py ====
@@ -1,13 +1,14 @@
 from django.contrib import admin
 from .models import ACL, ACLGitlabStore
-# Register your models here.
 
+
+@admin.register(ACL)
 class ACLAdmin(admin.ModelAdmin):
     list_display = ('project', 'status', 'owner', 'id', 'taskid', 'created')
     list_filter = ('status', 'created')
+    list_display_links = list_display
+
 
+@admin.register(ACLGitlabStore)
 class ACLGitlabStoreAdmin(admin.ModelAdmin):
     list_display = ('project', 'gitlab_url')
-
-admin.site.register(ACL,ACLAdmin)
-admin.site.register(ACLGitlabStore, ACLGitlabStoreAdmin)
\ No newline at end of file


==== File: accesslist/models.py ====
@@ -1,11 +1,11 @@
 from django.db import models
 from django.db.models.signals import pre_save
 from django.dispatch import receiver
-from ownerlist.models import Owners
-from django.contrib.auth.models import User, Group
+from django.contrib.auth.models import User
 from ownerlist.utils import MakeTemporaryToken
 from datetime import datetime, timezone
-from teams.models import Team, Block
+from teams.models import Team
+from uuid import uuid4
 
 
 class ACL(models.Model):


==== File: accesslist/templates/acl_traffic.html ====
@@ -72,7 +72,7 @@
 <form class="form-inline" method="post" action="{{ request.path }}" name="acl-form-internal" class="acl-form-internal">
     {% csrf_token %}
         <div class="form-row">
-            <table class="table table-md table-ip-internal" border="0">
+            <table class="table table-md table-ip-internal">
                 <thead>
                      <tr>
                          <th>Имя хоста (Источник)</th>
@@ -82,8 +82,7 @@
                          <th>Протокол/Порт (Назначение)*</th>
                          <th>ПО использующее нестандартный порт</th>
                          <th>Описание (цель)</th>
-                         <th></th>
-                         <th></th>
+                         <th>Резервирование</th>
                          <th></th>
                      </tr>
 
@@ -101,10 +100,14 @@
                                             <input type="text" class="form-control" value="{{item|get_index:forloop.counter0}}" name="{{widget}}_{% random_int %}" {% if widget == "input__host_port" %} pattern="^[a-zA-Z]+/+(?:\d+|\d+-\d+)(?:,\s*(?:\d+|\d+-\d+))*$" placeholder="UDP/100-200" title="UDP/100-200" {% else %} pattern="^(any|((\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(/\d{1,2})?)$" title="1.1.1.1" {% endif %} autofocus required>
                                         {% else %}
                                             {% if "input__domain_source" in widget or "input__domain_dest" in widget %}
-                                                <textarea type="text" class="form-control {{widget}}_textarea" rows="1" cols="19" name="{{widget}}_{% random_int %}" autofocus required>{{item|get_index:forloop.counter0}}</textarea>
-                                                <select class="{{widget}}_select form-control custom_domain_select" style="width:200px;">
+                                            <div class="form-group">  
+                                              <textarea type="text" class="form-control {{widget}}_textarea" rows="1" cols="19" name="{{widget}}_{% random_int %}" autofocus required>{{item|get_index:forloop.counter0}}</textarea>
+                                            </div>
+                                            <div class="form-group">   
+                                              <select class="{{widget}}_select form-control custom_domain_select" style="width:200px;">
                                                     <option value="" selected>Выбрать Хост</option>
                                                 </select>
+                                            </div>
                                             {% else %}
                                                 <textarea type="text" class="form-control" rows="1" cols="19" name="{{widget}}_{% random_int %}" {% if widget == "input__application_port" %} title="grpc, kafka, sqlServer" maxlength="50" {% endif %} autofocus required>{{item|get_index:forloop.counter0}}</textarea>
                                             {% endif %}
@@ -129,10 +132,14 @@
                                             <input type="text" class="form-control" value="{{item|get_index:forloop.counter0}}" name="{{widget}}_{% random_int %}" {% if widget == "input__ip_source" or widget == "input__ip__external" %} pattern="^(any|((\d{1,2}|1\d\d|2[0-4]\d|25[0-5]).){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(/\d{1,2})?)$" {% endif %} {% if widget == "input__host_port" %} pattern="^[a-zA-Z]+/+(?:\d+|\d+-\d+)(?:,\s*(?:\d+|\d+-\d+))*$" placeholder="UDP/100-200" title="UDP/100-200"{% endif %} autofocus required>
                                      {% else %}
                                             {% if "input__domain_source" in widget or "input__domain_dest" in widget %}
-                                                <textarea type="text" class="form-control {{widget}}_textarea" rows="1" cols="19" name="{{widget}}_{% random_int %}" autofocus required>{{item|get_index:forloop.counter0}}</textarea>
-                                                <select class="{{widget}}_select form-control custom_domain_select" style="width:200px;">
+                                            <div class="form-group">
+                                              <textarea type="text" class="form-control {{widget}}_textarea" rows="1" cols="19" name="{{widget}}_{% random_int %}" autofocus required>{{item|get_index:forloop.counter0}}</textarea>
+                                            </div>
+                                            <div class="form-group">
+                                              <select class="{{widget}}_select form-control custom_domain_select" style="width:200px;">
                                                     <option value="" selected>Выбрать Хост</option>
                                                 </select>
+                                            </div>
                                             {% else %}
                                                 <textarea type="text" class="form-control" rows="1" cols="19" name="{{widget}}_{% random_int %}" {% if widget == "input__application_port" %} title="grpc, kafka, sqlServer" maxlength="50" {% endif %} autofocus required>{{item|get_index:forloop.counter0}}</textarea>
                                             {% endif %}
@@ -259,6 +266,12 @@
             const selectedTextarea = $(tr).find(textareaSelector);
             const selectedOption = event.target.options[event.target.selectedIndex];
             selectedTextarea.val(selectedOption.text);
+
+            const ipInput = $(tr).find('input[name^="input__ip_source_"]');
+            if (ipInput.length) {
+              ipInput.val('');
+              selectedTextarea.trigger('change.resolve');
+            }
           }
         }
 


==== File: accesslist/views.py ====
@@ -38,7 +38,6 @@ from time import sleep
 from django.db import transaction
 import threading
 
-from rest_framework.response import Response
 from rest_framework.views import APIView
 
 
@@ -490,17 +489,20 @@ def save__form(request, owner_form: None, acl_id)->None:
     if owner_form is None:
         logger.error("[save__form] owner_form is None")
         return
+    
     if owner_form[1] != request.user.email:
         email = request.user.email
     else:
         email = owner_form[1]
-    user, created = Owners.objects.get_or_create(email=email)
-    if created:
-        user.username = owner_form[0]
-        user.phone = owner_form[2]
-        user.active = True
-        user.department = owner_form[3]
-        user.save()
+    
+
+    user = Owners.objects.filter(email=email).first()
+    if not user:
+        user = Owners.objects.create(email=email,
+                                     username=owner_form[0],
+                                     phone = owner_form[2],
+                                     active = True,
+                                     department = owner_form[3])
     try:
         ip, created_ip = Iplist.objects.get_or_create(ipv4=get_client_ip(request))
         ip.owner = user


==== File: ownerlist/utils.py ====
@@ -1,97 +1,152 @@
-import os, shutil, sys
-import urllib
-from pathlib import Path, PurePosixPath
-import docx.opc.constants
-from django.core.files.storage import FileSystemStorage
-from django.apps import apps
-from django.contrib import messages
-import re
-from django.conf import settings
-from django.db.utils import IntegrityError, DataError
-import requests
-import time
-import uuid
+import base64
+import codecs
+import datetime
+import hashlib
 import ipaddress
-from django.views import View
-from django.http import JsonResponse, HttpResponseRedirect
 import logging
-import xlrd
-import tempfile
-from django.shortcuts import reverse, redirect
-from docx import Document, opc
-from docx.enum.text import WD_COLOR_INDEX
-from docx.shared import RGBColor
-from docx.shared import Pt
+import os
+import random
+import re
+import shutil
 import socket
-import codecs
-import json
+import sys
+import tempfile
+import time
+import urllib
+import uuid
+from inspect import stack
+from itertools import chain
+from pathlib import Path
+from shutil import copyfile
 from time import sleep
+
 import git
-from shutil import copyfile
+import requests
+import xlrd
+from django.apps import apps
+from django.conf import settings
+from django.contrib import messages
 from django.core.cache import cache
-import random, hashlib, datetime
-from inspect import stack
+from django.core.files.storage import FileSystemStorage
+from django.core.mail import EmailMessage
 from django.db.models.expressions import RawSQL
-from itertools import chain
-from django.core.mail import EmailMessage, send_mail
-import base64
+from django.db.utils import DataError, IntegrityError
+from django.http import HttpResponseRedirect, JsonResponse
+from django.shortcuts import reverse
+from django.views import View
+from docx import Document, opc
+from docx.enum.text import WD_COLOR_INDEX
+from docx.shared import Pt
 
-#from accesslist.models import ACL
 try:
     from requests_ntlm import HttpNtlmAuth
 except ImportError:
-    logging.error('Error load requests_ntlm, run pip install requests_ntlm')
+    logging.error("Error load requests_ntlm, run pip install requests_ntlm")
 
-COMMIT_MESSAGE = '[ACL PORTAL] Update file:'
+COMMIT_MESSAGE = "[ACL PORTAL] Update file:"
 FUN_SPEED = 0
 BASE_DIR = Path(__file__).resolve().parent.parent
 LOCAL_UID = None
 
-FORM_APPLICATION_KEYS = ['acl_create_info.html', 'acl_internal_resources.html', 'acl_dmz_resources.html', 'acl_external_resources.html', 'acl_traffic.html', 'acl_approve.html']
-FORM_URLS = ["acldemo_urls", "aclcreate_urls", "aclinternal_urls", "acldmz_urls", "aclexternal_urls", "acltraffic_urls", "acloverview_urls", 'acl_approve_urls', "acl_pending_urls"]
-POST_FORM_KEYS = ['name', 'email', 'tel', 'department', 'project', 'link', 'd_form', 'd_start', 'd_complate', 'acl_filename']
-POST_FORM_EMPTY = ['on', '', None]
-JSON_DUMPS_PARAMS = {
-    'ensure_ascii': False
-}
-left_rule = {'<': ':', '^': ':', '>': '-'}
-right_rule = {'<': '-', '^': ':', '>': ':'}
+FORM_APPLICATION_KEYS = [
+    "acl_create_info.html",
+    "acl_internal_resources.html",
+    "acl_dmz_resources.html",
+    "acl_external_resources.html",
+    "acl_traffic.html",
+    "acl_approve.html",
+]
+FORM_URLS = [
+    "acldemo_urls",
+    "aclcreate_urls",
+    "aclinternal_urls",
+    "acldmz_urls",
+    "aclexternal_urls",
+    "acltraffic_urls",
+    "acloverview_urls",
+    "acl_approve_urls",
+    "acl_pending_urls",
+]
+POST_FORM_KEYS = [
+    "name",
+    "email",
+    "tel",
+    "department",
+    "project",
+    "link",
+    "d_form",
+    "d_start",
+    "d_complate",
+    "acl_filename",
+]
+POST_FORM_EMPTY = ["on", "", None]
+JSON_DUMPS_PARAMS = {"ensure_ascii": False}
+left_rule = {"<": ":", "^": ":", ">": "-"}
+right_rule = {"<": "-", "^": ":", ">": ":"}
 
 contact_column = ["Параметр", "Значение"]
-contact_table = ["ФИО", "E-mail", "Телефон", "Отдел/Управление", "Информационная система", "Описание/архитектура проекта", "Дата заполнения", "Дата ввода в эксплуатацию", "Дата вывода из эксплуатации", "Имя файла ACL в gitlab"]
-external_column = ["IP-адрес", "Полное доменное имя источника", "Маска подсети/Префикс", "Описание"]
+contact_table = [
+    "ФИО",
+    "E-mail",
+    "Телефон",
+    "Отдел/Управление",
+    "Информационная система",
+    "Описание/архитектура проекта",
+    "Дата заполнения",
+    "Дата ввода в эксплуатацию",
+    "Дата вывода из эксплуатации",
+    "Имя файла ACL в gitlab",
+]
+external_column = [
+    "IP-адрес",
+    "Полное доменное имя источника",
+    "Маска подсети/Префикс",
+    "Описание",
+]
 standart_column = ["IP-адрес", "Маска подсети/Префикс", "Описание"]
-traffic_column = ["Hostname (Источник)", "IP Address (Источник)", "Hostname (Назначение)", "IP Address (Назначение)", "Protocol/Port (Назначение)", "ПО использующее нестандартный порт", "Описание (цель)", "Этот доступ резервный?"]
-
-OMNI_ACL_STATUS = {'inProgress': 'JOB',
-          'Done': 'CMP',
-          'Closed': 'CMP',
-          'Assigned': 'JOB',
-          'Registered': 'JOB',
-          'RejectedByUser': 'CNL',
-          '': 'UNK'
-        }
-
-OMNI_HTTP_STATUS = {'inProgress': 'В работе',
-          'Done': 'Выполнено',
-          'Closed': 'Закрыто',
-          'Assigned': 'На исполнении',
-          'Registered': 'Новое',
-          'RejectedByUser': 'Отклолено',
-          'UNK': 'Статус не известен',
-          '': 'Статус не известен'
-        }
+traffic_column = [
+    "Hostname (Источник)",
+    "IP Address (Источник)",
+    "Hostname (Назначение)",
+    "IP Address (Назначение)",
+    "Protocol/Port (Назначение)",
+    "ПО использующее нестандартный порт",
+    "Описание (цель)",
+    "Этот доступ резервный?",
+]
+
+OMNI_ACL_STATUS = {
+    "inProgress": "JOB",
+    "Done": "CMP",
+    "Closed": "CMP",
+    "Assigned": "JOB",
+    "Registered": "JOB",
+    "RejectedByUser": "CNL",
+    "": "UNK",
+}
+
+OMNI_HTTP_STATUS = {
+    "inProgress": "В работе",
+    "Done": "Выполнено",
+    "Closed": "Закрыто",
+    "Assigned": "На исполнении",
+    "Registered": "Новое",
+    "RejectedByUser": "Отклолено",
+    "UNK": "Статус не известен",
+    "": "Статус не известен",
+}
 
 OMNI_HTTP_HEADERS = {
-    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0',
-    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
-    'Accept-Language': 'ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3',
-    'Content-Type': 'text/xml; charset=utf-8',
+    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0",
+    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
+    "Accept-Language": "ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3",
+    "Content-Type": "text/xml; charset=utf-8",
 }
 
 
 logger = logging.getLogger(__name__)
 
+
 class BaseView(View):
     def dispatch(self, request, *args, **kwargs):
         if settings.DEBUG:
@@ -99,14 +154,23 @@ class BaseView(View):
         try:
             response = super().dispatch(request, *args, **kwargs)
         except Exception as e:
-            logger.error('{}|{}|{}|{}'.format(request.path, str(e), request.META.get('REMOTE_ADDR'), datetime.datetime.today().strftime('%Y-%m-%d-%H:%M:%S')))
+            logger.error(
+                "{}|{}|{}|{}".format(
+                    request.path,
+                    str(e),
+                    request.META.get("REMOTE_ADDR"),
+                    datetime.datetime.today().strftime("%Y-%m-%d-%H:%M:%S"),
+                )
+            )
             messages.error(request, str(e))
-            return HttpResponseRedirect(reverse('acldemo_urls')) #self.__response({'errorMessage': str(e)}, status=400)
+            return HttpResponseRedirect(
+                reverse("acldemo_urls")
+            )  # self.__response({'errorMessage': str(e)}, status=400)
 
         if isinstance(response, (dict, list)):
             return self.__response(response)
         else:
-             return response
+            return response
 
     @staticmethod
     def __response(data, *, status=200):
@@ -114,66 +178,68 @@ class BaseView(View):
             data,
             status=status,
             safe=not isinstance(data, list),
-            json_dumps_params=JSON_DUMPS_PARAMS
+            json_dumps_params=JSON_DUMPS_PARAMS,
         )
 
-def isvalidip(ip)-> bool:
-        l = len(str(ip))
-        if (l == 0) or (l > 15): return False
-        s = str(ip).split('.')
-        if len(s) >= 3:
-            return True
-        else:
-            return False
+
+def isvalidip(ip) -> bool:
+    l = len(str(ip))
+    if (l == 0) or (l > 15):
+        return False
+    s = str(ip).split(".")
+    if len(s) >= 3:
+        return True
+    else:
+        return False
 
 
-def get_client_ip(request)->str:
+def get_client_ip(request) -> str:
     """Получение IP адреса клиента"""
-    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
+    x_forwarded_for = request.META.get("HTTP_X_FORWARDED_FOR")
     if x_forwarded_for:
-        ip = x_forwarded_for.split(',')[0]
+        ip = x_forwarded_for.split(",")[0]
     else:
-        ip = request.META.get('REMOTE_ADDR')
+        ip = request.META.get("REMOTE_ADDR")
     return ip
 
 
-def ip_status(ip=None)->dict:
+def ip_status(ip=None) -> dict:
     """Проверка типа IP адресса"""
     data = {}
-    data['ip'] = False
+    data["ip"] = False
     try:
         ip = ipaddress.ip_address(ip)
     except ValueError:
         return data
-    data['ip'] = True
+    data["ip"] = True
 
     if ip.is_reserved:
-        data['type'] = 3
+        data["type"] = 3
         return data
 
     if ip.is_loopback:
-        data['type'] = 4
+        data["type"] = 4
         return data
     if ip.is_multicast:
-        data['type'] = 5
+        data["type"] = 5
         return data
 
     if ip.is_global:
-        data['type'] = 1
+        data["type"] = 1
     elif ip.is_private:
-        data['type'] = 2
+        data["type"] = 2
     else:
-        data['type'] = 0
+        data["type"] = 0
     return data
 
 
-def request_handler(request, namespace=''):
+def request_handler(request, namespace=""):
     """Функция для заполнения глобального массива LOCAL_STORAGE из POST параметров файлов acl*"""
-    INFINITY = 'Нет'
+    INFINITY = "Нет"
     LOCAL_STORAGE = {}
     cnt_key = 0
     empty_key = 0
-    if namespace == FORM_APPLICATION_KEYS[0]: #first
+    if namespace == FORM_APPLICATION_KEYS[0]:  # first
         LOCAL_STORAGE[namespace] = []
         for idx, post_key in enumerate(POST_FORM_KEYS):
             if idx == len(POST_FORM_KEYS) - 1:
@@ -182,123 +248,124 @@ def request_handler(request, namespace=''):
                     continue
 
             if request.POST.get(post_key) not in POST_FORM_EMPTY:
-                 LOCAL_STORAGE[namespace].append(request.POST.get(post_key))
+                LOCAL_STORAGE[namespace].append(request.POST.get(post_key))
             else:
                 LOCAL_STORAGE[namespace].append(INFINITY)
 
         if namespace == FORM_APPLICATION_KEYS[0]:
-                if request.POST.get('action_make_docx', '') == 'on':
-                    request.session['ACT_MAKE_DOCX'] = True
-                elif 'ACT_MAKE_DOCX' in request.session:
-                     del request.session['ACT_MAKE_DOCX']
-                if request.POST.get('action_make_git', '') == 'on':
-                    request.session['ACT_MAKE_GIT'] = True
-                elif 'ACT_MAKE_GIT' in request.session:
-                    del request.session['ACT_MAKE_GIT']
-                if request.POST.get('action_make_omni', '') == 'on':
-                    request.session['ACT_OMNI'] = True
-                elif 'ACT_OMNI' in request.session:
-                    del request.session['ACT_OMNI']
-
-                #request.session.modified = True
+            if request.POST.get("action_make_docx", "") == "on":
+                request.session["ACT_MAKE_DOCX"] = True
+            elif "ACT_MAKE_DOCX" in request.session:
+                del request.session["ACT_MAKE_DOCX"]
+            if request.POST.get("action_make_git", "") == "on":
+                request.session["ACT_MAKE_GIT"] = True
+            elif "ACT_MAKE_GIT" in request.session:
+                del request.session["ACT_MAKE_GIT"]
+            if request.POST.get("action_make_omni", "") == "on":
+                request.session["ACT_OMNI"] = True
+            elif "ACT_OMNI" in request.session:
+                del request.session["ACT_OMNI"]
+
+            # request.session.modified = True
 
     else:
-        if namespace == FORM_APPLICATION_KEYS[-2]: #Traffic page
-            str_pattern = 'input__domain_source'
+        if namespace == FORM_APPLICATION_KEYS[-2]:  # Traffic page
+            str_pattern = "input__domain_source"
         else:
-            str_pattern = 'input__ip'
+            str_pattern = "input__ip"
 
         for k, v in request.POST.items():
-                if 'input_' in str(k):
-                        if len(v) > 0:
-                            try:
-                                v = '\n'.join(v.splitlines())
-                                v = v.replace('\n\n', '\n')
-                            except Exception as e:
-                                if settings.DEBUG:
-                                    logger.error("{} {}".format(stack()[0][3], e))
-                        if str_pattern in str(k):
-                            if namespace in LOCAL_STORAGE:
-                                LOCAL_STORAGE[namespace].append([v])
-                                cnt_key += 1
-                            else:
-                                LOCAL_STORAGE[namespace] = [[v]]
+            if "input_" in str(k):
+                if len(v) > 0:
+                    try:
+                        v = "\n".join(v.splitlines())
+                        v = v.replace("\n\n", "\n")
+                    except Exception as e:
+                        if settings.DEBUG:
+                            logger.error("{} {}".format(stack()[0][3], e))
+                if str_pattern in str(k):
+                    if namespace in LOCAL_STORAGE:
+                        LOCAL_STORAGE[namespace].append([v])
+                        cnt_key += 1
+                    else:
+                        LOCAL_STORAGE[namespace] = [[v]]
+                else:
+                    if v != "":
+                        LOCAL_STORAGE[namespace][cnt_key].append(v)
+                    else:
+                        if k == "d_complate":
+                            LOCAL_STORAGE[namespace][cnt_key].append(INFINITY)
                         else:
-                            if v != '':
-                                LOCAL_STORAGE[namespace][cnt_key].append(v)
-                            else:
-                                if k == 'd_complate':
-                                    LOCAL_STORAGE[namespace][cnt_key].append(INFINITY)
-                                else:
-                                    empty_key += 1
+                            empty_key += 1
 
         # if empty_key >= 2:
         #         del LOCAL_STORAGE[namespace]
-                                #return False
+        # return False
     return LOCAL_STORAGE
 
 
 def IP2Int(ip):
     """Function convert IP to integer"""
-    o = list(map(int, ip.split('.')))
+    o = list(map(int, ip.split(".")))
     res = (16777216 * o[0]) + (65536 * o[1]) + (256 * o[2]) + o[3]
     return res
 
 
-def upload_file_handler(request, functionhandler = None):
+def upload_file_handler(request, functionhandler=None):
     """Функция обработки загрузки файлов и вызова функции для парсинга xls"""
     result = {}
-    if 'input--file--upload' in request.FILES:
-        UPLOAD_PATH = tempfile.gettempdir() #os.path.join(BASE_DIR, 'upload')
-        myfile = request.FILES['input--file--upload']
+    if "input--file--upload" in request.FILES:
+        UPLOAD_PATH = tempfile.gettempdir()  # os.path.join(BASE_DIR, 'upload')
+        myfile = request.FILES["input--file--upload"]
         fs = FileSystemStorage(location=UPLOAD_PATH)
         fs.save(myfile.name, myfile)
-        uploaded_file_url = os.path.join(UPLOAD_PATH, myfile.name) #bug with persone encode'
+        uploaded_file_url = os.path.join(
+            UPLOAD_PATH, myfile.name
+        )  # bug with persone encode'
         if settings.DEBUG:
-            print('Upload file to: {}'.format(uploaded_file_url))
+            print("Upload file to: {}".format(uploaded_file_url))
     else:
-        result['error'] = "Отсутствуют файлы для загрузки"
+        result["error"] = "Отсутствуют файлы для загрузки"
         return result
-    if uploaded_file_url == '':
-        return {'error': 'There is error upload file'}
-
+    if uploaded_file_url == "":
+        return {"error": "There is error upload file"}
 
     if functionhandler is not None:
         result = functionhandler(uploaded_file_url)
     else:
-        if 'xls' not in uploaded_file_url:
-             # if 'ext.' in uploaded_file_url or \
-             #    'aktur' in uploaded_file_url or \
-             #      'alfatrah.ru' in uploaded_file_url:
-                        functionhandler = ExtractDataDns
+        if "xls" not in uploaded_file_url:
+            # if 'ext.' in uploaded_file_url or \
+            #    'aktur' in uploaded_file_url or \
+            #      'alfatrah.ru' in uploaded_file_url:
+            functionhandler = ExtractDataDns
         else:
             result = ExtractDataXls(request, uploaded_file_url).execute_file_parsing()
         # race condition
     time.sleep(1)
     try:
-            os.remove(uploaded_file_url)
-            if settings.DEBUG:
-                print('Удаление файла: {}'.format(uploaded_file_url))
+        os.remove(uploaded_file_url)
+        if settings.DEBUG:
+            print("Удаление файла: {}".format(uploaded_file_url))
     finally:
-            uploaded_file_url = None
+        uploaded_file_url = None
     if isinstance(result, int):
-       if result > 0:
-           return {'ok': 'Добавлено новых значений: {}'.format(result)}
+        if result > 0:
+            return {"ok": "Добавлено новых значений: {}".format(result)}
     else:
         if isinstance(result, dict):
-            if 'LOCAL_STORAGE' in result:
-                request.session['LOCAL_STORAGE'] = result.get('LOCAL_STORAGE')
+            if "LOCAL_STORAGE" in result:
+                request.session["LOCAL_STORAGE"] = result.get("LOCAL_STORAGE")
                 if settings.DEBUG:
-                    print(result.get('META'))
-                return {'status': 'Шаблон загружен'}
+                    print(result.get("META"))
+                return {"status": "Шаблон загружен"}
             else:
                 return result
-                #print(request.session['LOCAL_STORAGE'])
-    return {'error': 'Данных для добавления - нету'}
+    return {"error": "Данных для добавления - нету"}
 
 
 def count_perf(f):
     """Декоратор для измерения скорости поиска"""
+
     def wraper(*args, **kwargs):
         global FUN_SPEED
         time_init = datetime.datetime.now()
@@ -306,72 +373,98 @@ def count_perf(f):
         time_end = datetime.datetime.now()
         total = time_end - time_init
         FUN_SPEED = total
-        #print('Time: {}'.format(total))
         return result
+
     return wraper
 
+
 @count_perf
-def DeepSearch(request, string: str = ''):
+def DeepSearch(request, string: str = ""):
     """Функция для анализа типа данных в запросе и поиск по структуре"""
-    result, tmp = '', string
-    Iplist = apps.get_model('ownerlist', 'Iplist')
-    Acl = apps.get_model('accesslist', 'ACL')
+    result, tmp = "", string
+    Iplist = apps.get_model("ownerlist", "Iplist")
+    Acl = apps.get_model("accesslist", "ACL")
 
     if re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", tmp):
         result = Iplist.objects.filter(ipv4=tmp)
     if not result:
-            #acl = Acl.objects.filter(acltext__acl_internal_resources.html__contains=)
-
-            if re.match(r"^\d{1,3}\,\d{1,3}\,\d{1,3}\,\d{1,3}$", tmp):
-                tmp = string.replace(',', '.')
-            if tmp:
-                result = Iplist.objects.filter(ipv4__contains=tmp)[:5]
-            # else:
-            #     result = Iplist.objects.filter(ipv4__contains=string)[:5]
-            if result:
-                messages.add_message(request, messages.INFO,
-                                     'По запросу {} ничего не найдено, но мы нашли похожую информацию:'.format(string))
+        # acl = Acl.objects.filter(acltext__acl_internal_resources.html__contains=)
+
+        if re.match(r"^\d{1,3}\,\d{1,3}\,\d{1,3}\,\d{1,3}$", tmp):
+            tmp = string.replace(",", ".")
+        if tmp:
+            result = Iplist.objects.filter(ipv4__contains=tmp)[:5]
+        # else:
+        #     result = Iplist.objects.filter(ipv4__contains=string)[:5]
+        if result:
+            messages.add_message(
+                request,
+                messages.INFO,
+                "По запросу {} ничего не найдено, но мы нашли похожую информацию:".format(
+                    string
+                ),
+            )
     if not result:
         if re.match(r"[a-zA-Z0-9][a-zA-Z0-9-._]{1,61}", tmp):
 
             result = Iplist.objects.filter(hostname=tmp)[:5]
 
             if not result:
-                if '://' in tmp:
-                    tmp = tmp.split('://')[1]
-
-                if ('.vesta.ru' in tmp or '.alfastrah.ru' in tmp or '.dyn.vesta.ru' in tmp):
-                    tmp = tmp.split('.')[0]
+                if "://" in tmp:
+                    tmp = tmp.split("://")[1]
 
+                if (
+                    ".vesta.ru" in tmp
+                    or ".alfastrah.ru" in tmp
+                    or ".dyn.vesta.ru" in tmp
+                ):
+                    tmp = tmp.split(".")[0]
 
                 result = Iplist.objects.filter(hostname__icontains=tmp)[:5]
                 if result:
-                    messages.add_message(request, messages.INFO,
-                                         'По запросу {} ничего не найдено, но мы нашли похожую информацию:'.format(
-                                             string))
+                    messages.add_message(
+                        request,
+                        messages.INFO,
+                        "По запросу {} ничего не найдено, но мы нашли похожую информацию:".format(
+                            string
+                        ),
+                    )
                 if not result:
                     result = Iplist.objects.filter(comment__icontains=tmp)[:5]
                     if result:
-                        messages.add_message(request, messages.INFO,
-                                             'По запросу {} ничего не найдено, но мы нашли похожую информацию:'.format(
-                                                 string))
+                        messages.add_message(
+                            request,
+                            messages.INFO,
+                            "По запросу {} ничего не найдено, но мы нашли похожую информацию:".format(
+                                string
+                            ),
+                        )
                     else:
                         try:
                             tmp = socket.gethostbyname(tmp)
                         except:
                             pass
                         if tmp:
-                                result = Iplist.objects.filter(ipv4__contains=tmp)[:5]
+                            result = Iplist.objects.filter(ipv4__contains=tmp)[:5]
                         if result:
-                                messages.add_message(request, messages.INFO,
-                                                     'По запросу {} ничего не найдено, но мы нашли похожую информацию:'.format(
-                                                         string))
-
-
-    if re.match('[A-Za-zА-Яа-я\d\.]{3,20}', tmp):
+                            messages.add_message(
+                                request,
+                                messages.INFO,
+                                "По запросу {} ничего не найдено, но мы нашли похожую информацию:".format(
+                                    string
+                                ),
+                            )
+
+    if re.match("[A-Za-zА-Яа-я\d\.]{3,20}", tmp):
         tmp = tmp.replace("%", " ").replace("'", " ")
         row_query = Acl.objects.filter(
-            id__in=RawSQL("select id from accesslist_acl where acltext::text like '%%{}%%' limit 5".format(tmp), tmp))
+            id__in=RawSQL(
+                "select id from accesslist_acl where acltext::text like '%%{}%%' limit 5".format(
+                    tmp
+                ),
+                tmp,
+            )
+        )
         if row_query:
 
             if len(row_query) > 0 and result and len(result) > 0:
@@ -382,32 +475,32 @@ def DeepSearch(request, string: str = ''):
     return result
 
 
-
 def write_history(request, string, status) -> None:
     """Сохранять историю поиска, для улучшения качества поиска"""
-    hc = apps.get_model('ownerlist', 'HistoryCall')
-    ip = apps.get_model('ownerlist', 'Iplist')
+    hc = apps.get_model("ownerlist", "HistoryCall")
+    ip = apps.get_model("ownerlist", "Iplist")
 
-    ip_object, obj = ip.objects.get_or_create(ipv4=request.META.get('REMOTE_ADDR')) #IP-адрес пользователя
+    ip_object, obj = ip.objects.get_or_create(
+        ipv4=request.META.get("REMOTE_ADDR")
+    )  # IP-адрес пользователя
     if request.user.is_authenticated:
         User = request.user
     else:
         User = None
-    hc_object = hc.objects.create(string=string,
-                                         ipv4=ip_object,
-                                         username= User,
-                                         status=status)
+    hc_object = hc.objects.create(
+        string=string, ipv4=ip_object, username=User, status=status
+    )
     return hc_object
 
 
-def search_text(request=None, string: str = '') -> dict:
-    """ Функция для поиска данных в БД"""
+def search_text(request=None, string: str = "") -> dict:
+    """Функция для поиска данных в БД"""
     global FUN_SPEED
     result = DeepSearch(request, string)
-    context = {'SearchFor': string}
-    context['Data'] = result
-    context['TakeTime'] = FUN_SPEED
-    context['Info'] = ''
+    context = {"SearchFor": string}
+    context["Data"] = result
+    context["TakeTime"] = FUN_SPEED
+    context["Info"] = ""
     FUN_SPEED = 0
     write_history(request, string, bool(result))
     return context
@@ -415,22 +508,43 @@ def search_text(request=None, string: str = '') -> dict:
 
 class ExtractDataXls:
     """Основной класс для анализа xls файла"""
-    def __init__(self, request=None, filename=''):
+
+    def __init__(self, request=None, filename=""):
         self.ip_addr_idx = 1
-        self.count_total: int = 0 #total records in db
-        self.error_count: int = 0 #total errors
-        self.rb = xlrd.open_workbook(filename, formatting_info=True, encoding_override='utf-8')
+        self.count_total: int = 0  # total records in db
+        self.error_count: int = 0  # total errors
+        self.rb = xlrd.open_workbook(
+            filename, formatting_info=True, encoding_override="utf-8"
+        )
 
         self.current_page = None
         self.sheet_tags = self.rb.sheet_names()
-        self.Vlans = apps.get_model('ownerlist', 'Vlans')
-        self.Tags = apps.get_model('ownerlist', 'Tags')
-        self.Iplist = apps.get_model('ownerlist', 'Iplist')
-        self.Owners = apps.get_model('ownerlist', 'Owners')
-        self.page_headers = ['ответственный', 'комменты', 'ip address', 'Имя сервера', 'отвеcтвенный', 'nat inside']
-        self.fio_exclude_list = ['гусев', 'оксенюк', 'северцев', 'егоров', 'совинский', 'огнивцев', 'допиро', 'мюлекер', 'уволен', 'иренов', 'казаков', 'куслеев']
-
-
+        self.Vlans = apps.get_model("ownerlist", "Vlans")
+        self.Tags = apps.get_model("ownerlist", "Tags")
+        self.Iplist = apps.get_model("ownerlist", "Iplist")
+        self.Owners = apps.get_model("ownerlist", "Owners")
+        self.page_headers = [
+            "ответственный",
+            "комменты",
+            "ip address",
+            "Имя сервера",
+            "отвеcтвенный",
+            "nat inside",
+        ]
+        self.fio_exclude_list = [
+            "гусев",
+            "оксенюк",
+            "северцев",
+            "егоров",
+            "совинский",
+            "огнивцев",
+            "допиро",
+            "мюлекер",
+            "уволен",
+            "иренов",
+            "казаков",
+            "куслеев",
+        ]
 
     def execute_file_parsing(self):
         """Выбираем парсер на основе имени страницы"""
@@ -441,36 +555,51 @@ class ExtractDataXls:
                 if settings.DEBUG:
                     print("Страница {} пустая, пропущено...".format(self.current_page))
                     return 0
-            # else:
-            #     if settings.DEBUG:
-            #         print('Извлекаем данные из: {} ...'.format(self.sheet_tag))
-            #         print('*'*60)
-            if self.sheet_tag == 'VLAN DESCRIPTION':
-                    result += self.ExtractVlanInfo()
-            elif self.sheet_tag == 'VLAN_CORE_ACI':
-                    result += self.ExtractVlanInfo(name_idx=6, location_idx=3, vlan_idx=2, subnet_idx=4, mask_idx=5, tag1_idx=7, tag2_idx=8)
-            elif self.sheet_tag == '10.255.10.0 (NGNX-Serv)':
-                result += self.ExtractIPInfo(domain_idx=0, ip_idx=1, owner_idx=2, comment_idx=3)
-            elif self.sheet_tag == '213.33.175.0 _24':
-                result += self.ExtractIPInfo(domain_idx=1, ip_idx=2, owner_idx=4, comment_idx=5)
-            elif self.sheet_tag == 'активка 172.16.82.X':
-                result += self.ExtractIPInfo(domain_idx=1, ip_idx=0, owner_idx=2, comment_idx=3)
-            elif self.sheet_tag == '195.239.64.хх':
-                result += self.ExtractIPInfo(domain_idx=0, ip_idx=1, owner_idx=3, comment_idx=4)
+            if self.sheet_tag == "VLAN DESCRIPTION":
+                result += self.ExtractVlanInfo()
+            elif self.sheet_tag == "VLAN_CORE_ACI":
+                result += self.ExtractVlanInfo(
+                    name_idx=6,
+                    location_idx=3,
+                    vlan_idx=2,
+                    subnet_idx=4,
+                    mask_idx=5,
+                    tag1_idx=7,
+                    tag2_idx=8,
+                )
+            elif self.sheet_tag == "10.255.10.0 (NGNX-Serv)":
+                result += self.ExtractIPInfo(
+                    domain_idx=0, ip_idx=1, owner_idx=2, comment_idx=3
+                )
+            elif self.sheet_tag == "213.33.175.0 _24":
+                result += self.ExtractIPInfo(
+                    domain_idx=1, ip_idx=2, owner_idx=4, comment_idx=5
+                )
+            elif self.sheet_tag == "активка 172.16.82.X":
+                result += self.ExtractIPInfo(
+                    domain_idx=1, ip_idx=0, owner_idx=2, comment_idx=3
+                )
+            elif self.sheet_tag == "195.239.64.хх":
+                result += self.ExtractIPInfo(
+                    domain_idx=0, ip_idx=1, owner_idx=3, comment_idx=4
+                )
             elif self.current_page.ncols == 4:
-                    result += self.ExtractIPInfo()
+                result += self.ExtractIPInfo()
             else:
                 if settings.DEBUG:
-                        print("Страница содержит другое количество колонок <> 4, {} анализируем...".format(self.current_page.ncols))
+                    print(
+                        "Страница содержит другое количество колонок <> 4, {} анализируем...".format(
+                            self.current_page.ncols
+                        )
+                    )
                 result += self.PageStructAnalyzer(self.current_page)
         return result
 
-
     def is_row_empty(self, row) -> bool:
-        """ Проверяем пустая ли запись"""
+        """Проверяем пустая ли запись"""
         result = True
         for d in row:
-            if d != '':
+            if d != "":
                 result = False
                 break
         return result
@@ -483,101 +612,113 @@ class ExtractDataXls:
         except:
             return ""
 
-
-
-    def ExtractVlanInfo(self, name_idx=1, location_idx=2, vlan_idx=3, subnet_idx=4, mask_idx=5, tag1_idx=6, tag2_idx=7)->int:
+    def ExtractVlanInfo(
+        self,
+        name_idx=1,
+        location_idx=2,
+        vlan_idx=3,
+        subnet_idx=4,
+        mask_idx=5,
+        tag1_idx=6,
+        tag2_idx=7,
+    ) -> int:
         """Парсер страницы с описанием VLAN"""
         row_index: int = 0
         tags: list = []
         for row_idx in range(self.current_page.nrows):
-                        row = self.current_page.row_values(row_idx)
-                        if row_idx == 0 or self.is_row_empty(row):
-                            continue
+            row = self.current_page.row_values(row_idx)
+            if row_idx == 0 or self.is_row_empty(row):
+                continue
 
-                        if type(row[vlan_idx]) == float:
-                            vlan = int(round(row[vlan_idx]))
-                        elif type(row[vlan_idx]) == str:
-                             try:
-                                   vlan = int(round(float(row[vlan_idx])))
-                             except ValueError:
-                                    vlan = 0
-
-                        if str(row[subnet_idx]).find('/') > 0:
-                                subnet = str(row[subnet_idx]).split('/')
-                                subnet, mask = subnet[0], int(subnet[1])
-                        else:
-                            try:
-                                if len(str(row[subnet_idx])) > 15:
-                                    subnet = str(row[subnet_idx]).split('\n')[0] #Bug fig, if a couple value in row
-                                else:
-                                    subnet = str(row[subnet_idx])
-                            except ValueError:
-                                subnet = 0
+            if type(row[vlan_idx]) == float:
+                vlan = int(round(row[vlan_idx]))
+            elif type(row[vlan_idx]) == str:
+                try:
+                    vlan = int(round(float(row[vlan_idx])))
+                except ValueError:
+                    vlan = 0
 
+            if str(row[subnet_idx]).find("/") > 0:
+                subnet = str(row[subnet_idx]).split("/")
+                subnet, mask = subnet[0], int(subnet[1])
+            else:
+                try:
+                    if len(str(row[subnet_idx])) > 15:
+                        subnet = str(row[subnet_idx]).split("\n")[
+                            0
+                        ]  # Bug fig, if a couple value in row
+                    else:
+                        subnet = str(row[subnet_idx])
+                except ValueError:
+                    subnet = 0
 
-                            try:
-                                if len(str(row[mask_idx])) > 4:
-                                    mask = str(row[mask_idx]).split('\n')[0] #Bug fig, if a couple value in row
-                                    mask = int(round(float(mask)))
-                                else:
-                                    mask = int(round(float(row[mask_idx]))) or 0
-                            except ValueError:
-                                mask = 0
-
-                        vlan_info, _ = self.Vlans.objects.get_or_create(
-                        name=str(row[name_idx]),
-                        location=str(row[location_idx]),
-                        vlan=vlan,
-                        subnet=subnet,
-                        mask=mask,
-                        )
-                        # if created obj
-                        if _:
-                                self.count_total += 1
+                try:
+                    if len(str(row[mask_idx])) > 4:
+                        mask = str(row[mask_idx]).split("\n")[
+                            0
+                        ]  # Bug fig, if a couple value in row
+                        mask = int(round(float(mask)))
+                    else:
+                        mask = int(round(float(row[mask_idx]))) or 0
+                except ValueError:
+                    mask = 0
+
+            vlan_info, _ = self.Vlans.objects.get_or_create(
+                name=str(row[name_idx]),
+                location=str(row[location_idx]),
+                vlan=vlan,
+                subnet=subnet,
+                mask=mask,
+            )
+            # if created obj
+            if _:
+                self.count_total += 1
 
-                        try:
-                            tags.append(self.sheet_tag)
-                            tags.append(row[tag1_idx])
-                            tags.append(row[tag2_idx])
-
-                            for tag in tags:
-                                if (tag != '') and len(tag) > 1:
-                                            if len(str(tag).split('.')) >= 3:  # If tag as Gateway's IP
-                                                tag = "Gateway: {}".format(tag)
-                                            tag_info, _ = self.Tags.objects.get_or_create(name=str(tag).rstrip())
-                                            if tag_info not in vlan_info.tags.all():
-                                                vlan_info.tags.add(tag_info)
-                                                self.count_total += 1
-                        except:
-                            pass
+            try:
+                tags.append(self.sheet_tag)
+                tags.append(row[tag1_idx])
+                tags.append(row[tag2_idx])
+
+                for tag in tags:
+                    if (tag != "") and len(tag) > 1:
+                        if len(str(tag).split(".")) >= 3:  # If tag as Gateway's IP
+                            tag = "Gateway: {}".format(tag)
+                        tag_info, _ = self.Tags.objects.get_or_create(
+                            name=str(tag).rstrip()
+                        )
+                        if tag_info not in vlan_info.tags.all():
+                            vlan_info.tags.add(tag_info)
+                            self.count_total += 1
+            except:
+                pass
 
-                        finally:
-                            tags.clear()
+            finally:
+                tags.clear()
 
         if settings.DEBUG:
             print("Добавленно {} новых записей в БД.".format(self.count_total))
 
         return self.count_total
 
-    def ExtractIPInfo(self, domain_idx=0, ip_idx=1, owner_idx=2, comment_idx=3, stop_recurse = False, HasTags=[])->int:
+    def ExtractIPInfo(
+        self,
+        domain_idx=0,
+        ip_idx=1,
+        owner_idx=2,
+        comment_idx=3,
+        stop_recurse=False,
+        HasTags=[],
+    ) -> int:
         tags: list = []
         self.error_count = 0
         Header_POS = 0
         created = None
 
-        ip_addr = ''
-        domain = ''
-        owner = ''
-        comment = ''
-
-
+        ip_addr = ""
+        domain = ""
+        owner = ""
+        comment = ""
 
-        # if HasTags is not None:
-        #     if len(HasTags) > 0:
-        #         tags = HasTags
-
-        #print(self.sheet_tag)
-        #return 0
         self.count_total = 0
         for row_idx in range(self.current_page.nrows):
             row = self.current_page.row_values(row_idx)
@@ -586,61 +727,68 @@ class ExtractDataXls:
                 #     print ('')
                 if len(row) >= 3:
                     if row_idx in range(0, 3):
-                        if row[row_idx] in self.page_headers: #Пропускаем заголовки
+                        if row[row_idx] in self.page_headers:  # Пропускаем заголовки
                             Header_POS = row_idx
                             continue
                 if isvalidip(row[ip_idx]):
                     ip_addr = row[ip_idx]
-                elif len(str(row[ip_idx])) <= 5: #15.0
-                            try:
-                                tmp = int(round(float(row[ip_idx]))) or 0
-                            except ValueError:
-                                tmp = 0
-                                continue
-                            else:
-                                if tmp > 0:
-                                    ip_addr = self.get_ip_from_page(str(self.sheet_tag))
-                                    if ip_addr != '':
-                                            ip_addr = ip_addr + '.' + str(tmp)
+                elif len(str(row[ip_idx])) <= 5:  # 15.0
+                    try:
+                        tmp = int(round(float(row[ip_idx]))) or 0
+                    except ValueError:
+                        tmp = 0
+                        continue
+                    else:
+                        if tmp > 0:
+                            ip_addr = self.get_ip_from_page(str(self.sheet_tag))
+                            if ip_addr != "":
+                                ip_addr = ip_addr + "." + str(tmp)
                 else:
                     self.error_count += 1
                     if self.error_count >= 5:
                         if not stop_recurse:
                             if settings.DEBUG:
-                                print("Много ошибок на странице, провёдем анализ страницы ...")
+                                print(
+                                    "Много ошибок на странице, провёдем анализ страницы ..."
+                                )
                             self.PageStructAnalyzer(self.current_page)
                         else:
                             if settings.DEBUG:
-                                print("********************Ошибка при анализе странице {}****************".format(self.sheet_tag))
+                                print(
+                                    "********************Ошибка при анализе странице {}****************".format(
+                                        self.sheet_tag
+                                    )
+                                )
                         return 0
                     continue
                 try:
                     if domain_idx is not None:
                         domain = row[domain_idx]
                 except:
-                    domain = ''
-
+                    domain = ""
 
                 try:
                     if owner_idx is not None:
                         owner = row[owner_idx]
                 except:
-                    owner = ''
+                    owner = ""
 
                 try:
                     if comment_idx is not None:
                         comment = row[comment_idx]
                 except:
-                    comment = ''
+                    comment = ""
 
                 if len(HasTags) > 0:
                     for tag in HasTags:
                         try:
                             tmp = row[int(tag)]
-                            if tmp != '':
-                                name = self.current_page.cell_value(Header_POS, int(tag))
-                                if name != '':
-                                    tmp = name + ":"+tmp
+                            if tmp != "":
+                                name = self.current_page.cell_value(
+                                    Header_POS, int(tag)
+                                )
+                                if name != "":
+                                    tmp = name + ":" + tmp
                                 if tmp not in tags:
                                     tags.append(tmp)
                         except:
@@ -648,47 +796,49 @@ class ExtractDataXls:
                 if self.sheet_tag not in tags:
                     tags.append(self.sheet_tag)
 
-#-----------------------------------------------------------------------------------------------------------------------
+                # -----------------------------------------------------------------------------------------------------------------------
                 try:
                     if comment and re.match(r"([а-яА-Я\.\s()]){5,}", str(comment)):
                         tmp = comment.lower().strip()
                         exists = list(filter(lambda s: s in tmp, self.fio_exclude_list))
-                        #exists = any(substring in string for string in strings)
-                        #if comment.lower() in self.fio_exclude_list:
+                        # exists = any(substring in string for string in strings)
+                        # if comment.lower() in self.fio_exclude_list:
                         if len(exists) > 0:
                             owner, comment = comment, owner
                 except:
                     pass
-#-----------------------------------------------------------------------------------------------------------------------
+                # -----------------------------------------------------------------------------------------------------------------------
 
                 try:
                     if owner:
-                        if owner.find('://') != -1:
+                        if owner.find("://") != -1:
                             owner, comment = comment, owner
                 except:
                     pass
 
-                if ip_addr != '':
-                   # if not self.isvalidip(ip_addr):
+                if ip_addr != "":
+                    # if not self.isvalidip(ip_addr):
 
-                       # continue
+                    # continue
                     # if comment_idx != -1:
                     #     print("{} {} {} {} ".format(domain, ip_addr, row[owner_idx], row[comment_idx]))
                     # else:
-                    if (owner == '') or len(owner) <= 1:
+                    if (owner == "") or len(owner) <= 1:
                         owner_info = None
                     else:
-                        #try:
-                            owner_info, created = self.Owners.objects.get_or_create(username = owner)
-                        #except:
-                            #owner_info = self.Owners.get_default_owner()
+                        # try:
+                        owner_info, created = self.Owners.objects.get_or_create(
+                            username=owner
+                        )
+                    # except:
+                    # owner_info = self.Owners.get_default_owner()
 
                     try:
                         ip_info, created = self.Iplist.objects.get_or_create(
-                            ipv4 = ip_addr,
-                            hostname = domain,
-                            owner = owner_info,
-                            comment = comment
+                            ipv4=ip_addr,
+                            hostname=domain,
+                            owner=owner_info,
+                            comment=comment,
                         )
                     except IntegrityError:
                         ip_info = self.Iplist.objects.get(ipv4=ip_addr)
@@ -699,219 +849,256 @@ class ExtractDataXls:
                         ip_info.save()
 
                     except DataError:
-                        print("- Ошибка данных: {} на странице: {}".format(ip_addr, self.sheet_tag))
+                        print(
+                            "- Ошибка данных: {} на странице: {}".format(
+                                ip_addr, self.sheet_tag
+                            )
+                        )
                         continue
 
                     if created:
                         self.count_total += 1
 
-
                     try:
                         for tag in tags:
-                            if (tag != '') and len(tag) > 1:
-                                tag_info, created = self.Tags.objects.get_or_create(name=str(tag).rstrip())
+                            if (tag != "") and len(tag) > 1:
+                                tag_info, created = self.Tags.objects.get_or_create(
+                                    name=str(tag).rstrip()
+                                )
                                 if tag_info not in ip_info.tags.all():
                                     ip_info.tags.add(tag_info)
                     except:
                         pass
 
                     finally:
-                            #print("{} {} {} {}-> {}".format(domain, ip_addr, owner, comment, " [" + ' '.join(tags) + "]"))
+                        # print("{} {} {} {}-> {}".format(domain, ip_addr, owner, comment, " [" + ' '.join(tags) + "]"))
 
-                            tags.clear()
+                        tags.clear()
         if settings.DEBUG:
             print("Страница: {} записано: {}".format(self.sheet_tag, self.count_total))
         return self.count_total
 
-    def PageStructAnalyzer(self, page, DEBUG = False)-> None:
+    def PageStructAnalyzer(self, page, DEBUG=False) -> None:
         """Написанный на коленке анализатор данных на странице в xls"""
         is_domain = 0
         is_ip = 0
         is_owner = 0
         is_comment = 0
         is_add = 0
-        col_index ={}
-        #RowIndex = 0
-        #RowBlackListByNumber = []
+        col_index = {}
+        # RowIndex = 0
+        # RowBlackListByNumber = []
         skip_domain = False
         skip_owner = False
         skip_ip = False
         skip_commnet = False
 
-        col_index['domain'] = None
-        col_index['ip'] = None
-        col_index['owner'] = None
-        col_index['comment'] = None
+        col_index["domain"] = None
+        col_index["ip"] = None
+        col_index["owner"] = None
+        col_index["comment"] = None
 
         Tags = []
-        #col_index = {}
+        # col_index = {}
         # if self.sheet_tag == '172.16.88.Х Avaya':
         #     print('')
         if not (page.ncols > 0):  # and page.ncols < 6
-                print("Page {} has been skipped, unknown amount col {}".format(self.sheet_tag, page.ncols))
+            print(
+                "Page {} has been skipped, unknown amount col {}".format(
+                    self.sheet_tag, page.ncols
+                )
+            )
         else:
-                for idx_col in range(page.ncols):
-                    col_stat = {'Unknown': 0,
-                                'is_domain': 0,
-                                'is_ip': 0,
-                                'is_owner': 0,
-                                'is_comment': 0,
-                                'is_tag': 0}
-
-                    #RowIndex = 0
-                    if idx_col >=8: #Skip comment in tables
-                        continue
+            for idx_col in range(page.ncols):
+                col_stat = {
+                    "Unknown": 0,
+                    "is_domain": 0,
+                    "is_ip": 0,
+                    "is_owner": 0,
+                    "is_comment": 0,
+                    "is_tag": 0,
+                }
+
+                # RowIndex = 0
+                if idx_col >= 8:  # Skip comment in tables
+                    continue
 
-                    for index, col in enumerate(page.col_values(idx_col)):
-                        if col == '':
+                for index, col in enumerate(page.col_values(idx_col)):
+                    if col == "":
+                        continue
+                    if index in range(0, 2):
+                        if col in self.page_headers:
+                            continue
+                    try:
+                        if len(str(col)) <= 1:
                             continue
-                        if index in range(0, 2):
-                            if col in self.page_headers:
+                        if re.match(
+                            r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", str(col)
+                        ) or re.match(r"^(\d+.\d)|(\d)$", str(col)):
+                            if not skip_ip:
+                                col_stat["is_ip"] += 1
                                 continue
-                        try:
-                            if len(str(col)) <= 1:
+                            else:
+                                if idx_col not in Tags:
+                                    Tags.append(idx_col)
                                 continue
-                            if (re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", str(col)) or
-                                re.match(r"^(\d+.\d)|(\d)$", str(col))):
-                                    if not skip_ip:
-                                        col_stat['is_ip'] += 1
-                                        continue
-                                    else:
-                                      if  idx_col not in Tags:
-                                            Tags.append(idx_col)
-                                      continue
-                        except TypeError:
-                            pass
-
+                    except TypeError:
+                        pass
 
-                        try:
-                            if (skip_domain == False) and re.match(r"([a-zA-Z0-9\-\.\\()\_]){4,}", str(col)):  # [А-я]+
-                                    col_stat['is_domain'] += 1
-                                    continue
-                        except TypeError:
-                                pass
+                    try:
+                        if (skip_domain == False) and re.match(
+                            r"([a-zA-Z0-9\-\.\\()\_]){4,}", str(col)
+                        ):  # [А-я]+
+                            col_stat["is_domain"] += 1
+                            continue
+                    except TypeError:
+                        pass
 
+                    try:
+                        if (skip_owner == False) and re.match(
+                            r"([а-яА-Я\.\s()]){5,}", str(col)
+                        ):
+                            col_stat["is_owner"] += 1
+                            continue
+                    except:
+                        pass
 
-                        try:
-                            if (skip_owner == False) and re.match(r"([а-яА-Я\.\s()]){5,}", str(col)):
-                                   col_stat['is_owner'] += 1
-                                   continue
-                        except:
+                        # else:
+                    if len(str(col)) > 3:
+                        t = str(col).lower().find("vlan")
+                        if t > 0:
                             pass
+                        #     str_sum = len(col)
+                        #     #col_stat['is_tag'] += 1
+                        #     try:
+                        #         #cut_vlan = col.split(' ')
+                        #         if idx_col not in Tags:
+                        #             Tags.append(idx_col)
+                        #             continue
+                        #     except:
+                        #         pass
+                        # in ['vlan', 'vlan name', 'location', ]
+                        else:
+                            if not skip_commnet:
+                                col_stat["is_comment"] += 1
+                            else:
+                                if idx_col not in Tags:
+                                    Tags.append(idx_col)
+                                    continue
 
-                                #else:
-                        if len(str(col)) > 3:
-                                        t = str(col).lower().find('vlan')
-                                        if t > 0: pass
-                                        #     str_sum = len(col)
-                                        #     #col_stat['is_tag'] += 1
-                                        #     try:
-                                        #         #cut_vlan = col.split(' ')
-                                        #         if idx_col not in Tags:
-                                        #             Tags.append(idx_col)
-                                        #             continue
-                                        #     except:
-                                        #         pass
-                                            # in ['vlan', 'vlan name', 'location', ]
-                                        else:
-                                            if not skip_commnet:
-                                                col_stat['is_comment'] += 1
-                                            else:
-                                                if idx_col not in Tags:
-                                                    Tags.append(idx_col)
-                                                    continue
-
-
-
-
-
-                    max_v = max(col_stat, key=col_stat.get)
-                    if 'Unknown' == max_v:
-                        continue
-                    elif max_v == 'is_domain':
-                        col_index['domain'] = idx_col
-                        skip_domain = True
-                        if idx_col in Tags:
-                            Tags.remove(idx_col)
-                    elif  max_v == 'is_owner':
-                            skip_owner = True
-                            col_index['owner'] = idx_col
-                            if idx_col in Tags:
-                                Tags.remove(idx_col)
-                    elif max_v == 'is_ip':
-                                skip_ip = True
-                                col_index['ip'] = idx_col
-                                if idx_col in Tags:
-                                    Tags.remove(idx_col)
-                    elif not skip_commnet:
-                            col_index['comment'] = idx_col
+                max_v = max(col_stat, key=col_stat.get)
+                if "Unknown" == max_v:
+                    continue
+                elif max_v == "is_domain":
+                    col_index["domain"] = idx_col
+                    skip_domain = True
+                    if idx_col in Tags:
+                        Tags.remove(idx_col)
+                elif max_v == "is_owner":
+                    skip_owner = True
+                    col_index["owner"] = idx_col
+                    if idx_col in Tags:
+                        Tags.remove(idx_col)
+                elif max_v == "is_ip":
+                    skip_ip = True
+                    col_index["ip"] = idx_col
+                    if idx_col in Tags:
+                        Tags.remove(idx_col)
+                elif not skip_commnet:
+                    col_index["comment"] = idx_col
+                    if idx_col in Tags:
+                        Tags.remove(idx_col)
+
+                if max_v == "is_comment":
+                    if idx_col == 2:
+                        if (col_stat["is_owner"]) >= 5:
+                            col_index["owner"] = idx_col
                             if idx_col in Tags:
                                 Tags.remove(idx_col)
-
-                    if max_v == 'is_comment':
-                                    if idx_col == 2:
-                                            if (col_stat['is_owner']) >= 5:
-                                                col_index['owner'] = idx_col
-                                                if idx_col in Tags:
-                                                    Tags.remove(idx_col)
-                                                if settings.DEBUG:
-                                                    print(
-                                                        "Page: {}| Col {}| possible: [FIX] owner (d:{},i:{}, o:{},c:{},t:{})".format(
-                                                            self.sheet_tag, idx_col, col_stat['is_domain'],
-                                                            col_stat['is_ip'],
-                                                            col_stat['is_owner'], col_stat['is_comment'], col_stat['is_tag']))
-                                                continue
-                                    else:
-                                        skip_commnet = True
-
-
-                        #print("Page: {}| Col {}| possible empty, skipped".format(self.sheet_tag, idx_col))
-                    #else:
-                    if DEBUG:
-                        print("Page: {}| Col {}| possible: {}(d:{},i:{}, o:{},c:{},t:{})".format(self.sheet_tag, idx_col,
-                                                                                                max_v,
-                                                                                                col_stat['is_domain'],
-                                                                                                col_stat['is_ip'],
-                                                                                                col_stat['is_owner'],
-                                                                                                col_stat['is_comment'],
-                                                                                                col_stat['is_tag']))
+                            if settings.DEBUG:
+                                print(
+                                    "Page: {}| Col {}| possible: [FIX] owner (d:{},i:{}, o:{},c:{},t:{})".format(
+                                        self.sheet_tag,
+                                        idx_col,
+                                        col_stat["is_domain"],
+                                        col_stat["is_ip"],
+                                        col_stat["is_owner"],
+                                        col_stat["is_comment"],
+                                        col_stat["is_tag"],
+                                    )
+                                )
+                            continue
+                    else:
+                        skip_commnet = True
+
+                if DEBUG:
+                    print(
+                        "Page: {}| Col {}| possible: {}(d:{},i:{}, o:{},c:{},t:{})".format(
+                            self.sheet_tag,
+                            idx_col,
+                            max_v,
+                            col_stat["is_domain"],
+                            col_stat["is_ip"],
+                            col_stat["is_owner"],
+                            col_stat["is_comment"],
+                            col_stat["is_tag"],
+                        )
+                    )
 
         if not DEBUG:
-            return self.ExtractIPInfo(domain_idx=col_index['domain'], ip_idx=col_index['ip'], owner_idx=col_index['owner'],
-                                  comment_idx=col_index['comment'], stop_recurse=True, HasTags=Tags)
+            return self.ExtractIPInfo(
+                domain_idx=col_index["domain"],
+                ip_idx=col_index["ip"],
+                owner_idx=col_index["owner"],
+                comment_idx=col_index["comment"],
+                stop_recurse=True,
+                HasTags=Tags,
+            )
 
-def UpdateCallBackStatus (request, taskid, name, value, event = 1):
+
+def UpdateCallBackStatus(request, taskid, name, value, event=1):
     """Функция для создания сообщения callback на запрос статуса потоками"""
     JOB = cache.get(taskid, {})
     if event == 2:
-        JOB.update({name: {'done': value}}) #done
+        JOB.update({name: {"done": value}})  # done
     elif event == 1:
-        JOB.update({name: {'status': value}})
+        JOB.update({name: {"status": value}})
     else:
-        JOB.update({name: {'error': value}})
+        JOB.update({name: {"error": value}})
         try:
-            logger.error("{} [error] [client {}] [user {}] {}".format(str(datetime.datetime.now()), request.META.get('REMOTE_ADDR'), request.user, value))
+            logger.error(
+                "{} [error] [client {}] [user {}] {}".format(
+                    str(datetime.datetime.now()),
+                    request.META.get("REMOTE_ADDR"),
+                    request.user,
+                    value,
+                )
+            )
         except:
             pass
     cache.set(taskid, JOB)
 
-def add_hyperlink(paragraph,url,text,color, underline):
-    import docx
-    part = paragraph.part
-    r_id = part.relate_to(url, docx.opc.constants.RELATIONSHIP_TYPE.HYPERLINK, is_external=True)
 
-    hyperlink = docx.oxml.shared.OxmlElement('w:hyperlink')
-    hyperlink.set(docx.oxml.shared.qn('r:id'), r_id)
+def add_hyperlink(paragraph, url, text, color, underline):
+    import docx
 
-    new_run = docx.oxml.shared.OxmlElement('w:r')
-    rPr = docx.oxml.shared.OxmlElement('w:rPr')
-    if not color is None:
-        c = docx.oxml.shared.OxmlElement('w:color')
-        c.set(docx.oxml.shared.qn('w:val'), color)
+    part = paragraph.part
+    r_id = part.relate_to(
+        url, docx.opc.constants.RELATIONSHIP_TYPE.HYPERLINK, is_external=True
+    )
+
+    hyperlink = docx.oxml.shared.OxmlElement("w:hyperlink")
+    hyperlink.set(docx.oxml.shared.qn("r:id"), r_id)
+
+    new_run = docx.oxml.shared.OxmlElement("w:r")
+    rPr = docx.oxml.shared.OxmlElement("w:rPr")
+    if color is not None:
+        c = docx.oxml.shared.OxmlElement("w:color")
+        c.set(docx.oxml.shared.qn("w:val"), color)
         rPr.append(c)
     if underline:
-        u = docx.oxml.shared.OxmlElement('w:u')
-        u.set(docx.oxml.shared.qn('w:val'), 'single')
+        u = docx.oxml.shared.OxmlElement("w:u")
+        u.set(docx.oxml.shared.qn("w:val"), "single")
         rPr.append(u)
 
     new_run.append(rPr)
@@ -921,8 +1108,12 @@ def add_hyperlink(paragraph,url,text,color, underline):
 
     return hyperlink
 
-def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_filename='')->str:
+
+def make_doc(
+    request=None, data_set={}, fileuuid="", gitlab_repo_url="", gitlab_filename=""
+) -> str:
     """Функция для генерации docx файла"""
+
     def normalize_whitespace(data_set):
         for data_idx, data in enumerate(data_set):
             try:
@@ -930,63 +1121,76 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                     continue
                 for row_idx, row_value in enumerate(data_set[data]):
                     for cell_idx, cell_value in enumerate(row_value):
-                        if (all(ch.isspace() for ch in cell_value)):
-                            data_set[data][row_idx][cell_idx] = ' '
+                        if all(ch.isspace() for ch in cell_value):
+                            data_set[data][row_idx][cell_idx] = " "
                         else:
                             try:
                                 data_set[data][row_idx][cell_idx] = cell_value.strip()
                             except Exception as e:
                                 logger.error(e)
             except:
-                logger.info('Не удалось нормализовать пробелы docx. Продолжаем создание docx.')
+                logger.info(
+                    "Не удалось нормализовать пробелы docx. Продолжаем создание docx."
+                )
                 continue
         return data_set
 
-    if gitlab_repo_url != '' and gitlab_filename != '':
-        md_content, project_desc = get_acl_from_gitlab(repo_url=gitlab_repo_url, file_name=gitlab_filename)
+    if gitlab_repo_url != "" and gitlab_filename != "":
+        md_content, project_desc = get_acl_from_gitlab(
+            repo_url=gitlab_repo_url, file_name=gitlab_filename
+        )
 
-        gitlab_data_set = convert_md_to_dict(md_content)['LOCAL_STORAGE']
+        gitlab_data_set = convert_md_to_dict(md_content)["LOCAL_STORAGE"]
         data_set = normalize_whitespace(data_set)
         gitlab_data_set = normalize_whitespace(gitlab_data_set)
     else:
         gitlab_data_set = data_set
 
-    is_in_session = 'ACT_MAKE_DOCX' in request.session
-    TEMPLATE_FILE = os.path.join(BASE_DIR, 'templates//ACL.docx')
+    is_in_session = "ACT_MAKE_DOCX" in request.session
+    TEMPLATE_FILE = os.path.join(BASE_DIR, "templates//ACL.docx")
     try:
-        fileuuid = data_set['acl_create_info.html'][4] or ""
+        fileuuid = data_set["acl_create_info.html"][4] or ""
         if len(fileuuid) > 10:
-            fileuuid = fileuuid.split(' ')
+            fileuuid = fileuuid.split(" ")
             if len(fileuuid) > 2:
                 fileuuid = fileuuid[:2]
             fileuuid = "_".join(fileuuid)
 
-        fileuuid = fileuuid.replace(' ', '_').replace(',', '').replace('.', '').replace('/', '_')
+        fileuuid = (
+            fileuuid.replace(" ", "_")
+            .replace(",", "")
+            .replace(".", "")
+            .replace("/", "_")
+        )
     except:
         fileuuid = ""
 
-    if fileuuid == '':
+    if fileuuid == "":
         fileuuid = str(uuid.uuid4())
 
     if is_in_session:
-        UpdateCallBackStatus(request, fileuuid, 'docx_download_status', 'Создаем docx файл')
+        UpdateCallBackStatus(
+            request, fileuuid, "docx_download_status", "Создаем docx файл"
+        )
 
     try:
-        gitlab_filename = gitlab_filename.split('.')[:-1][0]
-        APP_FILE = 'static/docx/ACL_' + fileuuid + "_" + gitlab_filename + '.docx'
+        gitlab_filename = gitlab_filename.split(".")[:-1][0]
+        APP_FILE = "static/docx/ACL_" + fileuuid + "_" + gitlab_filename + ".docx"
     except Exception as e:
-        APP_FILE = 'static/docx/ACL_' + fileuuid + '.docx'
-        logger.error(f'Не удалось добавить gitlab_filename в название файла docx:{e}')
+        APP_FILE = "static/docx/ACL_" + fileuuid + ".docx"
+        logger.error(f"Не удалось добавить gitlab_filename в название файла docx:{e}")
 
     doc = Document(TEMPLATE_FILE)
     if is_in_session:
-        UpdateCallBackStatus(request, fileuuid, 'docx_download_status', 'Записываем изменения')
+        UpdateCallBackStatus(
+            request, fileuuid, "docx_download_status", "Записываем изменения"
+        )
 
-    doc.styles['Normal'].font.name = 'Verdana'
-    doc.styles['Normal'].font.size = Pt(10)
+    doc.styles["Normal"].font.name = "Verdana"
+    doc.styles["Normal"].font.size = Pt(10)
     for data_inx, data in enumerate(FORM_APPLICATION_KEYS):
         table_tmp = doc.tables[data_inx]  # Берем таблицу по номеру
-        table_rows = len(table_tmp.rows) - 1  #Берем все строки из таблицы
+        table_rows = len(table_tmp.rows) - 1  # Берем все строки из таблицы
         table_cols = len(table_tmp.columns)
         if data_inx == 0:  # Для таблицы контакты, меняем правила игры
             notFoundCount = 0
@@ -995,11 +1199,13 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                     if row_idx >= table_rows:
                         table_tmp.add_row()
                     if row_idx == 5:
-                        if row_data != 'Нет' and row_data != '':
+                        if row_data != "Нет" and row_data != "":
                             try:
                                 for paragraph in table_tmp.cell(row_idx, 1).paragraphs:
-                                    add_hyperlink(paragraph, row_data, row_data, '0000EE', True)
-                            except Exception as e:
+                                    add_hyperlink(
+                                        paragraph, row_data, row_data, "0000EE", True
+                                    )
+                            except Exception:
                                 table_tmp.cell(row_idx, 1).text = row_data
                         else:
                             table_tmp.cell(row_idx, 1).text = row_data
@@ -1011,8 +1217,12 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                             for run in paragraph.runs:
                                 run.font.highlight_color = WD_COLOR_INDEX.YELLOW
                         try:
-                            strike_paragraph = table_tmp.cell(row_idx, 1).add_paragraph()
-                            run_strike = strike_paragraph.add_run(str(gitlab_data_set.get(data, [])[row_idx]))
+                            strike_paragraph = table_tmp.cell(
+                                row_idx, 1
+                            ).add_paragraph()
+                            run_strike = strike_paragraph.add_run(
+                                str(gitlab_data_set.get(data, [])[row_idx])
+                            )
                             run_strike.font.strike = True
                             run_strike.font.highlight_color = WD_COLOR_INDEX.RED
                         except:
@@ -1020,7 +1230,9 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                 except Exception as e:
                     logger.error(e)
             if notFoundCount > 0:
-                logger.info(f"Не удалось найти {notFoundCount} строк(и) страницы Контакты в gitlab")
+                logger.info(
+                    f"Не удалось найти {notFoundCount} строк(и) страницы Контакты в gitlab"
+                )
         else:
             row_cnt = 0
             if data not in data_set:
@@ -1034,9 +1246,11 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                                     cell = table_tmp.cell(key, cell_idx)
                                     cell.text = str(cell_val)
                                     cell.paragraphs[0].runs[0].font.strike = True
-                                    cell.paragraphs[0].runs[0].font.highlight_color = WD_COLOR_INDEX.RED
+                                    cell.paragraphs[0].runs[
+                                        0
+                                    ].font.highlight_color = WD_COLOR_INDEX.RED
                         except Exception as e:
-                            logger.error(f'[restore from gitlab data set error ] {e}')
+                            logger.error(f"[restore from gitlab data set error ] {e}")
                 continue
             for key, value in enumerate(data_set[data], start=1):
                 try:
@@ -1053,7 +1267,9 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                             for cell_idx, cell_val in enumerate(value):
                                 try:
                                     cell = table_tmp.cell(key, cell_idx)
-                                    cell.paragraphs[0].runs[0].font.highlight_color = WD_COLOR_INDEX.YELLOW
+                                    cell.paragraphs[0].runs[
+                                        0
+                                    ].font.highlight_color = WD_COLOR_INDEX.YELLOW
                                 except Exception as e:
                                     logger.error(e)
                         else:
@@ -1061,7 +1277,9 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                                 for cell_idx, cell_val in enumerate(value):
                                     try:
                                         cell = table_tmp.cell(key, cell_idx)
-                                        cell.paragraphs[0].runs[0].font.highlight_color = WD_COLOR_INDEX.YELLOW
+                                        cell.paragraphs[0].runs[
+                                            0
+                                        ].font.highlight_color = WD_COLOR_INDEX.YELLOW
                                     except Exception as e:
                                         logger.error(e)
                     row_cnt += 1
@@ -1087,16 +1305,21 @@ def make_doc(request=None, data_set={}, fileuuid='', gitlab_repo_url='', gitlab_
                     row_cnt += 1
                 except Exception as e:
                     logger.error(e)
-    if 'taskid' in request.session:
-        if (request.session['taskid'] != ''):
-            p = doc.add_paragraph(request.session['taskid'])
+    if "taskid" in request.session:
+        if request.session["taskid"] != "":
+            p = doc.add_paragraph(request.session["taskid"])
             table = doc.tables[0]
             table._element.addnext(p._p)
 
     if is_in_session:
-        UpdateCallBackStatus(request, fileuuid, 'docx_download_status', "Сохраняем файл {} ".format("Application_" + fileuuid))
+        UpdateCallBackStatus(
+            request,
+            fileuuid,
+            "docx_download_status",
+            "Сохраняем файл {} ".format("Application_" + fileuuid),
+        )
     doc.save(os.path.join(BASE_DIR, APP_FILE))
-    return '/' + APP_FILE
+    return "/" + APP_FILE
 
 
 def is_valid_uuid(uuid_to_test, version=4):
@@ -1159,13 +1382,13 @@ def table(records, fields, headings=None, alignment=None, file=None):
     if len(extended_align) > num_columns:
         extended_align = extended_align[0:num_columns]
     elif len(extended_align) < num_columns:
-        extended_align += [('^', '<')
-                           for i in range[num_columns - len(extended_align)]]
+        extended_align += [("^", "<") for i in range[num_columns - len(extended_align)]]
 
     heading_align, cell_align = [x for x in zip(*extended_align)]
 
-    field_widths = [len(max(column, key=len)) if len(column) > 0 else 0
-                    for column in columns]
+    field_widths = [
+        len(max(column, key=len)) if len(column) > 0 else 0 for column in columns
+    ]
     if headings:
         heading_widths = [max(len(head), 2) for head in headings]
 
@@ -1174,42 +1397,46 @@ def table(records, fields, headings=None, alignment=None, file=None):
 
     column_widths = [max(x) for x in zip(field_widths, heading_widths)]
 
-    _ = ' | '.join(['{:' + a + str(w) + '}'
-                    for a, w in zip(heading_align, column_widths)])
-    heading_template = '| ' + _ + ' |'
-    _ = ' | '.join(['{:' + a + str(w) + '}'
-                    for a, w in zip(cell_align, column_widths)])
+    _ = " | ".join(
+        ["{:" + a + str(w) + "}" for a, w in zip(heading_align, column_widths)]
+    )
+    heading_template = "| " + _ + " |"
+    _ = " | ".join(["{:" + a + str(w) + "}" for a, w in zip(cell_align, column_widths)])
 
-    row_template = '| ' + _ + ' |'
+    row_template = "| " + _ + " |"
 
-    _ = ' | '.join([left_rule[a] + '-' * (w - 2) + right_rule[a]
-                    for a, w in zip(cell_align, column_widths)])
-    ruling = '| ' + _ + ' |'
+    _ = " | ".join(
+        [
+            left_rule[a] + "-" * (w - 2) + right_rule[a]
+            for a, w in zip(cell_align, column_widths)
+        ]
+    )
+    ruling = "| " + _ + " |"
 
     if file is not None:
         if headings:
-            file.write(heading_template.format(*headings).rstrip() + '\n')
-        file.write(ruling.rstrip() + '\n')
+            file.write(heading_template.format(*headings).rstrip() + "\n")
+        file.write(ruling.rstrip() + "\n")
         for row in zip(*columns):
-            file.write(row_template.format(*row).rstrip() + '\n')
-        file.write('\n')
-        file.write('\n')
+            file.write(row_template.format(*row).rstrip() + "\n")
+        file.write("\n")
+        file.write("\n")
 
 
-def MakeMarkDown(request, json_data, filename, fileuuid=''):
+def MakeMarkDown(request, json_data, filename, fileuuid=""):
     """Функция записывает JSON как md файл"""
     print("[MakeMarkDown] Создание md")
-    UpdateCallBackStatus(request, fileuuid, 'git_upload_status', 'Создание md файла')
+    UpdateCallBackStatus(request, fileuuid, "git_upload_status", "Создание md файла")
 
     try:
         file_path = os.path.join(BASE_DIR, f"static/md/{filename}.md")
         with codecs.open(file_path, "w", encoding="utf-8") as file:
             func_map = {
-                'acl_create_info.html': md_write_acl_create_info,
-                'acl_internal_resources.html': md_write_acl_internal_resources,
-                'acl_dmz_resources.html': md_write_acl_dmz_resources,
-                'acl_external_resources.html': md_write_acl_external_resources,
-                'acl_traffic.html': md_write_acl_traffic
+                "acl_create_info.html": md_write_acl_create_info,
+                "acl_internal_resources.html": md_write_acl_internal_resources,
+                "acl_dmz_resources.html": md_write_acl_dmz_resources,
+                "acl_external_resources.html": md_write_acl_external_resources,
+                "acl_traffic.html": md_write_acl_traffic,
             }
             for key, data in json_data.items():
                 if key in func_map:
@@ -1219,7 +1446,7 @@ def MakeMarkDown(request, json_data, filename, fileuuid=''):
         md_handle_error(filename, fileuuid, e)
         return False
 
-    UpdateCallBackStatus(request, fileuuid, 'git_upload_status', 'ACL file created')
+    UpdateCallBackStatus(request, fileuuid, "git_upload_status", "ACL file created")
     return f"/static/md/{filename}.md"
 
 
@@ -1230,7 +1457,13 @@ def md_write_acl_create_info(file, data):
     file.write("##### Описание доступа к ресурсам\n")
     tmp = zip(contact_table, data)
     fields = [0, 1]
-    table(records=tmp, fields=fields, headings=contact_column, alignment=[('<', '<'), ('<', '<')], file=file)
+    table(
+        records=tmp,
+        fields=fields,
+        headings=contact_column,
+        alignment=[("<", "<"), ("<", "<")],
+        file=file,
+    )
 
 
 def md_write_acl_internal_resources(file, data):
@@ -1238,7 +1471,13 @@ def md_write_acl_internal_resources(file, data):
     print("[MakeMarkDown] acl_internal_resources")
     file.write("\n##### Список внутренних ресурсов (СГ АльфаСтрахование)\n")
     fields = [0, 1, 2]
-    table(records=data, fields=fields, headings=standart_column, alignment=[('<', '<'), ('^', '^'), ('<', '<')], file=file)
+    table(
+        records=data,
+        fields=fields,
+        headings=standart_column,
+        alignment=[("<", "<"), ("^", "^"), ("<", "<")],
+        file=file,
+    )
 
 
 def md_write_acl_dmz_resources(file, data):
@@ -1246,7 +1485,13 @@ def md_write_acl_dmz_resources(file, data):
     print("[MakeMarkDown] acl_dmz_resources")
     file.write("\n##### Список DMZ ресурсов (СГ АльфаСтрахование)\n")
     fields = [0, 1, 2]
-    table(records=data, fields=fields, headings=standart_column, alignment=[('<', '<'), ('^', '^'), ('<', '<')], file=file)
+    table(
+        records=data,
+        fields=fields,
+        headings=standart_column,
+        alignment=[("<", "<"), ("^", "^"), ("<", "<")],
+        file=file,
+    )
 
 
 def md_write_acl_external_resources(file, data):
@@ -1254,7 +1499,13 @@ def md_write_acl_external_resources(file, data):
     print("[MakeMarkDown] acl_external_resources")
     file.write("\n##### Список внешних ресурсов (Internet)\n")
     fields = [0, 1, 2, 3]
-    table(records=data, fields=fields, headings=external_column, alignment=[('<', '<'), ('<', '<'), ('^', '^'), ('<', '<')], file=file)
+    table(
+        records=data,
+        fields=fields,
+        headings=external_column,
+        alignment=[("<", "<"), ("<", "<"), ("^", "^"), ("<", "<")],
+        file=file,
+    )
 
 
 def md_write_acl_traffic(file, data):
@@ -1265,18 +1516,49 @@ def md_write_acl_traffic(file, data):
     if data:
         for item in data:
             if len(item) < len(fields):
-                item.extend([' '] * (len(fields) - len(item)))
-        table(records=data, fields=fields, headings=traffic_column, alignment=[('<', '<'), ('<', '<'), ('<', '<'), ('<', '<'), ('<', '<'), ('<', '<'), ('<', '<'), ('<', '<')], file=file)
+                item.extend([" "] * (len(fields) - len(item)))
+        table(
+            records=data,
+            fields=fields,
+            headings=traffic_column,
+            alignment=[
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+                ("<", "<"),
+            ],
+            file=file,
+        )
 
 
 def md_handle_error(filename, fileuuid, e):
-    print(f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}")
-    send_to_mattermost(f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}")
-    logger.error(f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}")
+    print(
+        f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}"
+    )
+    send_to_mattermost(
+        f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}"
+    )
+    logger.error(
+        f"[ACL PORTAL] Error creating MD: {e} | filename: {filename} | fileuuid: {fileuuid}"
+    )
+
 
 class GitWorker:
-    def __init__(self, request, GITPRO=None, USERNAME=None, PASSWORD=None,  PATH_OF_GIT_REPO=None, MDFILE='', taskid=''):
-        os.environ['GIT_TIMEOUT'] = '60'
+    def __init__(
+        self,
+        request,
+        GITPRO=None,
+        USERNAME=None,
+        PASSWORD=None,
+        PATH_OF_GIT_REPO=None,
+        MDFILE="",
+        taskid="",
+    ):
+        os.environ["GIT_TIMEOUT"] = "60"
         uid = str(uuid.uuid4())
         self.USERNAME = settings.GITLAB_AUTH_USERNAME
         self.gitlab_token = settings.GIT_ACCESS_TOKEN
@@ -1284,26 +1566,50 @@ class GitWorker:
         self.gitlab_token_encoded = urllib.parse.quote_plus(self.gitlab_token)
         if PATH_OF_GIT_REPO is not None:
             try:
-                self.repo = git.Repo.init(PATH_OF_GIT_REPO, bare=True) #PATH_OF_GIT_REPO
+                self.repo = git.Repo.init(
+                    PATH_OF_GIT_REPO, bare=True
+                )  # PATH_OF_GIT_REPO
             except:
-                UpdateCallBackStatus(request, taskid, 'git_upload_status', 'Ошибка при инициализации Repo: {}'.format(PATH_OF_GIT_REPO), 0)
+                UpdateCallBackStatus(
+                    request,
+                    taskid,
+                    "git_upload_status",
+                    "Ошибка при инициализации Repo: {}".format(PATH_OF_GIT_REPO),
+                    0,
+                )
                 return False
             if settings.DEBUG:
-                logger.debug('Инициализация GIT репозитория {}'.format(PATH_OF_GIT_REPO))
+                logger.debug(
+                    "Инициализация GIT репозитория {}".format(PATH_OF_GIT_REPO)
+                )
         else:
             tmp = os.path.join(tempfile.gettempdir(), uid)
             try:
-                self.repo = git.Repo.init(tmp, bare=True)  # uid, bare=True os.path.join(tempfile.gettempdir(), uid)
-                print(f'Инициализирован новый репозиторий:{self.repo}')
+                self.repo = git.Repo.init(
+                    tmp, bare=True
+                )  # uid, bare=True os.path.join(tempfile.gettempdir(), uid)
+                print(f"Инициализирован новый репозиторий:{self.repo}")
             except:
-                UpdateCallBackStatus(request, taskid, 'git_upload_status', 'Ошибка при инициализации Repo: {}'.format(tmp), 0)
+                UpdateCallBackStatus(
+                    request,
+                    taskid,
+                    "git_upload_status",
+                    "Ошибка при инициализации Repo: {}".format(tmp),
+                    0,
+                )
                 return False
             if settings.DEBUG:
-                logger.debug('Инициализация GIT репозитория {}'.format(os.path.join(tempfile.gettempdir(), uid)))
+                logger.debug(
+                    "Инициализация GIT репозитория {}".format(
+                        os.path.join(tempfile.gettempdir(), uid)
+                    )
+                )
 
         self.request = request
         self.taskid = taskid
-        UpdateCallBackStatus(request, taskid, 'git_upload_status', 'Инициализация Git проекта')
+        UpdateCallBackStatus(
+            request, taskid, "git_upload_status", "Инициализация Git проекта"
+        )
 
         # if PASSWORD is not None and USERNAME is not None:
         #      self.USERNAME = USERNAME
@@ -1320,27 +1626,33 @@ class GitWorker:
         #
 
         self.GITURL = GITPRO
-        self.GITPRO = GITPRO.split('://')[1]
-        self.GITPRO = f"https://{self.USERNAME_encoded}:{self.gitlab_token_encoded}@{self.GITPRO}"
+        self.GITPRO = GITPRO.split("://")[1]
+        self.GITPRO = (
+            f"https://{self.USERNAME_encoded}:{self.gitlab_token_encoded}@{self.GITPRO}"
+        )
 
         if PATH_OF_GIT_REPO is not None:
             self.PATH_OF_GIT_REPO = PATH_OF_GIT_REPO
         else:
-             #if settings.DEBUG:
-                 #self.PATH_OF_GIT_REPO = os.path.join(os.path.abspath(os.getcwd()), str(uuid.uuid4()))
+            # if settings.DEBUG:
+            # self.PATH_OF_GIT_REPO = os.path.join(os.path.abspath(os.getcwd()), str(uuid.uuid4()))
             # else:
-                self.PATH_OF_GIT_REPO = os.path.join(tempfile.gettempdir(), uid)
+            self.PATH_OF_GIT_REPO = os.path.join(tempfile.gettempdir(), uid)
 
-        self.PATH_OF_GIT_REPO = os.path.join(self.PATH_OF_GIT_REPO, 'REPO')
+        self.PATH_OF_GIT_REPO = os.path.join(self.PATH_OF_GIT_REPO, "REPO")
 
         if not os.path.exists(self.PATH_OF_GIT_REPO):
-                 os.makedirs(self.PATH_OF_GIT_REPO)
-                 UpdateCallBackStatus(request, taskid, 'git_upload_status', "Создание временой папки")
-                 #self.request.session['git_upload_status'].append({'status': "Создание временой папки: {}".format(self.PATH_OF_GIT_REPO)})
-                 if settings.DEBUG:
-                     logger.debug("Создание временой папки: {}".format(self.PATH_OF_GIT_REPO))
-        #else:
-              # os.path.join(BASE_DIR, 'upload')
+            os.makedirs(self.PATH_OF_GIT_REPO)
+            UpdateCallBackStatus(
+                request, taskid, "git_upload_status", "Создание временой папки"
+            )
+            # self.request.session['git_upload_status'].append({'status': "Создание временой папки: {}".format(self.PATH_OF_GIT_REPO)})
+            if settings.DEBUG:
+                logger.debug(
+                    "Создание временой папки: {}".format(self.PATH_OF_GIT_REPO)
+                )
+        # else:
+        # os.path.join(BASE_DIR, 'upload')
         if not os.path.exists(MDFILE):
             self.MDFILE = os.path.join(os.path.abspath(os.getcwd()), MDFILE)
         else:
@@ -1348,7 +1660,6 @@ class GitWorker:
         if settings.DEBUG:
             logger.debug("Путь к md файлу: {}".format(self.MDFILE))
 
-
     def free(self):
         for i in range(1, 3):
             self.repo.close()
@@ -1362,27 +1673,55 @@ class GitWorker:
         try:
             # if settings.DEBUG:
             #     logger.debug('Копируем репозиторий: {} ->{} '.format(self.GITPRO, self.PATH_OF_GIT_REPO))
-            UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Клонируем удаленный репозиторий")
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Клонируем удаленный репозиторий",
+            )
             self.repo = self.repo.clone_from(self.GITPRO, self.PATH_OF_GIT_REPO)
         except Exception as e:
             if e.status == 128:
-                #self.request.session['git_upload_status'].append({'error': "Нет доступа к GIT репозиторию"})
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Нет доступа к GIT репозиторию", 0)
+                # self.request.session['git_upload_status'].append({'error': "Нет доступа к GIT репозиторию"})
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Нет доступа к GIT репозиторию",
+                    0,
+                )
             else:
-                #self.request.session['git_upload_status'].append({'error': "[Ошибка] {}".format(e)})
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Ошибка при клонировании репозитория", 0)
+                # self.request.session['git_upload_status'].append({'error': "[Ошибка] {}".format(e)})
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Ошибка при клонировании репозитория",
+                    0,
+                )
             if settings.DEBUG:
-                logger.debug('Ошибка при копировании')
+                logger.debug("Ошибка при копировании")
             return 0
 
         if len(self.repo.index.entries) == 0:
-           #self.request.session['git_upload_status'].append({'error': "Не удалось скачать файлы проекта, папка пустая"})
-           UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Не удалось скачать файлы проекта, проект пустой", 0)
-           if settings.DEBUG:
-               logger.debug("Не удалось скачать файлы проекта, папка пустая")
-           return 0
-        #self.request.session['git_upload_status'].append({'status': "Скачано: {} файлов".format(len(self.repo.index.entries))})
-        UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Скачано: {} файлов".format(len(self.repo.index.entries)))
+            # self.request.session['git_upload_status'].append({'error': "Не удалось скачать файлы проекта, папка пустая"})
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Не удалось скачать файлы проекта, проект пустой",
+                0,
+            )
+            if settings.DEBUG:
+                logger.debug("Не удалось скачать файлы проекта, папка пустая")
+            return 0
+        # self.request.session['git_upload_status'].append({'status': "Скачано: {} файлов".format(len(self.repo.index.entries))})
+        UpdateCallBackStatus(
+            self.request,
+            self.taskid,
+            "git_upload_status",
+            "Скачано: {} файлов".format(len(self.repo.index.entries)),
+        )
         if settings.DEBUG:
             logger.debug("Скачано: {} файлов".format(len(self.repo.index.entries)))
         return True
@@ -1390,22 +1729,33 @@ class GitWorker:
     def fetch(self):
         try:
             self.repo.git.fetch()
-            logger.info(f'Выполнен git fetch')
+            logger.info("Выполнен git fetch")
             return True
         except Exception as e:
-            logger.error(f'Ошибка при выполнении git fetch:{e}')
+            logger.error(f"Ошибка при выполнении git fetch:{e}")
             return False
 
-
     def pull(self):
         try:
             self.repo.git.pull()
-            logger.info('git pull выполнен')
+            logger.info("git pull выполнен")
         except Exception as e:
             if e.status == 128:
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Нет доступа к GIT репозиторию", 0)
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Нет доступа к GIT репозиторию",
+                    0,
+                )
             else:
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Ошибка при пулле резозитория", 0)
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Ошибка при пулле резозитория",
+                    0,
+                )
                 logger.error(e)
 
     def activity(self, git_filename: str):
@@ -1413,83 +1763,139 @@ class GitWorker:
             sfile = self.MDFILE
             dfile = os.path.join(self.PATH_OF_GIT_REPO, git_filename)
             if not copyfile(sfile, dfile):
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Ошибка при копировании md файла в проект", 0)
-                #self.request.session['git_upload_status'].append({'error': "Ошибка при копировании файла в проект: {}".format(dfile)})
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Ошибка при копировании md файла в проект",
+                    0,
+                )
+                # self.request.session['git_upload_status'].append({'error': "Ошибка при копировании файла в проект: {}".format(dfile)})
                 if settings.DEBUG:
-                    logger.debug("Ошибка при копировании файла {} в проект: {}".format(sfile, dfile))
+                    logger.debug(
+                        "Ошибка при копировании файла {} в проект: {}".format(
+                            sfile, dfile
+                        )
+                    )
                 return 0
-            UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Копирование md файла в проект")
-            #self.request.session['git_upload_status'].append({'status': "Копирование файла в проект: {}".format(dfile)})
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Копирование md файла в проект",
+            )
+            # self.request.session['git_upload_status'].append({'status': "Копирование файла в проект: {}".format(dfile)})
             if settings.DEBUG:
                 logger.debug("Копирование файла в проект: {}".format(dfile))
-        except Exception as e:
-            #self.request.session['git_upload_status'].append({'error': "Возникла ошибка при копировании md файла в папку проекта"})
-            UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Возникла ошибка при копировании md файла в папку проекта", 0)
+        except Exception:
+            # self.request.session['git_upload_status'].append({'error': "Возникла ошибка при копировании md файла в папку проекта"})
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Возникла ошибка при копировании md файла в папку проекта",
+                0,
+            )
             if settings.DEBUG:
                 logger.error("Возникла ошибка при копировании md файла в папку проекта")
             return 0
-        #finally:
-        #if 'linux' in sys.platform:
-            #return str(PurePosixPath(dfile)).replace('/', '//')
-        return dfile #str(PurePosixPath(dfile)).replace('/', '//')
+        # finally:
+        # if 'linux' in sys.platform:
+        # return str(PurePosixPath(dfile)).replace('/', '//')
+        return dfile  # str(PurePosixPath(dfile)).replace('/', '//')
 
     def addindex(self, filename):
         try:
             index = self.repo.index
             index.add([filename])
             clear_filename = os.path.basename(filename)
-            username = self.USERNAME.replace('%40', '@')
-            index.commit(f"{COMMIT_MESSAGE} {os.path.basename(clear_filename)} by {username}")
-            UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status',
-                                 "Локальный коммит изменений")
+            username = self.USERNAME.replace("%40", "@")
+            index.commit(
+                f"{COMMIT_MESSAGE} {os.path.basename(clear_filename)} by {username}"
+            )
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Локальный коммит изменений",
+            )
             if settings.DEBUG:
                 logger.debug("Локальный коммит изменений")
         except Exception as e:
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', "Ошибка при локальном коммите", 0)
-                if settings.DEBUG:
-                    logger.error("Ошибка при локальном коммите: {}".format(e))
-                return False
+            UpdateCallBackStatus(
+                self.request,
+                self.taskid,
+                "git_upload_status",
+                "Ошибка при локальном коммите",
+                0,
+            )
+            if settings.DEBUG:
+                logger.error("Ошибка при локальном коммите: {}".format(e))
+            return False
         return True
 
-    def push(self, refspec=''):
+    def push(self, refspec=""):
         if settings.DEBUG:
             logger.debug("Отправка изменений на сервер")
         try:
             for remote in self.repo.remotes:
-                if remote.name == 'origin':
+                if remote.name == "origin":
                     if not remote.exists():
-                        error_message = "Репозиторий не существует или нет доступа к нему"
+                        error_message = (
+                            "Репозиторий не существует или нет доступа к нему"
+                        )
                         print(error_message)
-                        UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', error_message, 0)
+                        UpdateCallBackStatus(
+                            self.request,
+                            self.taskid,
+                            "git_upload_status",
+                            error_message,
+                            0,
+                        )
                         return False
                     break
             for head in self.repo.heads:
-                if head.name == refspec.split(':')[0]:
+                if head.name == refspec.split(":")[0]:
                     break
             else:
                 error_message = f"Ветка {refspec.split(':')[0]} не существует"
                 print(error_message)
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', error_message, 0)
+                UpdateCallBackStatus(
+                    self.request, self.taskid, "git_upload_status", error_message, 0
+                )
                 return False
 
-            print(f'repo remotes:{self.repo.remotes}')
-            print(f'refspec:{refspec}')
+            print(f"repo remotes:{self.repo.remotes}")
+            print(f"refspec:{refspec}")
             result = self.repo.remotes.origin.push(refspec=refspec, force=True)
             if result:
                 print(f"Файл acl успешно загружен в репозиторий:{result}")
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status',"Файл acl успешно загружен в репозиторий")
+                UpdateCallBackStatus(
+                    self.request,
+                    self.taskid,
+                    "git_upload_status",
+                    "Файл acl успешно загружен в репозиторий",
+                )
                 return True
         except git.exc.GitCommandError as e:
             if e.status == 128:
                 error_message = "Ошибка аутентификации для данного репозитория"
                 print(error_message)
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', error_message, 0)
-                send_to_mattermost(f'[ACL PORTAL] Не удалось отправить md файл в git: У пользователя {self.USERNAME.replace("%40", "@")} нет доступа.')
+                UpdateCallBackStatus(
+                    self.request, self.taskid, "git_upload_status", error_message, 0
+                )
+                send_to_mattermost(
+                    f'[ACL PORTAL] Не удалось отправить md файл в git: У пользователя {self.USERNAME.replace("%40", "@")} нет доступа.'
+                )
             else:
                 error_message = "Ошибка при отправке коммита на сервер"
                 print(error_message)
-                UpdateCallBackStatus(self.request, self.taskid, 'git_upload_status', error_message, 0)
-                send_to_mattermost(f'[ACL PORTAL] Не удалось отправить md файл в git: {e}')
+                UpdateCallBackStatus(
+                    self.request, self.taskid, "git_upload_status", error_message, 0
+                )
+                send_to_mattermost(
+                    f"[ACL PORTAL] Не удалось отправить md файл в git: {e}"
+                )
         finally:
             self.repo.close()
             if settings.DEBUG:
@@ -1498,22 +1904,24 @@ class GitWorker:
         return False
 
 
-def dns_fileHandler(fname, full_buf)->int:
+def dns_fileHandler(fname, full_buf) -> int:
     """Функция парсинга DNS Aktur"""
     count = 0
-    EMAIL = '(\w|\.|\_|\-)+[@](\w|\_|\-|\.)+[.]\w{2,3}'
-    DEFAULT = 'Default'
-    MASK = ['@', ';', ' ', '_', '$']
-    with codecs.open(fname, 'r', encoding='utf-8', errors='ignore') as f: #encoding='utf-8'
-        owner = ''
+    EMAIL = "(\w|\.|\_|\-)+[@](\w|\_|\-|\.)+[.]\w{2,3}"
+    DEFAULT = "Default"
+    MASK = ["@", ";", " ", "_", "$"]
+    with codecs.open(
+        fname, "r", encoding="utf-8", errors="ignore"
+    ) as f:  # encoding='utf-8'
+        owner = ""
 
         for line in f:
             try:
-                #line = line.decode('cp1252').encode('utf-8')
+                # line = line.decode('cp1252').encode('utf-8')
                 if len(line) > 1:
                     if line[0] not in MASK:
-                        if 'IN' in str(line).upper():
-                            if owner != '':
+                        if "IN" in str(line).upper():
+                            if owner != "":
                                 if owner not in full_buf:
                                     full_buf[owner] = []
                                 full_buf[owner].append(line.strip())
@@ -1524,15 +1932,19 @@ def dns_fileHandler(fname, full_buf)->int:
                                 full_buf[DEFAULT].append(line.strip())
                                 count += 1
                     else:
-                        if ('<<' in line) or \
-                             (';<' in line and not ('/' in line or '\\' in line)) or \
-                             ('<' in line and re.search(EMAIL, line)) or \
-                             ('OT' in line and (':' in line or '#' in line)):
-                                owner = line.strip()
-                        elif ('>>' in line and owner != '') or  (';<' in line and ('/' in line or '\\' in line)):
+                        if (
+                            ("<<" in line)
+                            or (";<" in line and not ("/" in line or "\\" in line))
+                            or ("<" in line and re.search(EMAIL, line))
+                            or ("OT" in line and (":" in line or "#" in line))
+                        ):
+                            owner = line.strip()
+                        elif (">>" in line and owner != "") or (
+                            ";<" in line and ("/" in line or "\\" in line)
+                        ):
                             if owner not in full_buf:
                                 full_buf[owner] = []
-                            owner = ''
+                            owner = ""
                         else:
                             if DEFAULT not in full_buf:
                                 full_buf[DEFAULT] = []
@@ -1545,84 +1957,84 @@ def dns_fileHandler(fname, full_buf)->int:
     return count
 
 
-def ExtractDataDns(uploaded_file_url)->int:
+def ExtractDataDns(uploaded_file_url) -> int:
     """Функция записи из буфера DNS файла"""
     buff = {}
-    Tags = apps.get_model('ownerlist', 'Tags')
-    Iplist = apps.get_model('ownerlist', 'Iplist')
-    Owners = apps.get_model('ownerlist', 'Owners')
+    Tags = apps.get_model("ownerlist", "Tags")
+    Iplist = apps.get_model("ownerlist", "Iplist")
+    Owners = apps.get_model("ownerlist", "Owners")
     count = 0
     result = dns_fileHandler(uploaded_file_url, buff)
-    file_name = os.path.basename(uploaded_file_url) or 'Aktur DNS'
+    file_name = os.path.basename(uploaded_file_url) or "Aktur DNS"
     if buff:
-           for owner in buff:
-               for value in buff[owner]:
-                       line = value.split()
-                       if len(line) < 4:
-                           continue
-                       elif len(line) >= 5:
-                           del line[1]
-                       if line[2] == 'CNAME':
-                            for cname in buff:
-                                for tmp in buff[cname]:
-                                    s = tmp.split()
-                                    if line[3] == s[0]:
-                                        owner = "{} CNAME {}".format(owner, line[3])
-                                        if len(s) >= 5:
-                                            line[3] = s[4]
-                                        else:
-                                             line[3] = s[3]
-                                        break
-                            if not isvalidip(line[3]):
-                                try:
-                                    r = socket.gethostbyname(line[3])
-                                    if r:
-                                        owner = "{} CNAME {}".format(owner, line[3])
-                                        line[3] = r
-                                except:
-                                    pass
-
-                       if settings.DEBUG:
-                            print(line)
-
-                       try:
-                              owner_info, created1 = Owners.objects.get_or_create(username='Макаренко А.Б')
-
-                       except:
-                               owner_info = Owners.get_default_owner()
-                       try:
-                           tag_info, created2 = Tags.objects.get_or_create(name=file_name)
-                       except:
+        for owner in buff:
+            for value in buff[owner]:
+                line = value.split()
+                if len(line) < 4:
+                    continue
+                elif len(line) >= 5:
+                    del line[1]
+                if line[2] == "CNAME":
+                    for cname in buff:
+                        for tmp in buff[cname]:
+                            s = tmp.split()
+                            if line[3] == s[0]:
+                                owner = "{} CNAME {}".format(owner, line[3])
+                                if len(s) >= 5:
+                                    line[3] = s[4]
+                                else:
+                                    line[3] = s[3]
+                                break
+                    if not isvalidip(line[3]):
+                        try:
+                            r = socket.gethostbyname(line[3])
+                            if r:
+                                owner = "{} CNAME {}".format(owner, line[3])
+                                line[3] = r
+                        except:
                             pass
 
-                       try:
-                            created3 = None
-                            ip_info, created3 = Iplist.objects.get_or_create(
-                                ipv4=line[3],
-                                hostname=line[0],
-                                owner=owner_info,
-                                comment=owner,
-                                )
-                            if created3:
-                                count += 1
-                       except IntegrityError:
-                            ip_info = Iplist.objects.get(ipv4=line[3])
-                            ip_info.ipv4 = line[3]
-                            ip_info.hostname = line[0]
-                            ip_info.owner = owner_info
-                            ip_info.comment = owner
+                if settings.DEBUG:
+                    print(line)
 
-                            ip_info.save()
+                try:
+                    owner_info, created1 = Owners.objects.get_or_create(
+                        username="Макаренко А.Б"
+                    )
 
-                       except DataError as e:
-                            if settings.DEBUG:
-                                print("- Ошибка данных: {}".format(e))
+                except:
+                    owner_info = Owners.get_default_owner()
+                try:
+                    tag_info, created2 = Tags.objects.get_or_create(name=file_name)
+                except:
+                    pass
+
+                try:
+                    created3 = None
+                    ip_info, created3 = Iplist.objects.get_or_create(
+                        ipv4=line[3],
+                        hostname=line[0],
+                        owner=owner_info,
+                        comment=owner,
+                    )
+                    if created3:
+                        count += 1
+                except IntegrityError:
+                    ip_info = Iplist.objects.get(ipv4=line[3])
+                    ip_info.ipv4 = line[3]
+                    ip_info.hostname = line[0]
+                    ip_info.owner = owner_info
+                    ip_info.comment = owner
 
+                    ip_info.save()
 
-                       if created3:
-                           ip_info.tags.add(tag_info)
-                           ip_info.save()
+                except DataError as e:
+                    if settings.DEBUG:
+                        print("- Ошибка данных: {}".format(e))
 
+                if created3:
+                    ip_info.tags.add(tag_info)
+                    ip_info.save()
 
     return count
 
@@ -1630,32 +2042,39 @@ def ExtractDataDns(uploaded_file_url)->int:
 def ClearSessionMeta(request=None):
     """Функция очистки сессии при переходе на другую страницу"""
     if request:
-        SESSION_STORE = ['LOCAL_STORAGE', 'uuid', 'taskid', 'ACT_MAKE_GIT', 'ACT_MAKE_DOCX', 'ACT_OMNI',
-                         'file_download']
+        SESSION_STORE = [
+            "LOCAL_STORAGE",
+            "uuid",
+            "taskid",
+            "ACT_MAKE_GIT",
+            "ACT_MAKE_DOCX",
+            "ACT_OMNI",
+            "file_download",
+        ]
         for sid in SESSION_STORE:
             if sid in request.session:
                 del request.session[sid]
 
-        if 'file_download' in request.session:
+        if "file_download" in request.session:
             try:
-                BASE = os.path.basename(request.session['file_download'])
+                BASE = os.path.basename(request.session["file_download"])
                 if BASE:
-                    BASE = os.path.join(settings.BASE_DIR, 'static//docx//' + BASE)
+                    BASE = os.path.join(settings.BASE_DIR, "static//docx//" + BASE)
                     if os.path.exists(BASE):
                         os.remove(BASE)
             finally:
-                del request.session['file_download']
+                del request.session["file_download"]
                 BASE = None
 
-        if 'file_download_md' in request.session:
+        if "file_download_md" in request.session:
             try:
-                BASE = os.path.basename(request.session['file_download_md'])
+                BASE = os.path.basename(request.session["file_download_md"])
                 if BASE:
-                    BASE = os.path.join(settings.BASE_DIR, 'static//md//' + BASE)
+                    BASE = os.path.join(settings.BASE_DIR, "static//md//" + BASE)
                     if os.path.exists(BASE):
                         os.remove(BASE)
             finally:
-                del request.session['file_download_md']
+                del request.session["file_download_md"]
                 BASE = None
 
 
@@ -1673,6 +2092,7 @@ def compare_first_column(doc1, doc2):
         return True
     return False
 
+
 def compare_table_headers(doc1, doc2):
     for table1, table2 in zip(doc1.tables[1:], doc2.tables[1:]):
         headers1 = [cell.text for cell in table1.rows[0].cells]
@@ -1681,20 +2101,24 @@ def compare_table_headers(doc1, doc2):
             return False
     return True
 
+
 def check_file_against_template(file_path, template_path):
     doc1 = Document(file_path)
     doc2 = Document(template_path)
     return compare_first_column(doc1, doc2) and compare_table_headers(doc1, doc2)
 
+
 def ParseDocx(file):
-    template_file = os.path.join(BASE_DIR, 'templates//ACL.docx')
+    template_file = os.path.join(BASE_DIR, "templates//ACL.docx")
     LOCAL_STORAGE = {}
     FIX_STATISTICS = 0
     SKIP__STATISTICS = 0
     result = {}
     if not check_file_against_template(file, template_file):
-        logger.error(f'Был загружен файл, несоответствующий шаблону.{file}')
-        result['error'] = 'Неправильный формат файла. Проверьте заголовки в вашем файле.'
+        logger.error(f"Был загружен файл, несоответствующий шаблону.{file}")
+        result["error"] = (
+            "Неправильный формат файла. Проверьте заголовки в вашем файле."
+        )
         return result
     try:
         doc = Document(file)
@@ -1715,19 +2139,21 @@ def ParseDocx(file):
                 else:
                     for id, row in enumerate(table.rows):
                         if id == 3 or id == 4:
-                            buffer.append('')
+                            buffer.append("")
 
-                        elif id == 6 and row.cells[1].text == '':
-                            buffer.append('Нет')
+                        elif id == 6 and row.cells[1].text == "":
+                            buffer.append("Нет")
                             continue
-                        elif id == 5 and row.cells[1].text == '' and buffer[6] != '':
+                        elif id == 5 and row.cells[1].text == "" and buffer[6] != "":
                             buffer.append(buffer[6])
                             continue
 
                         if id in [4, 5, 6]:
-                            if (row.cells[1].text != '' and '.' in row.cells[1].text):
+                            if row.cells[1].text != "" and "." in row.cells[1].text:
                                 if re.match("^(\d{2}.\d{2}.\d{4})$", row.cells[1].text):
-                                    d = datetime.datetime.strptime(row.cells[1].text, "%d.%m.%Y")
+                                    d = datetime.datetime.strptime(
+                                        row.cells[1].text, "%d.%m.%Y"
+                                    )
                                     buffer.append(d.strftime("%Y-%m-%d"))
                                     continue
 
@@ -1736,57 +2162,91 @@ def ParseDocx(file):
                 LOCAL_STORAGE[namespace] = buffer
             elif idx in range(len(FORM_APPLICATION_KEYS)):
                 if table_cols >= 3:
-                    #if namespace not in LOCAL_STORAGE:
-                        #LOCAL_STORAGE[namespace] = []
+                    # if namespace not in LOCAL_STORAGE:
+                    # LOCAL_STORAGE[namespace] = []
                     for id, row in enumerate(table.rows):
                         if id != 0:
-                            if any([cell.text != '' for cell in row.cells]):
-                                    line = [row.cells[x].text for x in range(table_cols)]
-                                    if len(line) == 3:
-                                        CHECK_INDEX = 0
-                                        if line[1] == '':
-                                            line[1] = '32'
-                                            FIX_STATISTICS += 1
-                                        elif '.' in line[1]:
-                                            line[1] = GetNumberFromMask(line[1])
-                                        elif '/' in line[1]:
-                                            line[1] = line[1][1:]
-                                    elif len(line) == 4:
-                                        if line[2] == '':
-                                            line[2] = '32'
-                                            FIX_STATISTICS += 1
-
-                                    if namespace not in LOCAL_STORAGE:
-                                        LOCAL_STORAGE[namespace] = []
-                                    LOCAL_STORAGE[namespace].append(line[:])
+                            if any([cell.text != "" for cell in row.cells]):
+                                line = [row.cells[x].text for x in range(table_cols)]
+                                if len(line) == 3:
+                                    CHECK_INDEX = 0
+                                    if line[1] == "":
+                                        line[1] = "32"
+                                        FIX_STATISTICS += 1
+                                    elif "." in line[1]:
+                                        line[1] = GetNumberFromMask(line[1])
+                                    elif "/" in line[1]:
+                                        line[1] = line[1][1:]
+                                elif len(line) == 4:
+                                    if line[2] == "":
+                                        line[2] = "32"
+                                        FIX_STATISTICS += 1
+
+                                if namespace not in LOCAL_STORAGE:
+                                    LOCAL_STORAGE[namespace] = []
+                                LOCAL_STORAGE[namespace].append(line[:])
                             else:
                                 SKIP__STATISTICS += 1
 
     except ValueError as e:
-       if 'is not a Word' in str(e):
-            result['error'] = 'Ошибка при загрузке старого формата doc файла'
-       else:
-           result['error'] = '{}'.format(e)
+        if "is not a Word" in str(e):
+            result["error"] = "Ошибка при загрузке старого формата doc файла"
+        else:
+            result["error"] = "{}".format(e)
     except opc.exceptions.PackageNotFoundError:
-       result['error'] = 'Ошибка, вероятно это не docx файл'
+        result["error"] = "Ошибка, вероятно это не docx файл"
     except Exception as e:
-       result['error'] = str(e)
-       logger.error(f'Ошибка загрузки из файла:{e}')
+        result["error"] = str(e)
+        logger.error(f"Ошибка загрузки из файла:{e}")
     finally:
         if len(LOCAL_STORAGE) > 0:
-                result['LOCAL_STORAGE'] = LOCAL_STORAGE
-        result['META'] = {}
+            result["LOCAL_STORAGE"] = LOCAL_STORAGE
+        result["META"] = {}
         if FIX_STATISTICS > 0:
-                result['META']['fixed'] = '{}'.format(FIX_STATISTICS)
+            result["META"]["fixed"] = "{}".format(FIX_STATISTICS)
         if SKIP__STATISTICS > 0:
-                result['META']['skipped'] = '{}'.format(SKIP__STATISTICS)
+            result["META"]["skipped"] = "{}".format(SKIP__STATISTICS)
     return result
 
 
-def GetNumberFromMask(mask=''):
+def GetNumberFromMask(mask=""):
     """Функция возвращает число префикса по маске"""
     result = mask
-    buff = ["000.000.000.000", "128.000.000.000", "192.000.000.000", "224.000.000.000", "240.000.000.000", "248.000.000.000", "252.000.000.000", "254.000.000.000", "255.000.000.000", "255.128.000.000", "255.192.000.000", "255.224.000.000", "255.240.000.000", "255.248.000.000", "255.252.000.000", "255.254.000.000", "255.255.000.000", "255.255.128.000", "255.255.192.000", "255.255.224.000", "255.255.240.000", "255.255.248.000", "255.255.252.000", "255.255.254.000", "255.255.255.000", "255.255.255.128", "255.255.255.192", "255.255.255.224", "255.255.255.240", "255.255.255.248", "255.255.255.252", "255.255.255.254", "255.255.255.255"]
+    buff = [
+        "000.000.000.000",
+        "128.000.000.000",
+        "192.000.000.000",
+        "224.000.000.000",
+        "240.000.000.000",
+        "248.000.000.000",
+        "252.000.000.000",
+        "254.000.000.000",
+        "255.000.000.000",
+        "255.128.000.000",
+        "255.192.000.000",
+        "255.224.000.000",
+        "255.240.000.000",
+        "255.248.000.000",
+        "255.252.000.000",
+        "255.254.000.000",
+        "255.255.000.000",
+        "255.255.128.000",
+        "255.255.192.000",
+        "255.255.224.000",
+        "255.255.240.000",
+        "255.255.248.000",
+        "255.255.252.000",
+        "255.255.254.000",
+        "255.255.255.000",
+        "255.255.255.128",
+        "255.255.255.192",
+        "255.255.255.224",
+        "255.255.255.240",
+        "255.255.255.248",
+        "255.255.255.252",
+        "255.255.255.254",
+        "255.255.255.255",
+    ]
     try:
         result = buff.index(str(mask))
     except:
@@ -1794,10 +2254,14 @@ def GetNumberFromMask(mask=''):
     return str(result)
 
 
-def send_onmitracker(sender, title, text, attach, proxy=None, fake=None, request=None, uid=None):
+def send_onmitracker(
+    sender, title, text, attach, proxy=None, fake=None, request=None, uid=None
+):
     """Функция для отправки обращения напрямую в SD  получения номера зарегистрированного обращения"""
     try:
-        send_to_mattermost(f"Попытка отправки обращения в omnitracker. sender: {sender}; title:{title}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(uid)}")
+        send_to_mattermost(
+            f"Попытка отправки обращения в omnitracker. sender: {sender}; title:{title}; Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(uid)}"
+        )
     except Exception as e:
         logger.warning(f"[SEND_TO_MATTERMOST EXCEPTION] {e}")
     bodyNotEncoded = """<?xml version="1.0" encoding="utf-8"?>
@@ -1818,105 +2282,167 @@ def send_onmitracker(sender, title, text, attach, proxy=None, fake=None, request
             </tns:InvokeScript>
         </soap:Body>
         </soap:Envelope>
-        """.format(sender, title, text, str(uid), attach)
+        """.format(
+        sender, title, text, str(uid), attach
+    )
 
-    body = bodyNotEncoded.encode('utf-8')
-    logger.debug('BODY NOT ENCODED:'+str(bodyNotEncoded))
-    logger.debug('BODY ENCODED:' + str(body))
-    logger.debug('START SEND OMNI')
+    body = bodyNotEncoded.encode("utf-8")
+    logger.debug("BODY NOT ENCODED:" + str(bodyNotEncoded))
+    logger.debug("BODY ENCODED:" + str(body))
+    logger.debug("START SEND OMNI")
 
     try:
-        auth = HttpNtlmAuth('{}\\{}'.format(settings.LDAP_AUTH_CONNECTION_DOMAIN,
-                                            settings.LDAP_AUTH_CONNECTION_USERNAME),
-                                            settings.LDAP_AUTH_CONNECTION_PASSWORD)
+        auth = HttpNtlmAuth(
+            "{}\\{}".format(
+                settings.LDAP_AUTH_CONNECTION_DOMAIN,
+                settings.LDAP_AUTH_CONNECTION_USERNAME,
+            ),
+            settings.LDAP_AUTH_CONNECTION_PASSWORD,
+        )
     except Exception as e:
-        send_to_mattermost(f'Ошибка авторизации LDAP: {e}')
+        send_to_mattermost(f"Ошибка авторизации LDAP: {e}")
     result = 0
 
-
     for i in range(settings.ATTEMPS):
         try:
-            #time.sleep(5)
-            logger.debug('[{}] Отправка запроса в {}'.format(i, settings.OMNITRACKER_URL))
-            logger.debug('[TRACE] Тело запроса: ' + body.decode())
-            res = requests.post(settings.OMNITRACKER_URL, body, headers=OMNI_HTTP_HEADERS, timeout=settings.TIMEOUT, auth=auth)
+            # time.sleep(5)
+            logger.debug(
+                "[{}] Отправка запроса в {}".format(i, settings.OMNITRACKER_URL)
+            )
+            logger.debug("[TRACE] Тело запроса: " + body.decode())
+            res = requests.post(
+                settings.OMNITRACKER_URL,
+                body,
+                headers=OMNI_HTTP_HEADERS,
+                timeout=settings.TIMEOUT,
+                auth=auth,
+            )
             if i == 2:
-                send_to_mattermost(f"Попытка подключения номер: {i}.",
-                                   f"res: {res.text}",
-                                   f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
+                send_to_mattermost(
+                    f"Попытка подключения номер: {i}.",
+                    f"res: {res.text}",
+                    f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
                 )
             if res and res.status_code == 200:
-                        result = res.text
-                        logger.info('OMNITRACKER ANSWER ====' + result)
-                        if result and len(result) > 3:
-                            result = result.split('strResponse">')
-                            if len(result) > 1:
-                                result = result[1].split('</')[0]
-                            else:
-                                result = res.text.split('strResponse>')
-                                if len(result) > 1:
-                                    result = result[1].split('</')[0]
-                                else:
-                                    UpdateCallBackStatus(request, uid, 'omni_email_status',
-                                                         'Сервер omni вернул неправильный ответ', 0)
-                                    send_to_mattermost(f"[TRACE] Сервер omni вернул неправильный ответ: {res.text}"
-                                                       f"Попытка номер: {i}",
-                                                       f"Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(uid)}"
-                                                       )
-                                    if settings.DEBUG:
-                                        logger.error('[TRACE] Сервер omni вернул неправильный ответ {} '.format(res.text))
-
-                                    result = 0
-                        break
-            else:
-                    if res.status_code == 401 and not auth:
-                        if 'requests_ntlm' in sys.modules:
-                            try:
-                                auth = HttpNtlmAuth('{}\\{}'.format(settings.LDAP_AUTH_CONNECTION_DOMAIN,
-                                                                    settings.LDAP_AUTH_CONNECTION_USERNAME),
-                                                                    settings.LDAP_AUTH_CONNECTION_PASSWORD)
-                            except Exception as e:
-                                send_to_mattermost(f'Ошибка авторизации LDAP: {e}')
-                            logger.info('[TRACE] Пытаемся авторизоватся в omni')
+                result = res.text
+                logger.info("OMNITRACKER ANSWER ====" + result)
+                if result and len(result) > 3:
+                    result = result.split('strResponse">')
+                    if len(result) > 1:
+                        result = result[1].split("</")[0]
+                    else:
+                        result = res.text.split("strResponse>")
+                        if len(result) > 1:
+                            result = result[1].split("</")[0]
                         else:
-                            logger.error('Нужный модуль requests_ntlm не загружен :-(')
-                    if i >= settings.ATTEMPS:
-                        break
-                    UpdateCallBackStatus(request, uid, 'omni_email_status',
-                                         'Повторная отправка сообщения в SD ({})'.format(i), 0)
-                    sleep(i)
+                            UpdateCallBackStatus(
+                                request,
+                                uid,
+                                "omni_email_status",
+                                "Сервер omni вернул неправильный ответ",
+                                0,
+                            )
+                            send_to_mattermost(
+                                f"[TRACE] Сервер omni вернул неправильный ответ: {res.text}"
+                                f"Попытка номер: {i}",
+                                f"Ссылка на ACL :https://acl.vesta.ru/acl/info/{str(uid)}",
+                            )
+                            if settings.DEBUG:
+                                logger.error(
+                                    "[TRACE] Сервер omni вернул неправильный ответ {} ".format(
+                                        res.text
+                                    )
+                                )
+
+                            result = 0
+                break
+            else:
+                if res.status_code == 401 and not auth:
+                    if "requests_ntlm" in sys.modules:
+                        try:
+                            auth = HttpNtlmAuth(
+                                "{}\\{}".format(
+                                    settings.LDAP_AUTH_CONNECTION_DOMAIN,
+                                    settings.LDAP_AUTH_CONNECTION_USERNAME,
+                                ),
+                                settings.LDAP_AUTH_CONNECTION_PASSWORD,
+                            )
+                        except Exception as e:
+                            send_to_mattermost(f"Ошибка авторизации LDAP: {e}")
+                        logger.info("[TRACE] Пытаемся авторизоватся в omni")
+                    else:
+                        logger.error("Нужный модуль requests_ntlm не загружен :-(")
+                if i >= settings.ATTEMPS:
+                    break
+                UpdateCallBackStatus(
+                    request,
+                    uid,
+                    "omni_email_status",
+                    "Повторная отправка сообщения в SD ({})".format(i),
+                    0,
+                )
+                sleep(i)
         except requests.Timeout:
-                #if settings.DEBUG:
-                    send_to_mattermost("Подключение не удалось по таймауту (Timeout).",
-                                       f"Попытка подключения номер: {i}.",
-                                       f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
-                                       f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
-                    )
-                    logger.error('[TRACE] Подключение не удалось по таймауту к {}'.format(settings.OMNITRACKER_URL))
-                    UpdateCallBackStatus(request, uid, 'omni_email_status', 'Повторная отправка сообщения в SD ({})'.format(i), 1)
-        except requests.ConnectionError:
-            #if settings.DEBUG:
-                send_to_mattermost("Сервис не отвечает (Connection Error).",
-                               f"Попытка подключения номер: {i}.",
-                               f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
-                               f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
+            # if settings.DEBUG:
+            send_to_mattermost(
+                "Подключение не удалось по таймауту (Timeout).",
+                f"Попытка подключения номер: {i}.",
+                f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
+                f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
+            )
+            logger.error(
+                "[TRACE] Подключение не удалось по таймауту к {}".format(
+                    settings.OMNITRACKER_URL
                 )
-                logger.error('[TRACE] Сервис {} не отвечает'.format(settings.OMNITRACKER_URL))
-                UpdateCallBackStatus(request, uid, 'omni_email_status', 'Повторная отправка сообщения в SD ({})'.format(i), 1)
+            )
+            UpdateCallBackStatus(
+                request,
+                uid,
+                "omni_email_status",
+                "Повторная отправка сообщения в SD ({})".format(i),
+                1,
+            )
+        except requests.ConnectionError:
+            # if settings.DEBUG:
+            send_to_mattermost(
+                "Сервис не отвечает (Connection Error).",
+                f"Попытка подключения номер: {i}.",
+                f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
+                f"Ссылка на ACL: https://acl.vesta.ru/acl/info/{str(uid)}",
+            )
+            logger.error(
+                "[TRACE] Сервис {} не отвечает".format(settings.OMNITRACKER_URL)
+            )
+            UpdateCallBackStatus(
+                request,
+                uid,
+                "omni_email_status",
+                "Повторная отправка сообщения в SD ({})".format(i),
+                1,
+            )
 
         except Exception as e:
-            send_to_mattermost(f"Ошибка Omni request: {e}.",
-                               f"Попытка номер: {i}.",
-                               f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
-                               f"Ссылка на ACL: https://acl.vesta.ru/acl/info/ {str(uid)}",
-                               )
-            UpdateCallBackStatus(request, uid, 'omni_email_status', 'Повторная отправка сообщения в SD ({})'.format(i), 1)
-            logger.error('[Omni request] ' + str(e))
+            send_to_mattermost(
+                f"Ошибка Omni request: {e}.",
+                f"Попытка номер: {i}.",
+                f"OMNITRACKER_URL: {settings.OMNITRACKER_URL}",
+                f"Ссылка на ACL: https://acl.vesta.ru/acl/info/ {str(uid)}",
+            )
+            UpdateCallBackStatus(
+                request,
+                uid,
+                "omni_email_status",
+                "Повторная отправка сообщения в SD ({})".format(i),
+                1,
+            )
+            logger.error("[Omni request] " + str(e))
             if settings.DEBUG:
                 print(e)
     if not result:
         return 0
-    send_to_mattermost(f"Обращение [https://acl.vesta.ru/acl/info/{str(uid)}] успешно отправлено. Получен ответ: [result:{result}]. Отправитель:{sender}")
+    send_to_mattermost(
+        f"Обращение [https://acl.vesta.ru/acl/info/{str(uid)}] успешно отправлено. Получен ответ: [result:{result}]. Отправитель:{sender}"
+    )
     return result
 
 
@@ -1934,48 +2460,60 @@ def omni_check_status(id=None, proxy=None):
    </tns:InvokeScript>
 </soap:Body>
 </soap:Envelope>
-""".format(id).encode('utf-8')
-    result = ''
-
+""".format(
+        id
+    ).encode(
+        "utf-8"
+    )
+    result = ""
 
     try:
-        auth = HttpNtlmAuth('{}\\{}'.format(settings.LDAP_AUTH_CONNECTION_DOMAIN,
-                                            settings.LDAP_AUTH_CONNECTION_USERNAME),
-                                            settings.LDAP_AUTH_CONNECTION_PASSWORD)
+        auth = HttpNtlmAuth(
+            "{}\\{}".format(
+                settings.LDAP_AUTH_CONNECTION_DOMAIN,
+                settings.LDAP_AUTH_CONNECTION_USERNAME,
+            ),
+            settings.LDAP_AUTH_CONNECTION_PASSWORD,
+        )
     except Exception as e:
-        logger.error(f'Ошибка авторизации LDAP: {e}')
+        logger.error(f"Ошибка авторизации LDAP: {e}")
 
     try:
-        r = requests.post(settings.OMNITRACKER_URL, body, headers=OMNI_HTTP_HEADERS, proxies=proxy,
-                          auth=auth, timeout=1)
+        r = requests.post(
+            settings.OMNITRACKER_URL,
+            body,
+            headers=OMNI_HTTP_HEADERS,
+            proxies=proxy,
+            auth=auth,
+            timeout=1,
+        )
         if r.status_code == 200:
             try:
                 result = r.text
                 if result and len(result) > 3:
                     result = result.split('strResponse">')
-                    result = result[1].split('</')[0]
-                #return result
+                    result = result[1].split("</")[0]
+                # return result
             except Exception as e:
-                logger.error('[Check status] ' + str(e))
+                logger.error("[Check status] " + str(e))
                 if settings.DEBUG:
                     print(e)
-                #return r.text
+                # return r.text
 
     except Exception as e:
-        result = ''
-        logger.info(f'Ошибка: {e}')
+        result = ""
+        logger.info(f"Ошибка: {e}")
 
     finally:
         if result in OMNI_HTTP_STATUS:
             return OMNI_ACL_STATUS[result], OMNI_HTTP_STATUS[result]
         else:
             return None, None
-        #return OMNI_ACL_STATUS[result], OMNI_HTTP_STATUS[result]
+        # return OMNI_ACL_STATUS[result], OMNI_HTTP_STATUS[result]
 
 
-
-def SendMessageToApprove(acl_id, acl_owner, user, token=''):
-    EMAIL_APPROVE = '''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+def SendMessageToApprove(acl_id, acl_owner, user, token=""):
+    EMAIL_APPROVE = """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
     <html xmlns="http://www.w3.org/1999/xhtml"><head>
     <meta charset="utf-8"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
     <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
@@ -1999,19 +2537,26 @@ def SendMessageToApprove(acl_id, acl_owner, user, token=''):
     </div>
     </body>
     </html>
-                                    ''' % (
-    acl_owner, "https://acl.vesta.ru/acl/pending/{}/?token={}".format(acl_id, token))
-
-    e = EmailMessage(subject='Согласование обращения'+str(user.username), body=EMAIL_APPROVE, from_email='acl@alfastrah.ru',
-                     to=[user.email])
+                                    """ % (
+        acl_owner,
+        "https://acl.vesta.ru/acl/pending/{}/?token={}".format(acl_id, token),
+    )
+
+    e = EmailMessage(
+        subject="Согласование обращения" + str(user.username),
+        body=EMAIL_APPROVE,
+        from_email="acl@alfastrah.ru",
+        to=[user.email],
+    )
     e.content_subtype = "html"
     e.send(fail_silently=settings.DEBUG)
     if settings.DEBUG:
         print("https://acl.vesta.ru/acl/pending/{}/?token={}".format(acl_id, token))
 
+
 def send_to_mattermost(*messages):
     try:
-        text = ''
+        text = ""
 
         for message in messages:
             text += f"{message}\n"
@@ -2020,117 +2565,154 @@ def send_to_mattermost(*messages):
         response = requests.post(settings.MATTERMOST_WEBHOOK_URL, json=payload)
         logger.info(f"response = {response}")
         if response.status_code != 200:
-            logger.warning("[Send to Mattermost] Failed to send message. Error: ", response.status_code)
+            logger.warning(
+                "[Send to Mattermost] Failed to send message. Error: ",
+                response.status_code,
+            )
     except Exception as e:
         logger.error(e)
 
 
-def get_gitlab_project_info(session, repo_url: str, mode: str = ''):
+def get_gitlab_project_info(session, repo_url: str, mode: str = ""):
     try:
-        logger.info(f'[GET_GITLAB_PROJECT_INFO] Получение информации о проекте.')
+        logger.info("[GET_GITLAB_PROJECT_INFO] Получение информации о проекте.")
         # base_api_url = f"https://{request.session['GIT_USERNAME']}%40alfastrah.ru:{request.session['GIT_PASSWORD']}@gitlab.alfastrah.ru/api/v4/projects"
-        base_api_url = f"https://gitlab.alfastrah.ru/api/v4/projects"
-        project_namespace = "/".join(repo_url.split('/')[3:-1]).replace('/', '%2F')
-        logger.info(f'[GET_GITLAB_PROJECT_INFO] Получен project namespace:{project_namespace}')
-        repo_url_parts = repo_url.split('/')
+        base_api_url = "https://gitlab.alfastrah.ru/api/v4/projects"
+        project_namespace = "/".join(repo_url.split("/")[3:-1]).replace("/", "%2F")
+        logger.info(
+            f"[GET_GITLAB_PROJECT_INFO] Получен project namespace:{project_namespace}"
+        )
+        repo_url_parts = repo_url.split("/")
         project_name_with_extension = repo_url_parts[-1]
         project_name = os.path.splitext(project_name_with_extension)[0]
-        logger.info(f'[GET_GITLAB_PROJECT_INFO] Получен project_name:{project_name}')
+        logger.info(f"[GET_GITLAB_PROJECT_INFO] Получен project_name:{project_name}")
         project_id = None
         get_project_id_api = f"{base_api_url}/{project_namespace}%2F{project_name}"
         response = session.get(get_project_id_api)
         if response.status_code == 200:
-            project_id = int(response.json()['id']) or None
+            project_id = int(response.json()["id"]) or None
 
         if project_id is not None:
-            logger.info(f'[GET_GITLAB_PROJECT_INFO] Получен project_id:{project_id}')
-            if mode == 'id':
+            logger.info(f"[GET_GITLAB_PROJECT_INFO] Получен project_id:{project_id}")
+            if mode == "id":
                 return project_id
-            info = {'namespace':project_namespace, 'project_name':project_name, 'project_id':project_id}
+            info = {
+                "namespace": project_namespace,
+                "project_name": project_name,
+                "project_id": project_id,
+            }
             return info
     except Exception as e:
         logger.error(f"Ошибка при получении информации gitlab: {e}")
 
-def get_files_from_gitlab(repo_url: str, branch_name: str = 'develop'):
+
+def get_files_from_gitlab(repo_url: str, branch_name: str = "develop"):
     file_list = []
     try:
         session = requests.Session()
-        session.headers.update({'PRIVATE-TOKEN': settings.GIT_ACCESS_TOKEN})
-        project_id = get_gitlab_project_info(session, repo_url)['project_id']
-        base_api_url = f"https://gitlab.alfastrah.ru/api/v4/projects"
-        get_file_list_api = f"{base_api_url}/{project_id}/repository/tree?ref={branch_name}"
+        session.headers.update({"PRIVATE-TOKEN": settings.GIT_ACCESS_TOKEN})
+        project_id = get_gitlab_project_info(session, repo_url)["project_id"]
+        base_api_url = "https://gitlab.alfastrah.ru/api/v4/projects"
+        get_file_list_api = (
+            f"{base_api_url}/{project_id}/repository/tree?ref={branch_name}"
+        )
         response = session.get(get_file_list_api)
         if response.status_code == 200:
-            file_list = [file_name['name'] for file_name in response.json() if ".md" in file_name['name']]
-            logger.info(f'[GET_FILES_FROM_GITLAB] Список файлов успешно получен')
+            file_list = [
+                file_name["name"]
+                for file_name in response.json()
+                if ".md" in file_name["name"]
+            ]
+            logger.info("[GET_FILES_FROM_GITLAB] Список файлов успешно получен")
     except Exception as e:
         logger.error(f"Ошибка при получении списка файлов:{e}")
     finally:
         return file_list
 
-def get_acl_from_gitlab(repo_url: str, branch_name: str = 'develop', file_name:str = ''):
+
+def get_acl_from_gitlab(
+    repo_url: str, branch_name: str = "develop", file_name: str = ""
+):
     """Получает acl в формате str из gitlab"""
     try:
-        logger.info(f'[GET_ACL_FROM_GITLAB] Получаю acl в формате str из gitlab')
+        logger.info("[GET_ACL_FROM_GITLAB] Получаю acl в формате str из gitlab")
         session = requests.Session()
-        session.headers.update({'PRIVATE-TOKEN': settings.GIT_ACCESS_TOKEN})
-        project_id = get_gitlab_project_info(session, repo_url)['project_id']
+        session.headers.update({"PRIVATE-TOKEN": settings.GIT_ACCESS_TOKEN})
+        project_id = get_gitlab_project_info(session, repo_url)["project_id"]
         get_file_content_api = f"https://gitlab.alfastrah.ru/api/v4/projects/{project_id}/repository/files/{file_name}?ref={branch_name}"
         response = session.get(get_file_content_api)
         if response.status_code == 200:
-            logger.info(f'[GET_ACL_FROM_GITLAB] acl получен из gitlab. Обработка к необходимому формату.')
-            encoded_file_content = response.json()['content']
-            decoded_file_content = base64.b64decode(encoded_file_content).decode('utf-8')
-            project_desc = get_project_desc_from_git(session=session, project_id=str(project_id))
+            logger.info(
+                "[GET_ACL_FROM_GITLAB] acl получен из gitlab. Обработка к необходимому формату."
+            )
+            encoded_file_content = response.json()["content"]
+            decoded_file_content = base64.b64decode(encoded_file_content).decode(
+                "utf-8"
+            )
+            project_desc = get_project_desc_from_git(
+                session=session, project_id=str(project_id)
+            )
             return decoded_file_content, project_desc
-        logger.info(f'[GET_ACL_FROM_GITLAB] Не удалось получить acl из gitlab')
+        logger.info("[GET_ACL_FROM_GITLAB] Не удалось получить acl из gitlab")
         return
     except Exception as e:
-        logger.error(f'[ПОЛУЧЕНИЕ md_content] Ошибка: {e}')
+        logger.error(f"[ПОЛУЧЕНИЕ md_content] Ошибка: {e}")
+
 
 def convert_md_to_dict(md_content: str):
     try:
         LOCAL_STORAGE = {}
         result = {}
-        lines = md_content.split('\n')
+        lines = md_content.split("\n")
 
         current_section = None
         for idx, line in enumerate(lines):
             line = line.strip()
-            if line.startswith('##### Описание доступа к ресурсам'):
-                current_section = 'acl_create_info.html'
+            if line.startswith("##### Описание доступа к ресурсам"):
+                current_section = "acl_create_info.html"
                 LOCAL_STORAGE[current_section] = []
 
-            elif line.startswith('##### Список внутренних ресурсов'):
-                current_section = 'acl_internal_resources.html'
+            elif line.startswith("##### Список внутренних ресурсов"):
+                current_section = "acl_internal_resources.html"
                 LOCAL_STORAGE[current_section] = []
 
-            elif line.startswith('##### Список DMZ ресурсов'):
-                current_section = 'acl_dmz_resources.html'
+            elif line.startswith("##### Список DMZ ресурсов"):
+                current_section = "acl_dmz_resources.html"
                 LOCAL_STORAGE[current_section] = []
 
-            elif line.startswith('##### Список внешних ресурсов'):
-                current_section = 'acl_external_resources.html'
+            elif line.startswith("##### Список внешних ресурсов"):
+                current_section = "acl_external_resources.html"
                 LOCAL_STORAGE[current_section] = []
 
-            elif line.startswith('##### Потоки трафика'):
-                current_section = 'acl_traffic.html'
+            elif line.startswith("##### Потоки трафика"):
+                current_section = "acl_traffic.html"
                 LOCAL_STORAGE[current_section] = []
 
-            elif line.startswith('|'):
-                if current_section == 'acl_create_info.html':
-                    parts = [p.strip() for p in line.split('|')[1:-1]]
-                    if re.match('^:--', parts[0]) or parts == contact_column:
-                       continue
+            elif line.startswith("|"):
+                if current_section == "acl_create_info.html":
+                    parts = [p.strip() for p in line.split("|")[1:-1]]
+                    if re.match("^:--", parts[0]) or parts == contact_column:
+                        continue
                     LOCAL_STORAGE[current_section].append(parts[1])
 
-                elif current_section in ['acl_internal_resources.html', 'acl_dmz_resources.html', 'acl_external_resources.html', 'acl_traffic.html']:
-                    parts = [p.strip() for p in line.split('|')[1:-1]]
-                    if len(parts) > 0 and re.match('^:--', parts[0]) or parts == standart_column or parts == external_column or parts == traffic_column:
+                elif current_section in [
+                    "acl_internal_resources.html",
+                    "acl_dmz_resources.html",
+                    "acl_external_resources.html",
+                    "acl_traffic.html",
+                ]:
+                    parts = [p.strip() for p in line.split("|")[1:-1]]
+                    if (
+                        len(parts) > 0
+                        and re.match("^:--", parts[0])
+                        or parts == standart_column
+                        or parts == external_column
+                        or set(parts).issubset(set(traffic_column))
+                    ):
                         continue
                     LOCAL_STORAGE[current_section].append(parts)
 
-        result['LOCAL_STORAGE'] = LOCAL_STORAGE
+        result["LOCAL_STORAGE"] = LOCAL_STORAGE
         return result
     except Exception as e:
         logger.error(e)
@@ -2154,10 +2736,11 @@ def acl_sending_retry_checking(acl_object):
     else:
         return None
 
+
 def check_taskId_by_uuid(uuid, proxy=None):
-    '''Функция проверяет номер SD по номеру UUID в omnitracker'''
+    """Функция проверяет номер SD по номеру UUID в omnitracker"""
 
-    body = '''<?xml version="1.0" encoding="utf-8"?>
+    body = """<?xml version="1.0" encoding="utf-8"?>
     <soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://www.omninet.de/OtWebSvc/v1">
       <soap:Body>
         <tns:InvokeScript>
@@ -2170,60 +2753,85 @@ def check_taskId_by_uuid(uuid, proxy=None):
         </tns:InvokeScript>
       </soap:Body>
     </soap:Envelope>
-    '''.format(str(uuid)).encode('utf-8')
+    """.format(
+        str(uuid)
+    ).encode(
+        "utf-8"
+    )
     try:
-        auth = HttpNtlmAuth('{}\\{}'.format(settings.LDAP_AUTH_CONNECTION_DOMAIN,
-                                            settings.LDAP_AUTH_CONNECTION_USERNAME),
-                                            settings.LDAP_AUTH_CONNECTION_PASSWORD)
+        auth = HttpNtlmAuth(
+            "{}\\{}".format(
+                settings.LDAP_AUTH_CONNECTION_DOMAIN,
+                settings.LDAP_AUTH_CONNECTION_USERNAME,
+            ),
+            settings.LDAP_AUTH_CONNECTION_PASSWORD,
+        )
     except Exception as e:
-        logger.error(f'Ошибка авторизации LDAP: {e}')
+        logger.error(f"Ошибка авторизации LDAP: {e}")
     try:
-        response = requests.post(settings.OMNITRACKER_URL, body, headers=OMNI_HTTP_HEADERS, proxies=proxy,
-                          auth=auth)
+        response = requests.post(
+            settings.OMNITRACKER_URL,
+            body,
+            headers=OMNI_HTTP_HEADERS,
+            proxies=proxy,
+            auth=auth,
+        )
         if response and response.status_code == 200:
 
             result = response.text
-            logger.info('OMNITRACKER ANSWER ====' + result)
+            logger.info("OMNITRACKER ANSWER ====" + result)
 
             if result and len(result) > 3:
                 result = result.split('strResponse">')
                 if len(result) > 1:
-                    result = result[1].split('</')[0]
+                    result = result[1].split("</")[0]
                 else:
-                    result = response.text.split('strResponse>')
+                    result = response.text.split("strResponse>")
                     if len(result) > 1:
-                        result = result[1].split('</')[0]
+                        result = result[1].split("</")[0]
                     else:
-                        logger.warning(f'uuid: {uuid}. Сервер omni вернул неправильный ответ')
-                        result = ''
+                        logger.warning(
+                            f"uuid: {uuid}. Сервер omni вернул неправильный ответ"
+                        )
+                        result = ""
     except Exception as e:
-        logger.error(f'[check_taskId_by_uuid] Error: {e}')
-        result = ''
+        logger.error(f"[check_taskId_by_uuid] Error: {e}")
+        result = ""
 
     try:
         result = int(result)
     except:
-        result = ''
+        result = ""
     return str(result)
 
-def sync_acl_portal_projects_list(group_name : str = "ACL"):
+
+def sync_acl_portal_projects_list(group_name: str = "ACL"):
     project_list = []
     session = requests.Session()
-    session.headers.update({'PRIVATE-TOKEN': settings.GIT_ACCESS_TOKEN})
+    session.headers.update({"PRIVATE-TOKEN": settings.GIT_ACCESS_TOKEN})
 
     def get_subgroup_projects(group_id, path=""):
         try:
-            url_get_projects = f"https://gitlab.alfastrah.ru/api/v4/groups/{group_id}/projects"
+            url_get_projects = (
+                f"https://gitlab.alfastrah.ru/api/v4/groups/{group_id}/projects"
+            )
             response = session.get(url_get_projects)
             if response.status_code == 200:
                 for project in response.json():
                     full_path = f"{path}/{project['name']}".lstrip("/")
-                    project_list.append({'full_path': full_path, 'http_url_to_repo': project['http_url_to_repo']})
+                    project_list.append(
+                        {
+                            "full_path": full_path,
+                            "http_url_to_repo": project["http_url_to_repo"],
+                        }
+                    )
         except Exception as e:
             logger.error(f"Ошибка при получении проектов из подгруппы: {e}")
 
         try:
-            url_get_subgroups = f'https://gitlab.alfastrah.ru/api/v4/groups/{group_id}/subgroups'
+            url_get_subgroups = (
+                f"https://gitlab.alfastrah.ru/api/v4/groups/{group_id}/subgroups"
+            )
             response = session.get(url_get_subgroups)
             if response.status_code == 200:
                 for subgroup in response.json():
@@ -2233,7 +2841,9 @@ def sync_acl_portal_projects_list(group_name : str = "ACL"):
             logger.error(f"Ошибка при получении подгрупп из подгруппы: {e}")
 
     try:
-        url_get_subgroups = f'https://gitlab.alfastrah.ru/api/v4/groups/{group_name}/subgroups'
+        url_get_subgroups = (
+            f"https://gitlab.alfastrah.ru/api/v4/groups/{group_name}/subgroups"
+        )
         response = session.get(url_get_subgroups)
         if response.status_code == 200:
             for block in response.json():
@@ -2243,15 +2853,16 @@ def sync_acl_portal_projects_list(group_name : str = "ACL"):
         logger.error(f"Ошибка при получении блоков: {e}")
     return project_list
 
-def get_project_desc_from_git(session=None, project_id=''):
-    project_desc = ''
+
+def get_project_desc_from_git(session=None, project_id=""):
+    project_desc = ""
     try:
-        get_custom_attributes_from_git = f'https://gitlab.alfastrah.ru/api/v4/projects/{project_id}/custom_attributes/project_description'
+        get_custom_attributes_from_git = f"https://gitlab.alfastrah.ru/api/v4/projects/{project_id}/custom_attributes/project_description"
         response = session.get(get_custom_attributes_from_git)
         if response.status_code == 200:
             project_desc = response.json()["value"]
         elif response.status_code == 404:
             logger.info("Атрибут project_description не найден в gitlab.")
-    except Exception as e:
-        logger.error(f'Ошибка: не удалось получить описание проекта из gitlab.')
+    except Exception:
+        logger.error("Ошибка: не удалось получить описание проекта из gitlab.")
     return project_desc
\ No newline at end of file


==== File: static/css/style.css ====
@@ -655,6 +655,14 @@ input:not([type='checkbox']):valid+span:after, textarea:valid+span:after {
 
 .table-ip-internal th{
     text-align: center;
+    background-color: #f8f9fa;
+}
+
+.table-ip-internal th, .table-ip-internal td {
+  text-align: center;
+  word-wrap: break-word;
+  white-space: nowrap;
+  padding: 8px;
 }
 
 .table-ip-internal tr{


